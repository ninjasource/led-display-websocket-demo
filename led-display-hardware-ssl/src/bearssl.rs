/* automatically generated by rust-bindgen */
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const BR_HASHDESC_ID_OFF: u32 = 0;
pub const BR_HASHDESC_ID_MASK: u32 = 255;
pub const BR_HASHDESC_OUT_OFF: u32 = 8;
pub const BR_HASHDESC_OUT_MASK: u32 = 127;
pub const BR_HASHDESC_STATE_OFF: u32 = 15;
pub const BR_HASHDESC_STATE_MASK: u32 = 255;
pub const BR_HASHDESC_LBLEN_OFF: u32 = 23;
pub const BR_HASHDESC_LBLEN_MASK: u32 = 15;
pub const br_md5_ID: u32 = 1;
pub const br_md5_SIZE: u32 = 16;
pub const br_sha1_ID: u32 = 2;
pub const br_sha1_SIZE: u32 = 20;
pub const br_sha224_ID: u32 = 3;
pub const br_sha224_SIZE: u32 = 28;
pub const br_sha256_ID: u32 = 4;
pub const br_sha256_SIZE: u32 = 32;
pub const br_sha384_ID: u32 = 5;
pub const br_sha384_SIZE: u32 = 48;
pub const br_sha512_ID: u32 = 6;
pub const br_sha512_SIZE: u32 = 64;
pub const br_md5sha1_ID: u32 = 0;
pub const br_md5sha1_SIZE: u32 = 36;
pub const br_aes_big_BLOCK_SIZE: u32 = 16;
pub const br_aes_small_BLOCK_SIZE: u32 = 16;
pub const br_aes_ct_BLOCK_SIZE: u32 = 16;
pub const br_aes_ct64_BLOCK_SIZE: u32 = 16;
pub const br_aes_x86ni_BLOCK_SIZE: u32 = 16;
pub const br_aes_pwr8_BLOCK_SIZE: u32 = 16;
pub const br_des_tab_BLOCK_SIZE: u32 = 8;
pub const br_des_ct_BLOCK_SIZE: u32 = 8;
pub const BR_EC_sect163k1: u32 = 1;
pub const BR_EC_sect163r1: u32 = 2;
pub const BR_EC_sect163r2: u32 = 3;
pub const BR_EC_sect193r1: u32 = 4;
pub const BR_EC_sect193r2: u32 = 5;
pub const BR_EC_sect233k1: u32 = 6;
pub const BR_EC_sect233r1: u32 = 7;
pub const BR_EC_sect239k1: u32 = 8;
pub const BR_EC_sect283k1: u32 = 9;
pub const BR_EC_sect283r1: u32 = 10;
pub const BR_EC_sect409k1: u32 = 11;
pub const BR_EC_sect409r1: u32 = 12;
pub const BR_EC_sect571k1: u32 = 13;
pub const BR_EC_sect571r1: u32 = 14;
pub const BR_EC_secp160k1: u32 = 15;
pub const BR_EC_secp160r1: u32 = 16;
pub const BR_EC_secp160r2: u32 = 17;
pub const BR_EC_secp192k1: u32 = 18;
pub const BR_EC_secp192r1: u32 = 19;
pub const BR_EC_secp224k1: u32 = 20;
pub const BR_EC_secp224r1: u32 = 21;
pub const BR_EC_secp256k1: u32 = 22;
pub const BR_EC_secp256r1: u32 = 23;
pub const BR_EC_secp384r1: u32 = 24;
pub const BR_EC_secp521r1: u32 = 25;
pub const BR_EC_brainpoolP256r1: u32 = 26;
pub const BR_EC_brainpoolP384r1: u32 = 27;
pub const BR_EC_brainpoolP512r1: u32 = 28;
pub const BR_EC_curve25519: u32 = 29;
pub const BR_EC_curve448: u32 = 30;
pub const BR_EC_KBUF_PRIV_MAX_SIZE: u32 = 72;
pub const BR_EC_KBUF_PUB_MAX_SIZE: u32 = 145;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const BR_ERR_X509_OK: u32 = 32;
pub const BR_ERR_X509_INVALID_VALUE: u32 = 33;
pub const BR_ERR_X509_TRUNCATED: u32 = 34;
pub const BR_ERR_X509_EMPTY_CHAIN: u32 = 35;
pub const BR_ERR_X509_INNER_TRUNC: u32 = 36;
pub const BR_ERR_X509_BAD_TAG_CLASS: u32 = 37;
pub const BR_ERR_X509_BAD_TAG_VALUE: u32 = 38;
pub const BR_ERR_X509_INDEFINITE_LENGTH: u32 = 39;
pub const BR_ERR_X509_EXTRA_ELEMENT: u32 = 40;
pub const BR_ERR_X509_UNEXPECTED: u32 = 41;
pub const BR_ERR_X509_NOT_CONSTRUCTED: u32 = 42;
pub const BR_ERR_X509_NOT_PRIMITIVE: u32 = 43;
pub const BR_ERR_X509_PARTIAL_BYTE: u32 = 44;
pub const BR_ERR_X509_BAD_BOOLEAN: u32 = 45;
pub const BR_ERR_X509_OVERFLOW: u32 = 46;
pub const BR_ERR_X509_BAD_DN: u32 = 47;
pub const BR_ERR_X509_BAD_TIME: u32 = 48;
pub const BR_ERR_X509_UNSUPPORTED: u32 = 49;
pub const BR_ERR_X509_LIMIT_EXCEEDED: u32 = 50;
pub const BR_ERR_X509_WRONG_KEY_TYPE: u32 = 51;
pub const BR_ERR_X509_BAD_SIGNATURE: u32 = 52;
pub const BR_ERR_X509_TIME_UNKNOWN: u32 = 53;
pub const BR_ERR_X509_EXPIRED: u32 = 54;
pub const BR_ERR_X509_DN_MISMATCH: u32 = 55;
pub const BR_ERR_X509_BAD_SERVER_NAME: u32 = 56;
pub const BR_ERR_X509_CRITICAL_EXTENSION: u32 = 57;
pub const BR_ERR_X509_NOT_CA: u32 = 58;
pub const BR_ERR_X509_FORBIDDEN_KEY_USAGE: u32 = 59;
pub const BR_ERR_X509_WEAK_PUBLIC_KEY: u32 = 60;
pub const BR_ERR_X509_NOT_TRUSTED: u32 = 62;
pub const BR_X509_TA_CA: u32 = 1;
pub const BR_KEYTYPE_RSA: u32 = 1;
pub const BR_KEYTYPE_EC: u32 = 2;
pub const BR_KEYTYPE_KEYX: u32 = 16;
pub const BR_KEYTYPE_SIGN: u32 = 32;
pub const BR_X509_BUFSIZE_KEY: u32 = 520;
pub const BR_X509_BUFSIZE_SIG: u32 = 512;
pub const BR_ENCODE_PEM_RSA_RAW: &'static [u8; 16usize] = b"RSA PRIVATE KEY\0";
pub const BR_ENCODE_PEM_EC_RAW: &'static [u8; 15usize] = b"EC PRIVATE KEY\0";
pub const BR_ENCODE_PEM_PKCS8: &'static [u8; 12usize] = b"PRIVATE KEY\0";
pub const BR_SSL_BUFSIZE_INPUT: u32 = 16709;
pub const BR_SSL_BUFSIZE_OUTPUT: u32 = 16469;
pub const BR_SSL_BUFSIZE_MONO: u32 = 16709;
pub const BR_SSL_BUFSIZE_BIDI: u32 = 33178;
pub const BR_SSL30: u32 = 768;
pub const BR_TLS10: u32 = 769;
pub const BR_TLS11: u32 = 770;
pub const BR_TLS12: u32 = 771;
pub const BR_ERR_OK: u32 = 0;
pub const BR_ERR_BAD_PARAM: u32 = 1;
pub const BR_ERR_BAD_STATE: u32 = 2;
pub const BR_ERR_UNSUPPORTED_VERSION: u32 = 3;
pub const BR_ERR_BAD_VERSION: u32 = 4;
pub const BR_ERR_BAD_LENGTH: u32 = 5;
pub const BR_ERR_TOO_LARGE: u32 = 6;
pub const BR_ERR_BAD_MAC: u32 = 7;
pub const BR_ERR_NO_RANDOM: u32 = 8;
pub const BR_ERR_UNKNOWN_TYPE: u32 = 9;
pub const BR_ERR_UNEXPECTED: u32 = 10;
pub const BR_ERR_BAD_CCS: u32 = 12;
pub const BR_ERR_BAD_ALERT: u32 = 13;
pub const BR_ERR_BAD_HANDSHAKE: u32 = 14;
pub const BR_ERR_OVERSIZED_ID: u32 = 15;
pub const BR_ERR_BAD_CIPHER_SUITE: u32 = 16;
pub const BR_ERR_BAD_COMPRESSION: u32 = 17;
pub const BR_ERR_BAD_FRAGLEN: u32 = 18;
pub const BR_ERR_BAD_SECRENEG: u32 = 19;
pub const BR_ERR_EXTRA_EXTENSION: u32 = 20;
pub const BR_ERR_BAD_SNI: u32 = 21;
pub const BR_ERR_BAD_HELLO_DONE: u32 = 22;
pub const BR_ERR_LIMIT_EXCEEDED: u32 = 23;
pub const BR_ERR_BAD_FINISHED: u32 = 24;
pub const BR_ERR_RESUME_MISMATCH: u32 = 25;
pub const BR_ERR_INVALID_ALGORITHM: u32 = 26;
pub const BR_ERR_BAD_SIGNATURE: u32 = 27;
pub const BR_ERR_WRONG_KEY_USAGE: u32 = 28;
pub const BR_ERR_NO_CLIENT_AUTH: u32 = 29;
pub const BR_ERR_IO: u32 = 31;
pub const BR_ERR_RECV_FATAL_ALERT: u32 = 256;
pub const BR_ERR_SEND_FATAL_ALERT: u32 = 512;
pub const BR_MAX_CIPHER_SUITES: u32 = 48;
pub const BR_SSL_CLOSED: u32 = 1;
pub const BR_SSL_SENDREC: u32 = 2;
pub const BR_SSL_RECVREC: u32 = 4;
pub const BR_SSL_SENDAPP: u32 = 8;
pub const BR_SSL_RECVAPP: u32 = 16;
pub const BR_AUTH_ECDH: u32 = 0;
pub const BR_AUTH_RSA: u32 = 1;
pub const BR_AUTH_ECDSA: u32 = 3;
pub const BR_SSLKEYX_RSA: u32 = 0;
pub const BR_SSLKEYX_ECDHE_RSA: u32 = 1;
pub const BR_SSLKEYX_ECDHE_ECDSA: u32 = 2;
pub const BR_SSLKEYX_ECDH_RSA: u32 = 3;
pub const BR_SSLKEYX_ECDH_ECDSA: u32 = 4;
pub const BR_SSLENC_3DES_CBC: u32 = 0;
pub const BR_SSLENC_AES128_CBC: u32 = 1;
pub const BR_SSLENC_AES256_CBC: u32 = 2;
pub const BR_SSLENC_AES128_GCM: u32 = 3;
pub const BR_SSLENC_AES256_GCM: u32 = 4;
pub const BR_SSLENC_CHACHA20: u32 = 5;
pub const BR_SSLMAC_AEAD: u32 = 0;
pub const BR_SSLMAC_SHA1: u32 = 2;
pub const BR_SSLMAC_SHA256: u32 = 4;
pub const BR_SSLMAC_SHA384: u32 = 5;
pub const BR_SSLPRF_SHA256: u32 = 4;
pub const BR_SSLPRF_SHA384: u32 = 5;
pub const BR_TLS_NULL_WITH_NULL_NULL: u32 = 0;
pub const BR_TLS_RSA_WITH_NULL_MD5: u32 = 1;
pub const BR_TLS_RSA_WITH_NULL_SHA: u32 = 2;
pub const BR_TLS_RSA_WITH_NULL_SHA256: u32 = 59;
pub const BR_TLS_RSA_WITH_RC4_128_MD5: u32 = 4;
pub const BR_TLS_RSA_WITH_RC4_128_SHA: u32 = 5;
pub const BR_TLS_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 10;
pub const BR_TLS_RSA_WITH_AES_128_CBC_SHA: u32 = 47;
pub const BR_TLS_RSA_WITH_AES_256_CBC_SHA: u32 = 53;
pub const BR_TLS_RSA_WITH_AES_128_CBC_SHA256: u32 = 60;
pub const BR_TLS_RSA_WITH_AES_256_CBC_SHA256: u32 = 61;
pub const BR_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA: u32 = 13;
pub const BR_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 16;
pub const BR_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA: u32 = 19;
pub const BR_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 22;
pub const BR_TLS_DH_DSS_WITH_AES_128_CBC_SHA: u32 = 48;
pub const BR_TLS_DH_RSA_WITH_AES_128_CBC_SHA: u32 = 49;
pub const BR_TLS_DHE_DSS_WITH_AES_128_CBC_SHA: u32 = 50;
pub const BR_TLS_DHE_RSA_WITH_AES_128_CBC_SHA: u32 = 51;
pub const BR_TLS_DH_DSS_WITH_AES_256_CBC_SHA: u32 = 54;
pub const BR_TLS_DH_RSA_WITH_AES_256_CBC_SHA: u32 = 55;
pub const BR_TLS_DHE_DSS_WITH_AES_256_CBC_SHA: u32 = 56;
pub const BR_TLS_DHE_RSA_WITH_AES_256_CBC_SHA: u32 = 57;
pub const BR_TLS_DH_DSS_WITH_AES_128_CBC_SHA256: u32 = 62;
pub const BR_TLS_DH_RSA_WITH_AES_128_CBC_SHA256: u32 = 63;
pub const BR_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256: u32 = 64;
pub const BR_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 103;
pub const BR_TLS_DH_DSS_WITH_AES_256_CBC_SHA256: u32 = 104;
pub const BR_TLS_DH_RSA_WITH_AES_256_CBC_SHA256: u32 = 105;
pub const BR_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256: u32 = 106;
pub const BR_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: u32 = 107;
pub const BR_TLS_DH_anon_WITH_RC4_128_MD5: u32 = 24;
pub const BR_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA: u32 = 27;
pub const BR_TLS_DH_anon_WITH_AES_128_CBC_SHA: u32 = 52;
pub const BR_TLS_DH_anon_WITH_AES_256_CBC_SHA: u32 = 58;
pub const BR_TLS_DH_anon_WITH_AES_128_CBC_SHA256: u32 = 108;
pub const BR_TLS_DH_anon_WITH_AES_256_CBC_SHA256: u32 = 109;
pub const BR_TLS_ECDH_ECDSA_WITH_NULL_SHA: u32 = 49153;
pub const BR_TLS_ECDH_ECDSA_WITH_RC4_128_SHA: u32 = 49154;
pub const BR_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49155;
pub const BR_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49156;
pub const BR_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49157;
pub const BR_TLS_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 49158;
pub const BR_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA: u32 = 49159;
pub const BR_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49160;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49161;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49162;
pub const BR_TLS_ECDH_RSA_WITH_NULL_SHA: u32 = 49163;
pub const BR_TLS_ECDH_RSA_WITH_RC4_128_SHA: u32 = 49164;
pub const BR_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49165;
pub const BR_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 49166;
pub const BR_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 49167;
pub const BR_TLS_ECDHE_RSA_WITH_NULL_SHA: u32 = 49168;
pub const BR_TLS_ECDHE_RSA_WITH_RC4_128_SHA: u32 = 49169;
pub const BR_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49170;
pub const BR_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 49171;
pub const BR_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 49172;
pub const BR_TLS_ECDH_anon_WITH_NULL_SHA: u32 = 49173;
pub const BR_TLS_ECDH_anon_WITH_RC4_128_SHA: u32 = 49174;
pub const BR_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA: u32 = 49175;
pub const BR_TLS_ECDH_anon_WITH_AES_128_CBC_SHA: u32 = 49176;
pub const BR_TLS_ECDH_anon_WITH_AES_256_CBC_SHA: u32 = 49177;
pub const BR_TLS_RSA_WITH_AES_128_GCM_SHA256: u32 = 156;
pub const BR_TLS_RSA_WITH_AES_256_GCM_SHA384: u32 = 157;
pub const BR_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 158;
pub const BR_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 159;
pub const BR_TLS_DH_RSA_WITH_AES_128_GCM_SHA256: u32 = 160;
pub const BR_TLS_DH_RSA_WITH_AES_256_GCM_SHA384: u32 = 161;
pub const BR_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256: u32 = 162;
pub const BR_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384: u32 = 163;
pub const BR_TLS_DH_DSS_WITH_AES_128_GCM_SHA256: u32 = 164;
pub const BR_TLS_DH_DSS_WITH_AES_256_GCM_SHA384: u32 = 165;
pub const BR_TLS_DH_anon_WITH_AES_128_GCM_SHA256: u32 = 166;
pub const BR_TLS_DH_anon_WITH_AES_256_GCM_SHA384: u32 = 167;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49187;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49188;
pub const BR_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49189;
pub const BR_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49190;
pub const BR_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 49191;
pub const BR_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: u32 = 49192;
pub const BR_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: u32 = 49193;
pub const BR_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: u32 = 49194;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49195;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49196;
pub const BR_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49197;
pub const BR_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49198;
pub const BR_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 49199;
pub const BR_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 49200;
pub const BR_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 49201;
pub const BR_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 49202;
pub const BR_TLS_RSA_WITH_AES_128_CCM: u32 = 49308;
pub const BR_TLS_RSA_WITH_AES_256_CCM: u32 = 49309;
pub const BR_TLS_RSA_WITH_AES_128_CCM_8: u32 = 49312;
pub const BR_TLS_RSA_WITH_AES_256_CCM_8: u32 = 49313;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 49324;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 49325;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 49326;
pub const BR_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 49327;
pub const BR_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52392;
pub const BR_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52393;
pub const BR_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52394;
pub const BR_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52395;
pub const BR_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52396;
pub const BR_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52397;
pub const BR_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52398;
pub const BR_TLS_FALLBACK_SCSV: u32 = 22016;
pub const BR_ALERT_CLOSE_NOTIFY: u32 = 0;
pub const BR_ALERT_UNEXPECTED_MESSAGE: u32 = 10;
pub const BR_ALERT_BAD_RECORD_MAC: u32 = 20;
pub const BR_ALERT_RECORD_OVERFLOW: u32 = 22;
pub const BR_ALERT_DECOMPRESSION_FAILURE: u32 = 30;
pub const BR_ALERT_HANDSHAKE_FAILURE: u32 = 40;
pub const BR_ALERT_BAD_CERTIFICATE: u32 = 42;
pub const BR_ALERT_UNSUPPORTED_CERTIFICATE: u32 = 43;
pub const BR_ALERT_CERTIFICATE_REVOKED: u32 = 44;
pub const BR_ALERT_CERTIFICATE_EXPIRED: u32 = 45;
pub const BR_ALERT_CERTIFICATE_UNKNOWN: u32 = 46;
pub const BR_ALERT_ILLEGAL_PARAMETER: u32 = 47;
pub const BR_ALERT_UNKNOWN_CA: u32 = 48;
pub const BR_ALERT_ACCESS_DENIED: u32 = 49;
pub const BR_ALERT_DECODE_ERROR: u32 = 50;
pub const BR_ALERT_DECRYPT_ERROR: u32 = 51;
pub const BR_ALERT_PROTOCOL_VERSION: u32 = 70;
pub const BR_ALERT_INSUFFICIENT_SECURITY: u32 = 71;
pub const BR_ALERT_INTERNAL_ERROR: u32 = 80;
pub const BR_ALERT_USER_CANCELED: u32 = 90;
pub const BR_ALERT_NO_RENEGOTIATION: u32 = 100;
pub const BR_ALERT_UNSUPPORTED_EXTENSION: u32 = 110;
pub const BR_ALERT_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const BR_PEM_BEGIN_OBJ: u32 = 1;
pub const BR_PEM_END_OBJ: u32 = 2;
pub const BR_PEM_ERROR: u32 = 3;
pub const BR_PEM_LINE64: u32 = 1;
pub const BR_PEM_CRLF: u32 = 2;
pub type wchar_t = cty::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __bindgen_padding_0: [u32; 2usize],
    pub __clang_max_align_nonce2: u128,
}
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __quad_t = cty::c_longlong;
pub type __u_quad_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __dev_t = __u_quad_t;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = __u_quad_t;
pub type __ino64_t = __u_quad_t;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = __u_quad_t;
pub type __off_t = __quad_t;
pub type __off64_t = __quad_t;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
pub type __clock_t = __quad_t;
pub type __rlim_t = __u_quad_t;
pub type __rlim64_t = __u_quad_t;
pub type __id_t = cty::c_uint;
pub type __time_t = __quad_t;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = __quad_t;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = __quad_t;
pub type __blkcnt_t = __quad_t;
pub type __blkcnt64_t = __quad_t;
pub type __fsblkcnt_t = __u_quad_t;
pub type __fsblkcnt64_t = __u_quad_t;
pub type __fsfilcnt_t = __u_quad_t;
pub type __fsfilcnt64_t = __u_quad_t;
pub type __fsword_t = __quad_t;
pub type __ssize_t = cty::c_int;
pub type __syscall_slong_t = __quad_t;
pub type __syscall_ulong_t = __u_quad_t;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_int;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type int_least8_t = cty::c_schar;
pub type int_least16_t = cty::c_short;
pub type int_least32_t = cty::c_int;
pub type int_least64_t = cty::c_longlong;
pub type uint_least8_t = cty::c_uchar;
pub type uint_least16_t = cty::c_ushort;
pub type uint_least32_t = cty::c_uint;
pub type uint_least64_t = cty::c_ulonglong;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_int;
pub type int_fast32_t = cty::c_int;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_uint;
pub type uint_fast32_t = cty::c_uint;
pub type uint_fast64_t = cty::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn memcpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __c: cty::c_int,
        __n: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(__s: *mut cty::c_void, __c: cty::c_int, __n: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const cty::c_void,
        __s2: *const cty::c_void,
        __n: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memchr(__s: *const cty::c_void, __c: cty::c_int, __n: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_uint,
    ) -> cty::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const cty::c_ushort,
    pub __ctype_tolower: *const cty::c_int,
    pub __ctype_toupper: *const cty::c_int,
    pub __names: [*const cty::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __l: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(__string: *const cty::c_char, __n: cty::c_uint) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const cty::c_char, __reject: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strspn(__s: *const cty::c_char, __accept: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strpbrk(__s: *const cty::c_char, __accept: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const cty::c_char, __needle: *const cty::c_char)
        -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut cty::c_char, __delim: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlen(__s: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strnlen(__string: *const cty::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(__errnum: cty::c_int, __buf: *mut cty::c_char, __buflen: usize)
        -> cty::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: cty::c_int, __l: locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn bcmp(__s1: *const cty::c_void, __s2: *const cty::c_void, __n: usize) -> cty::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const cty::c_void, __dest: *mut cty::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut cty::c_void, __n: cty::c_uint);
}
extern "C" {
    pub fn index(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rindex(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn ffs(__i: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ffsl(__l: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn ffsll(__ll: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __loc: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut cty::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut cty::c_char,
        __delim: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsignal(__sig: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: usize,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_uint,
    ) -> *mut cty::c_char;
}
#[doc = " \\brief Class type for hash function implementations."]
#[doc = ""]
#[doc = " A `br_hash_class` instance references the methods implementing a hash"]
#[doc = " function. Constant instances of this structure are defined for each"]
#[doc = " implemented hash function. Such instances are also called \"vtables\"."]
#[doc = ""]
#[doc = " Vtables are used to support object-oriented programming, as"]
#[doc = " described on [the BearSSL Web site](https://www.bearssl.org/oop.html)."]
pub type br_hash_class = br_hash_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_hash_class_ {
    #[doc = " \\brief Size (in bytes) of the context structure appropriate for"]
    #[doc = " computing this hash function."]
    pub context_size: usize,
    #[doc = " \\brief Descriptor word that contains information about the hash"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " For each word `xxx` described below, use `BR_HASHDESC_xxx_OFF`"]
    #[doc = " and `BR_HASHDESC_xxx_MASK` to access the specific value, as"]
    #[doc = " follows:"]
    #[doc = ""]
    #[doc = "     (hf->desc >> BR_HASHDESC_xxx_OFF) & BR_HASHDESC_xxx_MASK"]
    #[doc = ""]
    #[doc = " The defined elements are:"]
    #[doc = ""]
    #[doc = "  - `ID`: the symbolic identifier for the function, as defined"]
    #[doc = "    in [TLS](https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1)"]
    #[doc = "    (MD5 = 1, SHA-1 = 2,...)."]
    #[doc = ""]
    #[doc = "  - `OUT`: hash output size, in bytes."]
    #[doc = ""]
    #[doc = "  - `STATE`: internal running state size, in bytes."]
    #[doc = ""]
    #[doc = "  - `LBLEN`: base-2 logarithm for the internal block size, as"]
    #[doc = "    defined for HMAC processing (this is 6 for MD5, SHA-1, SHA-224"]
    #[doc = "    and SHA-256, since these functions use 64-byte blocks; for"]
    #[doc = "    SHA-384 and SHA-512, this is 7, corresponding to their"]
    #[doc = "    128-byte blocks)."]
    #[doc = ""]
    #[doc = " The descriptor may contain a few other flags."]
    pub desc: u32,
    #[doc = " \\brief Initialisation method."]
    #[doc = ""]
    #[doc = " This method takes as parameter a pointer to a context area,"]
    #[doc = " that it initialises. The first field of the context is set"]
    #[doc = " to this vtable; other elements are initialised for a new hash"]
    #[doc = " computation."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to (the first field of) the context."]
    pub init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut *const br_hash_class)>,
    #[doc = " \\brief Data injection method."]
    #[doc = ""]
    #[doc = " The `len` bytes starting at address `data` are injected into"]
    #[doc = " the running hash computation incarnated by the specified"]
    #[doc = " context. The context is updated accordingly. It is allowed"]
    #[doc = " to have `len == 0`, in which case `data` is ignored (and could"]
    #[doc = " be `NULL`), and nothing happens."]
    #[doc = " on the input data."]
    #[doc = ""]
    #[doc = " \\param ctx    pointer to (the first field of) the context."]
    #[doc = " \\param data   pointer to the first data byte to inject."]
    #[doc = " \\param len    number of bytes to inject."]
    pub update: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut *const br_hash_class, data: *const cty::c_void, len: usize),
    >,
    #[doc = " \\brief Produce hash output."]
    #[doc = ""]
    #[doc = " The hash output corresponding to all data bytes injected in the"]
    #[doc = " context since the last `init()` call is computed, and written"]
    #[doc = " in the buffer pointed to by `dst`. The hash output size depends"]
    #[doc = " on the implemented hash function (e.g. 16 bytes for MD5)."]
    #[doc = " The context is _not_ modified by this call, so further bytes"]
    #[doc = " may be afterwards injected to continue the current computation."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to (the first field of) the context."]
    #[doc = " \\param dst   destination buffer for the hash output."]
    pub out: ::core::option::Option<
        unsafe extern "C" fn(ctx: *const *const br_hash_class, dst: *mut cty::c_void),
    >,
    #[doc = " \\brief Get running state."]
    #[doc = ""]
    #[doc = " This method saves the current running state into the `dst`"]
    #[doc = " buffer. What constitutes the \"running state\" depends on the"]
    #[doc = " hash function; for Merkle-Damg√•rd hash functions (like"]
    #[doc = " MD5 or SHA-1), this is the output obtained after processing"]
    #[doc = " each block. The number of bytes injected so far is returned."]
    #[doc = " The context is not modified by this call."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to (the first field of) the context."]
    #[doc = " \\param dst   destination buffer for the state."]
    #[doc = " \\return  the injected total byte length."]
    pub state: ::core::option::Option<
        unsafe extern "C" fn(ctx: *const *const br_hash_class, dst: *mut cty::c_void) -> u64,
    >,
    #[doc = " \\brief Set running state."]
    #[doc = ""]
    #[doc = " This methods replaces the running state for the function."]
    #[doc = ""]
    #[doc = " \\param ctx     pointer to (the first field of) the context."]
    #[doc = " \\param stb     source buffer for the state."]
    #[doc = " \\param count   injected total byte length."]
    pub set_state: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut *const br_hash_class, stb: *const cty::c_void, count: u64),
    >,
}
extern "C" {
    pub static br_md5_vtable: br_hash_class;
}
#[doc = " \\brief MD5 context."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_md5_context {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_hash_class,
    pub buf: [cty::c_uchar; 64usize],
    pub __bindgen_padding_0: u32,
    pub count: u64,
    pub val: [u32; 4usize],
}
extern "C" {
    #[doc = " \\brief MD5 context initialisation."]
    #[doc = ""]
    #[doc = " This function initialises or resets a context for a new MD5"]
    #[doc = " computation. It also sets the vtable pointer."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    pub fn br_md5_init(ctx: *mut br_md5_context);
}
extern "C" {
    #[doc = " \\brief Inject some data bytes in a running MD5 computation."]
    #[doc = ""]
    #[doc = " The provided context is updated with some data bytes. If the number"]
    #[doc = " of bytes (`len`) is zero, then the data pointer (`data`) is ignored"]
    #[doc = " and may be `NULL`, and this function does nothing."]
    #[doc = ""]
    #[doc = " \\param ctx    pointer to the context structure."]
    #[doc = " \\param data   pointer to the injected data."]
    #[doc = " \\param len    injected data length (in bytes)."]
    pub fn br_md5_update(ctx: *mut br_md5_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Compute MD5 output."]
    #[doc = ""]
    #[doc = " The MD5 output for the concatenation of all bytes injected in the"]
    #[doc = " provided context since the last initialisation or reset call, is"]
    #[doc = " computed and written in the buffer pointed to by `out`. The context"]
    #[doc = " itself is not modified, so extra bytes may be injected afterwards"]
    #[doc = " to continue that computation."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the hash output."]
    pub fn br_md5_out(ctx: *const br_md5_context, out: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Save MD5 running state."]
    #[doc = ""]
    #[doc = " The running state for MD5 (output of the last internal block"]
    #[doc = " processing) is written in the buffer pointed to by `out`. The"]
    #[doc = " number of bytes injected since the last initialisation or reset"]
    #[doc = " call is returned. The context is not modified."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the running state."]
    #[doc = " \\return  the injected total byte length."]
    pub fn br_md5_state(ctx: *const br_md5_context, out: *mut cty::c_void) -> u64;
}
extern "C" {
    #[doc = " \\brief Restore MD5 running state."]
    #[doc = ""]
    #[doc = " The running state for MD5 is set to the provided values."]
    #[doc = ""]
    #[doc = " \\param ctx     pointer to the context structure."]
    #[doc = " \\param stb     source buffer for the running state."]
    #[doc = " \\param count   the injected total byte length."]
    pub fn br_md5_set_state(ctx: *mut br_md5_context, stb: *const cty::c_void, count: u64);
}
extern "C" {
    pub static br_sha1_vtable: br_hash_class;
}
#[doc = " \\brief SHA-1 context."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_sha1_context {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_hash_class,
    pub buf: [cty::c_uchar; 64usize],
    pub __bindgen_padding_0: u32,
    pub count: u64,
    pub val: [u32; 5usize],
    pub __bindgen_padding_1: u32,
}
extern "C" {
    #[doc = " \\brief SHA-1 context initialisation."]
    #[doc = ""]
    #[doc = " This function initialises or resets a context for a new SHA-1"]
    #[doc = " computation. It also sets the vtable pointer."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    pub fn br_sha1_init(ctx: *mut br_sha1_context);
}
extern "C" {
    #[doc = " \\brief Inject some data bytes in a running SHA-1 computation."]
    #[doc = ""]
    #[doc = " The provided context is updated with some data bytes. If the number"]
    #[doc = " of bytes (`len`) is zero, then the data pointer (`data`) is ignored"]
    #[doc = " and may be `NULL`, and this function does nothing."]
    #[doc = ""]
    #[doc = " \\param ctx    pointer to the context structure."]
    #[doc = " \\param data   pointer to the injected data."]
    #[doc = " \\param len    injected data length (in bytes)."]
    pub fn br_sha1_update(ctx: *mut br_sha1_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Compute SHA-1 output."]
    #[doc = ""]
    #[doc = " The SHA-1 output for the concatenation of all bytes injected in the"]
    #[doc = " provided context since the last initialisation or reset call, is"]
    #[doc = " computed and written in the buffer pointed to by `out`. The context"]
    #[doc = " itself is not modified, so extra bytes may be injected afterwards"]
    #[doc = " to continue that computation."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the hash output."]
    pub fn br_sha1_out(ctx: *const br_sha1_context, out: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Save SHA-1 running state."]
    #[doc = ""]
    #[doc = " The running state for SHA-1 (output of the last internal block"]
    #[doc = " processing) is written in the buffer pointed to by `out`. The"]
    #[doc = " number of bytes injected since the last initialisation or reset"]
    #[doc = " call is returned. The context is not modified."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the running state."]
    #[doc = " \\return  the injected total byte length."]
    pub fn br_sha1_state(ctx: *const br_sha1_context, out: *mut cty::c_void) -> u64;
}
extern "C" {
    #[doc = " \\brief Restore SHA-1 running state."]
    #[doc = ""]
    #[doc = " The running state for SHA-1 is set to the provided values."]
    #[doc = ""]
    #[doc = " \\param ctx     pointer to the context structure."]
    #[doc = " \\param stb     source buffer for the running state."]
    #[doc = " \\param count   the injected total byte length."]
    pub fn br_sha1_set_state(ctx: *mut br_sha1_context, stb: *const cty::c_void, count: u64);
}
extern "C" {
    pub static br_sha224_vtable: br_hash_class;
}
#[doc = " \\brief SHA-224 context."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_sha224_context {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_hash_class,
    pub buf: [cty::c_uchar; 64usize],
    pub __bindgen_padding_0: u32,
    pub count: u64,
    pub val: [u32; 8usize],
}
extern "C" {
    #[doc = " \\brief SHA-224 context initialisation."]
    #[doc = ""]
    #[doc = " This function initialises or resets a context for a new SHA-224"]
    #[doc = " computation. It also sets the vtable pointer."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    pub fn br_sha224_init(ctx: *mut br_sha224_context);
}
extern "C" {
    #[doc = " \\brief Inject some data bytes in a running SHA-224 computation."]
    #[doc = ""]
    #[doc = " The provided context is updated with some data bytes. If the number"]
    #[doc = " of bytes (`len`) is zero, then the data pointer (`data`) is ignored"]
    #[doc = " and may be `NULL`, and this function does nothing."]
    #[doc = ""]
    #[doc = " \\param ctx    pointer to the context structure."]
    #[doc = " \\param data   pointer to the injected data."]
    #[doc = " \\param len    injected data length (in bytes)."]
    pub fn br_sha224_update(ctx: *mut br_sha224_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Compute SHA-224 output."]
    #[doc = ""]
    #[doc = " The SHA-224 output for the concatenation of all bytes injected in the"]
    #[doc = " provided context since the last initialisation or reset call, is"]
    #[doc = " computed and written in the buffer pointed to by `out`. The context"]
    #[doc = " itself is not modified, so extra bytes may be injected afterwards"]
    #[doc = " to continue that computation."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the hash output."]
    pub fn br_sha224_out(ctx: *const br_sha224_context, out: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Save SHA-224 running state."]
    #[doc = ""]
    #[doc = " The running state for SHA-224 (output of the last internal block"]
    #[doc = " processing) is written in the buffer pointed to by `out`. The"]
    #[doc = " number of bytes injected since the last initialisation or reset"]
    #[doc = " call is returned. The context is not modified."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the running state."]
    #[doc = " \\return  the injected total byte length."]
    pub fn br_sha224_state(ctx: *const br_sha224_context, out: *mut cty::c_void) -> u64;
}
extern "C" {
    #[doc = " \\brief Restore SHA-224 running state."]
    #[doc = ""]
    #[doc = " The running state for SHA-224 is set to the provided values."]
    #[doc = ""]
    #[doc = " \\param ctx     pointer to the context structure."]
    #[doc = " \\param stb     source buffer for the running state."]
    #[doc = " \\param count   the injected total byte length."]
    pub fn br_sha224_set_state(ctx: *mut br_sha224_context, stb: *const cty::c_void, count: u64);
}
extern "C" {
    pub static br_sha256_vtable: br_hash_class;
}
pub type br_sha256_context = br_sha224_context;
extern "C" {
    #[doc = " \\brief SHA-256 context initialisation."]
    #[doc = ""]
    #[doc = " This function initialises or resets a context for a new SHA-256"]
    #[doc = " computation. It also sets the vtable pointer."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    pub fn br_sha256_init(ctx: *mut br_sha256_context);
}
extern "C" {
    #[doc = " \\brief Compute SHA-256 output."]
    #[doc = ""]
    #[doc = " The SHA-256 output for the concatenation of all bytes injected in the"]
    #[doc = " provided context since the last initialisation or reset call, is"]
    #[doc = " computed and written in the buffer pointed to by `out`. The context"]
    #[doc = " itself is not modified, so extra bytes may be injected afterwards"]
    #[doc = " to continue that computation."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the hash output."]
    pub fn br_sha256_out(ctx: *const br_sha256_context, out: *mut cty::c_void);
}
extern "C" {
    pub static br_sha384_vtable: br_hash_class;
}
#[doc = " \\brief SHA-384 context."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_sha384_context {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_hash_class,
    pub buf: [cty::c_uchar; 128usize],
    pub __bindgen_padding_0: u32,
    pub count: u64,
    pub val: [u64; 8usize],
}
extern "C" {
    #[doc = " \\brief SHA-384 context initialisation."]
    #[doc = ""]
    #[doc = " This function initialises or resets a context for a new SHA-384"]
    #[doc = " computation. It also sets the vtable pointer."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    pub fn br_sha384_init(ctx: *mut br_sha384_context);
}
extern "C" {
    #[doc = " \\brief Inject some data bytes in a running SHA-384 computation."]
    #[doc = ""]
    #[doc = " The provided context is updated with some data bytes. If the number"]
    #[doc = " of bytes (`len`) is zero, then the data pointer (`data`) is ignored"]
    #[doc = " and may be `NULL`, and this function does nothing."]
    #[doc = ""]
    #[doc = " \\param ctx    pointer to the context structure."]
    #[doc = " \\param data   pointer to the injected data."]
    #[doc = " \\param len    injected data length (in bytes)."]
    pub fn br_sha384_update(ctx: *mut br_sha384_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Compute SHA-384 output."]
    #[doc = ""]
    #[doc = " The SHA-384 output for the concatenation of all bytes injected in the"]
    #[doc = " provided context since the last initialisation or reset call, is"]
    #[doc = " computed and written in the buffer pointed to by `out`. The context"]
    #[doc = " itself is not modified, so extra bytes may be injected afterwards"]
    #[doc = " to continue that computation."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the hash output."]
    pub fn br_sha384_out(ctx: *const br_sha384_context, out: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Save SHA-384 running state."]
    #[doc = ""]
    #[doc = " The running state for SHA-384 (output of the last internal block"]
    #[doc = " processing) is written in the buffer pointed to by `out`. The"]
    #[doc = " number of bytes injected since the last initialisation or reset"]
    #[doc = " call is returned. The context is not modified."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the running state."]
    #[doc = " \\return  the injected total byte length."]
    pub fn br_sha384_state(ctx: *const br_sha384_context, out: *mut cty::c_void) -> u64;
}
extern "C" {
    #[doc = " \\brief Restore SHA-384 running state."]
    #[doc = ""]
    #[doc = " The running state for SHA-384 is set to the provided values."]
    #[doc = ""]
    #[doc = " \\param ctx     pointer to the context structure."]
    #[doc = " \\param stb     source buffer for the running state."]
    #[doc = " \\param count   the injected total byte length."]
    pub fn br_sha384_set_state(ctx: *mut br_sha384_context, stb: *const cty::c_void, count: u64);
}
extern "C" {
    pub static br_sha512_vtable: br_hash_class;
}
pub type br_sha512_context = br_sha384_context;
extern "C" {
    #[doc = " \\brief SHA-512 context initialisation."]
    #[doc = ""]
    #[doc = " This function initialises or resets a context for a new SHA-512"]
    #[doc = " computation. It also sets the vtable pointer."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    pub fn br_sha512_init(ctx: *mut br_sha512_context);
}
extern "C" {
    #[doc = " \\brief Compute SHA-512 output."]
    #[doc = ""]
    #[doc = " The SHA-512 output for the concatenation of all bytes injected in the"]
    #[doc = " provided context since the last initialisation or reset call, is"]
    #[doc = " computed and written in the buffer pointed to by `out`. The context"]
    #[doc = " itself is not modified, so extra bytes may be injected afterwards"]
    #[doc = " to continue that computation."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the hash output."]
    pub fn br_sha512_out(ctx: *const br_sha512_context, out: *mut cty::c_void);
}
extern "C" {
    pub static br_md5sha1_vtable: br_hash_class;
}
#[doc = " \\brief MD5+SHA-1 context."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_md5sha1_context {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_hash_class,
    pub buf: [cty::c_uchar; 64usize],
    pub __bindgen_padding_0: u32,
    pub count: u64,
    pub val_md5: [u32; 4usize],
    pub val_sha1: [u32; 5usize],
    pub __bindgen_padding_1: u32,
}
extern "C" {
    #[doc = " \\brief MD5+SHA-1 context initialisation."]
    #[doc = ""]
    #[doc = " This function initialises or resets a context for a new SHA-512"]
    #[doc = " computation. It also sets the vtable pointer."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    pub fn br_md5sha1_init(ctx: *mut br_md5sha1_context);
}
extern "C" {
    #[doc = " \\brief Inject some data bytes in a running MD5+SHA-1 computation."]
    #[doc = ""]
    #[doc = " The provided context is updated with some data bytes. If the number"]
    #[doc = " of bytes (`len`) is zero, then the data pointer (`data`) is ignored"]
    #[doc = " and may be `NULL`, and this function does nothing."]
    #[doc = ""]
    #[doc = " \\param ctx    pointer to the context structure."]
    #[doc = " \\param data   pointer to the injected data."]
    #[doc = " \\param len    injected data length (in bytes)."]
    pub fn br_md5sha1_update(ctx: *mut br_md5sha1_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Compute MD5+SHA-1 output."]
    #[doc = ""]
    #[doc = " The MD5+SHA-1 output for the concatenation of all bytes injected in the"]
    #[doc = " provided context since the last initialisation or reset call, is"]
    #[doc = " computed and written in the buffer pointed to by `out`. The context"]
    #[doc = " itself is not modified, so extra bytes may be injected afterwards"]
    #[doc = " to continue that computation."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the hash output."]
    pub fn br_md5sha1_out(ctx: *const br_md5sha1_context, out: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Save MD5+SHA-1 running state."]
    #[doc = ""]
    #[doc = " The running state for MD5+SHA-1 (output of the last internal block"]
    #[doc = " processing) is written in the buffer pointed to by `out`. The"]
    #[doc = " number of bytes injected since the last initialisation or reset"]
    #[doc = " call is returned. The context is not modified."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param out   destination buffer for the running state."]
    #[doc = " \\return  the injected total byte length."]
    pub fn br_md5sha1_state(ctx: *const br_md5sha1_context, out: *mut cty::c_void) -> u64;
}
extern "C" {
    #[doc = " \\brief Restore MD5+SHA-1 running state."]
    #[doc = ""]
    #[doc = " The running state for MD5+SHA-1 is set to the provided values."]
    #[doc = ""]
    #[doc = " \\param ctx     pointer to the context structure."]
    #[doc = " \\param stb     source buffer for the running state."]
    #[doc = " \\param count   the injected total byte length."]
    pub fn br_md5sha1_set_state(ctx: *mut br_md5sha1_context, stb: *const cty::c_void, count: u64);
}
#[doc = " \\brief Aggregate context for configurable hash function support."]
#[doc = ""]
#[doc = " The `br_hash_compat_context` type is a type which is large enough to"]
#[doc = " serve as context for all standard hash functions defined above."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_hash_compat_context {
    pub vtable: *const br_hash_class,
    pub md5: br_md5_context,
    pub sha1: br_sha1_context,
    pub sha224: br_sha224_context,
    pub sha256: br_sha256_context,
    pub sha384: br_sha384_context,
    pub sha512: br_sha512_context,
    pub md5sha1: br_md5sha1_context,
    _bindgen_union_align: [u64; 26usize],
}
#[doc = " \\brief Multi-hasher context structure."]
#[doc = ""]
#[doc = " The multi-hasher runs up to six hash functions in the standard TLS list"]
#[doc = " (MD5, SHA-1, SHA-224, SHA-256, SHA-384 and SHA-512) in parallel, over"]
#[doc = " the same input."]
#[doc = ""]
#[doc = " The multi-hasher does _not_ follow the OOP structure with a vtable."]
#[doc = " Instead, it is configured with the vtables of the hash functions it"]
#[doc = " should run. Structure fields are not supposed to be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_multihash_context {
    pub buf: [cty::c_uchar; 128usize],
    pub count: u64,
    pub val_32: [u32; 25usize],
    pub __bindgen_padding_0: u32,
    pub val_64: [u64; 16usize],
    pub impl_: [*const br_hash_class; 6usize],
}
extern "C" {
    #[doc = " \\brief Clear a multi-hasher context."]
    #[doc = ""]
    #[doc = " This should always be called once on a given context, _before_ setting"]
    #[doc = " the implementation pointers."]
    #[doc = ""]
    #[doc = " \\param ctx   the multi-hasher context."]
    pub fn br_multihash_zero(ctx: *mut br_multihash_context);
}
extern "C" {
    #[doc = " \\brief Reset a multi-hasher context."]
    #[doc = ""]
    #[doc = " This function prepares the context for a new hashing computation,"]
    #[doc = " for all implementations configured at that point."]
    #[doc = ""]
    #[doc = " \\param ctx    the multi-hasher context."]
    pub fn br_multihash_init(ctx: *mut br_multihash_context);
}
extern "C" {
    #[doc = " \\brief Inject some data bytes in a running multi-hashing computation."]
    #[doc = ""]
    #[doc = " The provided context is updated with some data bytes. If the number"]
    #[doc = " of bytes (`len`) is zero, then the data pointer (`data`) is ignored"]
    #[doc = " and may be `NULL`, and this function does nothing."]
    #[doc = ""]
    #[doc = " \\param ctx    pointer to the context structure."]
    #[doc = " \\param data   pointer to the injected data."]
    #[doc = " \\param len    injected data length (in bytes)."]
    pub fn br_multihash_update(
        ctx: *mut br_multihash_context,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Compute a hash output from a multi-hasher."]
    #[doc = ""]
    #[doc = " The hash output for the concatenation of all bytes injected in the"]
    #[doc = " provided context since the last initialisation or reset call, is"]
    #[doc = " computed and written in the buffer pointed to by `dst`. The hash"]
    #[doc = " function to use is identified by `id` and must be one of the standard"]
    #[doc = " hash functions. If that hash function was indeed configured in the"]
    #[doc = " multi-hasher context, the corresponding hash value is written in"]
    #[doc = " `dst` and its length (in bytes) is returned. If the hash function"]
    #[doc = " was _not_ configured, then nothing is written in `dst` and 0 is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " The context itself is not modified, so extra bytes may be injected"]
    #[doc = " afterwards to continue the hash computations."]
    #[doc = ""]
    #[doc = " \\param ctx   pointer to the context structure."]
    #[doc = " \\param id    the hash function symbolic identifier."]
    #[doc = " \\param dst   destination buffer for the hash output."]
    #[doc = " \\return  the hash output length (in bytes), or 0."]
    pub fn br_multihash_out(
        ctx: *const br_multihash_context,
        id: cty::c_int,
        dst: *mut cty::c_void,
    ) -> usize;
}
#[doc = " \\brief Type for a GHASH implementation."]
#[doc = ""]
#[doc = " GHASH is a sort of keyed hash meant to be used to implement GCM in"]
#[doc = " combination with a block cipher (with 16-byte blocks)."]
#[doc = ""]
#[doc = " The `y` array has length 16 bytes and is used for input and output; in"]
#[doc = " a complete GHASH run, it starts with an all-zero value. `h` is a 16-byte"]
#[doc = " value that serves as key (it is derived from the encryption key in GCM,"]
#[doc = " using the block cipher). The data length (`len`) is expressed in bytes."]
#[doc = " The `y` array is updated."]
#[doc = ""]
#[doc = " If the data length is not a multiple of 16, then the data is implicitly"]
#[doc = " padded with zeros up to the next multiple of 16. Thus, when using GHASH"]
#[doc = " in GCM, this method may be called twice, for the associated data and"]
#[doc = " for the ciphertext, respectively; the zero-padding implements exactly"]
#[doc = " the GCM rules."]
#[doc = ""]
#[doc = " \\param y      the array to update."]
#[doc = " \\param h      the GHASH key."]
#[doc = " \\param data   the input data (may be `NULL` if `len` is zero)."]
#[doc = " \\param len    the input data length (in bytes)."]
pub type br_ghash = ::core::option::Option<
    unsafe extern "C" fn(
        y: *mut cty::c_void,
        h: *const cty::c_void,
        data: *const cty::c_void,
        len: usize,
    ),
>;
extern "C" {
    #[doc = " \\brief GHASH implementation using multiplications (mixed 32-bit)."]
    #[doc = ""]
    #[doc = " This implementation uses multiplications of 32-bit values, with a"]
    #[doc = " 64-bit result. It is constant-time (if multiplications are"]
    #[doc = " constant-time)."]
    #[doc = ""]
    #[doc = " \\param y      the array to update."]
    #[doc = " \\param h      the GHASH key."]
    #[doc = " \\param data   the input data (may be `NULL` if `len` is zero)."]
    #[doc = " \\param len    the input data length (in bytes)."]
    pub fn br_ghash_ctmul(
        y: *mut cty::c_void,
        h: *const cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief GHASH implementation using multiplications (strict 32-bit)."]
    #[doc = ""]
    #[doc = " This implementation uses multiplications of 32-bit values, with a"]
    #[doc = " 32-bit result. It is usually somewhat slower than `br_ghash_ctmul()`,"]
    #[doc = " but it is expected to be faster on architectures for which the"]
    #[doc = " 32-bit multiplication opcode does not yield the upper 32 bits of the"]
    #[doc = " product. It is constant-time (if multiplications are constant-time)."]
    #[doc = ""]
    #[doc = " \\param y      the array to update."]
    #[doc = " \\param h      the GHASH key."]
    #[doc = " \\param data   the input data (may be `NULL` if `len` is zero)."]
    #[doc = " \\param len    the input data length (in bytes)."]
    pub fn br_ghash_ctmul32(
        y: *mut cty::c_void,
        h: *const cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief GHASH implementation using multiplications (64-bit)."]
    #[doc = ""]
    #[doc = " This implementation uses multiplications of 64-bit values, with a"]
    #[doc = " 64-bit result. It is constant-time (if multiplications are"]
    #[doc = " constant-time). It is substantially faster than `br_ghash_ctmul()`"]
    #[doc = " and `br_ghash_ctmul32()` on most 64-bit architectures."]
    #[doc = ""]
    #[doc = " \\param y      the array to update."]
    #[doc = " \\param h      the GHASH key."]
    #[doc = " \\param data   the input data (may be `NULL` if `len` is zero)."]
    #[doc = " \\param len    the input data length (in bytes)."]
    pub fn br_ghash_ctmul64(
        y: *mut cty::c_void,
        h: *const cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief GHASH implementation using the `pclmulqdq` opcode (part of the"]
    #[doc = " AES-NI instructions)."]
    #[doc = ""]
    #[doc = " This implementation is available only on x86 platforms where the"]
    #[doc = " compiler supports the relevant intrinsic functions. Even if the"]
    #[doc = " compiler supports these functions, the local CPU might not support"]
    #[doc = " the `pclmulqdq` opcode, meaning that a call will fail with an"]
    #[doc = " illegal instruction exception. To safely obtain a pointer to this"]
    #[doc = " function when supported (or 0 otherwise), use `br_ghash_pclmul_get()`."]
    #[doc = ""]
    #[doc = " \\param y      the array to update."]
    #[doc = " \\param h      the GHASH key."]
    #[doc = " \\param data   the input data (may be `NULL` if `len` is zero)."]
    #[doc = " \\param len    the input data length (in bytes)."]
    pub fn br_ghash_pclmul(
        y: *mut cty::c_void,
        h: *const cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Obtain the `pclmul` GHASH implementation, if available."]
    #[doc = ""]
    #[doc = " If the `pclmul` implementation was compiled in the library (depending"]
    #[doc = " on the compiler abilities) _and_ the local CPU appears to support the"]
    #[doc = " opcode, then this function will return a pointer to the"]
    #[doc = " `br_ghash_pclmul()` function. Otherwise, it will return `0`."]
    #[doc = ""]
    #[doc = " \\return  the `pclmul` GHASH implementation, or `0`."]
    pub fn br_ghash_pclmul_get() -> br_ghash;
}
extern "C" {
    #[doc = " \\brief GHASH implementation using the POWER8 opcodes."]
    #[doc = ""]
    #[doc = " This implementation is available only on POWER8 platforms (and later)."]
    #[doc = " To safely obtain a pointer to this function when supported (or 0"]
    #[doc = " otherwise), use `br_ghash_pwr8_get()`."]
    #[doc = ""]
    #[doc = " \\param y      the array to update."]
    #[doc = " \\param h      the GHASH key."]
    #[doc = " \\param data   the input data (may be `NULL` if `len` is zero)."]
    #[doc = " \\param len    the input data length (in bytes)."]
    pub fn br_ghash_pwr8(
        y: *mut cty::c_void,
        h: *const cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Obtain the `pwr8` GHASH implementation, if available."]
    #[doc = ""]
    #[doc = " If the `pwr8` implementation was compiled in the library (depending"]
    #[doc = " on the compiler abilities) _and_ the local CPU appears to support the"]
    #[doc = " opcode, then this function will return a pointer to the"]
    #[doc = " `br_ghash_pwr8()` function. Otherwise, it will return `0`."]
    #[doc = ""]
    #[doc = " \\return  the `pwr8` GHASH implementation, or `0`."]
    pub fn br_ghash_pwr8_get() -> br_ghash;
}
#[doc = " \\brief HMAC key context."]
#[doc = ""]
#[doc = " The HMAC key context is initialised with a hash function implementation"]
#[doc = " and a secret key. Contents are opaque (callers should not access them"]
#[doc = " directly). The caller is responsible for allocating the context where"]
#[doc = " appropriate. Context initialisation and usage incurs no dynamic"]
#[doc = " allocation, so there is no release function."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_hmac_key_context {
    pub dig_vtable: *const br_hash_class,
    pub ksi: [cty::c_uchar; 64usize],
    pub kso: [cty::c_uchar; 64usize],
}
extern "C" {
    #[doc = " \\brief HMAC key context initialisation."]
    #[doc = ""]
    #[doc = " Initialise the key context with the provided key, using the hash function"]
    #[doc = " identified by `digest_vtable`. This supports arbitrary key lengths."]
    #[doc = ""]
    #[doc = " \\param kc              HMAC key context to initialise."]
    #[doc = " \\param digest_vtable   pointer to the hash function implementation vtable."]
    #[doc = " \\param key             pointer to the HMAC secret key."]
    #[doc = " \\param key_len         HMAC secret key length (in bytes)."]
    pub fn br_hmac_key_init(
        kc: *mut br_hmac_key_context,
        digest_vtable: *const br_hash_class,
        key: *const cty::c_void,
        key_len: usize,
    );
}
#[doc = " \\brief HMAC computation context."]
#[doc = ""]
#[doc = " The HMAC computation context maintains the state for a single HMAC"]
#[doc = " computation. It is modified as input bytes are injected. The context"]
#[doc = " is caller-allocated and has no release function since it does not"]
#[doc = " dynamically allocate external resources. Its contents are opaque."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_hmac_context {
    pub dig: br_hash_compat_context,
    pub kso: [cty::c_uchar; 64usize],
    pub out_len: usize,
    pub __bindgen_padding_0: u32,
}
extern "C" {
    #[doc = " \\brief HMAC computation initialisation."]
    #[doc = ""]
    #[doc = " Initialise a HMAC context with a key context. The key context is"]
    #[doc = " unmodified. Relevant data from the key context is immediately copied;"]
    #[doc = " the key context can thus be independently reused, modified or released"]
    #[doc = " without impacting this HMAC computation."]
    #[doc = ""]
    #[doc = " An explicit output length can be specified; the actual output length"]
    #[doc = " will be the minimum of that value and the natural HMAC output length."]
    #[doc = " If `out_len` is 0, then the natural HMAC output length is selected. The"]
    #[doc = " \"natural output length\" is the output length of the underlying hash"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " \\param ctx       HMAC context to initialise."]
    #[doc = " \\param kc        HMAC key context (already initialised with the key)."]
    #[doc = " \\param out_len   HMAC output length (0 to select \"natural length\")."]
    pub fn br_hmac_init(ctx: *mut br_hmac_context, kc: *const br_hmac_key_context, out_len: usize);
}
extern "C" {
    #[doc = " \\brief Inject some bytes in HMAC."]
    #[doc = ""]
    #[doc = " The provided `len` bytes are injected as extra input in the HMAC"]
    #[doc = " computation incarnated by the `ctx` HMAC context. It is acceptable"]
    #[doc = " that `len` is zero, in which case `data` is ignored (and may be"]
    #[doc = " `NULL`) and this function does nothing."]
    pub fn br_hmac_update(ctx: *mut br_hmac_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Compute the HMAC output."]
    #[doc = ""]
    #[doc = " The destination buffer MUST be large enough to accommodate the result;"]
    #[doc = " its length is at most the \"natural length\" of HMAC (i.e. the output"]
    #[doc = " length of the underlying hash function). The context is NOT modified;"]
    #[doc = " further bytes may be processed. Thus, \"partial HMAC\" values can be"]
    #[doc = " efficiently obtained."]
    #[doc = ""]
    #[doc = " Returned value is the output length (in bytes)."]
    #[doc = ""]
    #[doc = " \\param ctx   HMAC computation context."]
    #[doc = " \\param out   destination buffer for the HMAC output."]
    #[doc = " \\return  the produced value length (in bytes)."]
    pub fn br_hmac_out(ctx: *const br_hmac_context, out: *mut cty::c_void) -> usize;
}
extern "C" {
    #[doc = " \\brief Constant-time HMAC computation."]
    #[doc = ""]
    #[doc = " This function compute the HMAC output in constant time. Some extra"]
    #[doc = " input bytes are processed, then the output is computed. The extra"]
    #[doc = " input consists in the `len` bytes pointed to by `data`. The `len`"]
    #[doc = " parameter must lie between `min_len` and `max_len` (inclusive);"]
    #[doc = " `max_len` bytes are actually read from `data`. Computing time (and"]
    #[doc = " memory access pattern) will not depend upon the data byte contents or"]
    #[doc = " the value of `len`."]
    #[doc = ""]
    #[doc = " The output is written in the `out` buffer, that MUST be large enough"]
    #[doc = " to receive it."]
    #[doc = ""]
    #[doc = " The difference `max_len - min_len` MUST be less than 2<sup>30</sup>"]
    #[doc = " (i.e. about one gigabyte)."]
    #[doc = ""]
    #[doc = " This function computes the output properly only if the underlying"]
    #[doc = " hash function uses MD padding (i.e. MD5, SHA-1, SHA-224, SHA-256,"]
    #[doc = " SHA-384 or SHA-512)."]
    #[doc = ""]
    #[doc = " The provided context is NOT modified."]
    #[doc = ""]
    #[doc = " \\param ctx       the (already initialised) HMAC computation context."]
    #[doc = " \\param data      the extra input bytes."]
    #[doc = " \\param len       the extra input length (in bytes)."]
    #[doc = " \\param min_len   minimum extra input length (in bytes)."]
    #[doc = " \\param max_len   maximum extra input length (in bytes)."]
    #[doc = " \\param out       destination buffer for the HMAC output."]
    #[doc = " \\return  the produced value length (in bytes)."]
    pub fn br_hmac_outCT(
        ctx: *const br_hmac_context,
        data: *const cty::c_void,
        len: usize,
        min_len: usize,
        max_len: usize,
        out: *mut cty::c_void,
    ) -> usize;
}
#[doc = " \\brief HKDF context."]
#[doc = ""]
#[doc = " The HKDF context is initialized with a hash function implementation"]
#[doc = " and a salt value. Contents are opaque (callers should not access them"]
#[doc = " directly). The caller is responsible for allocating the context where"]
#[doc = " appropriate. Context initialisation and usage incurs no dynamic"]
#[doc = " allocation, so there is no release function."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_hkdf_context {
    pub u: br_hkdf_context__bindgen_ty_1,
    pub buf: [cty::c_uchar; 64usize],
    pub ptr: usize,
    pub dig_len: usize,
    pub chunk_num: cty::c_uint,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_hkdf_context__bindgen_ty_1 {
    pub hmac_ctx: br_hmac_context,
    pub prk_ctx: br_hmac_key_context,
    _bindgen_union_align: [u64; 35usize],
}
extern "C" {
    #[doc = " \\brief HKDF context initialization."]
    #[doc = ""]
    #[doc = " The underlying hash function and salt value are provided. Arbitrary"]
    #[doc = " salt lengths can be used."]
    #[doc = ""]
    #[doc = " HKDF makes a difference between a salt of length zero, and an"]
    #[doc = " absent salt (the latter being equivalent to a salt consisting of"]
    #[doc = " bytes of value zero, of the same length as the hash function output)."]
    #[doc = " If `salt_len` is zero, then this function assumes that the salt is"]
    #[doc = " present but of length zero. To specify an _absent_ salt, use"]
    #[doc = " `BR_HKDF_NO_SALT` as `salt` parameter (`salt_len` is then ignored)."]
    #[doc = ""]
    #[doc = " \\param hc              HKDF context to initialise."]
    #[doc = " \\param digest_vtable   pointer to the hash function implementation vtable."]
    #[doc = " \\param salt            HKDF-Extract salt."]
    #[doc = " \\param salt_len        HKDF-Extract salt length (in bytes)."]
    pub fn br_hkdf_init(
        hc: *mut br_hkdf_context,
        digest_vtable: *const br_hash_class,
        salt: *const cty::c_void,
        salt_len: usize,
    );
}
extern "C" {
    pub static br_hkdf_no_salt: cty::c_uchar;
}
extern "C" {
    #[doc = " \\brief HKDF input injection (HKDF-Extract)."]
    #[doc = ""]
    #[doc = " This function injects some more input bytes (\"key material\") into"]
    #[doc = " HKDF. This function may be called several times, after `br_hkdf_init()`"]
    #[doc = " but before `br_hkdf_flip()`."]
    #[doc = ""]
    #[doc = " \\param hc        HKDF context."]
    #[doc = " \\param ikm       extra input bytes."]
    #[doc = " \\param ikm_len   number of extra input bytes."]
    pub fn br_hkdf_inject(hc: *mut br_hkdf_context, ikm: *const cty::c_void, ikm_len: usize);
}
extern "C" {
    #[doc = " \\brief HKDF switch to the HKDF-Expand phase."]
    #[doc = ""]
    #[doc = " This call terminates the HKDF-Extract process (input injection), and"]
    #[doc = " starts the HKDF-Expand process (output production)."]
    #[doc = ""]
    #[doc = " \\param hc   HKDF context."]
    pub fn br_hkdf_flip(hc: *mut br_hkdf_context);
}
extern "C" {
    #[doc = " \\brief HKDF output production (HKDF-Expand)."]
    #[doc = ""]
    #[doc = " Produce more output bytes from the current state. This function may be"]
    #[doc = " called several times, but only after `br_hkdf_flip()`."]
    #[doc = ""]
    #[doc = " Returned value is the number of actually produced bytes. The total"]
    #[doc = " output length is limited to 255 times the output length of the"]
    #[doc = " underlying hash function."]
    #[doc = ""]
    #[doc = " \\param hc         HKDF context."]
    #[doc = " \\param info       application specific information string."]
    #[doc = " \\param info_len   application specific information string length (in bytes)."]
    #[doc = " \\param out        destination buffer for the HKDF output."]
    #[doc = " \\param out_len    the length of the requested output (in bytes)."]
    #[doc = " \\return  the produced output length (in bytes)."]
    pub fn br_hkdf_produce(
        hc: *mut br_hkdf_context,
        info: *const cty::c_void,
        info_len: usize,
        out: *mut cty::c_void,
        out_len: usize,
    ) -> usize;
}
#[doc = " \\brief SHAKE context."]
#[doc = ""]
#[doc = " The HKDF context is initialized with a \"security level\". The internal"]
#[doc = " notion is called \"capacity\"; the capacity is twice the security level"]
#[doc = " (for instance, SHAKE128 has capacity 256)."]
#[doc = ""]
#[doc = " The caller is responsible for allocating the context where"]
#[doc = " appropriate. Context initialisation and usage incurs no dynamic"]
#[doc = " allocation, so there is no release function."]
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct br_shake_context {
    pub dbuf: [cty::c_uchar; 200usize],
    pub dptr: usize,
    pub rate: usize,
    pub A: [u64; 25usize],
}
extern "C" {
    #[doc = " \\brief SHAKE context initialization."]
    #[doc = ""]
    #[doc = " The context is initialized for the provided \"security level\"."]
    #[doc = " Internally, this sets the \"capacity\" to twice the security level;"]
    #[doc = " thus, for SHAKE128, the `security_level` parameter should be 128,"]
    #[doc = " which corresponds to a 256-bit capacity."]
    #[doc = ""]
    #[doc = " Allowed security levels are all multiples of 32, from 32 to 768,"]
    #[doc = " inclusive. Larger security levels imply lower performance; levels"]
    #[doc = " beyond 256 bits don't make much sense. Standard levels are 128"]
    #[doc = " and 256 bits (for SHAKE128 and SHAKE256, respectively)."]
    #[doc = ""]
    #[doc = " \\param sc               SHAKE context to initialise."]
    #[doc = " \\param security_level   security level (in bits)."]
    pub fn br_shake_init(sc: *mut br_shake_context, security_level: cty::c_int);
}
extern "C" {
    #[doc = " \\brief SHAKE input injection."]
    #[doc = ""]
    #[doc = " This function injects some more input bytes (\"key material\") into"]
    #[doc = " SHAKE. This function may be called several times, after `br_shake_init()`"]
    #[doc = " but before `br_shake_flip()`."]
    #[doc = ""]
    #[doc = " \\param sc     SHAKE context."]
    #[doc = " \\param data   extra input bytes."]
    #[doc = " \\param len    number of extra input bytes."]
    pub fn br_shake_inject(sc: *mut br_shake_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief SHAKE switch to production phase."]
    #[doc = ""]
    #[doc = " This call terminates the input injection process, and starts the"]
    #[doc = " output production process."]
    #[doc = ""]
    #[doc = " \\param sc   SHAKE context."]
    pub fn br_shake_flip(hc: *mut br_shake_context);
}
extern "C" {
    #[doc = " \\brief SHAKE output production."]
    #[doc = ""]
    #[doc = " Produce more output bytes from the current state. This function may be"]
    #[doc = " called several times, but only after `br_shake_flip()`."]
    #[doc = ""]
    #[doc = " There is no practical limit to the number of bytes that may be produced."]
    #[doc = ""]
    #[doc = " \\param sc    SHAKE context."]
    #[doc = " \\param out   destination buffer for the SHAKE output."]
    #[doc = " \\param len   the length of the requested output (in bytes)."]
    pub fn br_shake_produce(sc: *mut br_shake_context, out: *mut cty::c_void, len: usize);
}
#[doc = " \\brief Class type for CBC encryption implementations."]
#[doc = ""]
#[doc = " A `br_block_cbcenc_class` instance points to the functions implementing"]
#[doc = " a specific block cipher, when used in CBC mode for encrypting data."]
pub type br_block_cbcenc_class = br_block_cbcenc_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_block_cbcenc_class_ {
    #[doc = " \\brief Size (in bytes) of the context structure appropriate"]
    #[doc = " for containing subkeys."]
    pub context_size: usize,
    #[doc = " \\brief Size of individual blocks (in bytes)."]
    pub block_size: cty::c_uint,
    #[doc = " \\brief Base-2 logarithm of the size of individual blocks,"]
    #[doc = " expressed in bytes."]
    pub log_block_size: cty::c_uint,
    #[doc = " \\brief Initialisation function."]
    #[doc = ""]
    #[doc = " This function sets the `vtable` field in the context structure."]
    #[doc = " The key length MUST be one of the key lengths supported by"]
    #[doc = " the implementation."]
    #[doc = ""]
    #[doc = " \\param ctx       context structure to initialise."]
    #[doc = " \\param key       secret key."]
    #[doc = " \\param key_len   key length (in bytes)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_block_cbcenc_class,
            key: *const cty::c_void,
            key_len: usize,
        ),
    >,
    #[doc = " \\brief Run the CBC encryption."]
    #[doc = ""]
    #[doc = " The `iv` parameter points to the IV for this run; it is"]
    #[doc = " updated with a copy of the last encrypted block. The data"]
    #[doc = " is encrypted \"in place\"; its length (`len`) MUST be a"]
    #[doc = " multiple of the block size."]
    #[doc = ""]
    #[doc = " \\param ctx    context structure (already initialised)."]
    #[doc = " \\param iv     IV for CBC encryption (updated)."]
    #[doc = " \\param data   data to encrypt."]
    #[doc = " \\param len    data length (in bytes, multiple of block size)."]
    pub run: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_block_cbcenc_class,
            iv: *mut cty::c_void,
            data: *mut cty::c_void,
            len: usize,
        ),
    >,
}
#[doc = " \\brief Class type for CBC decryption implementations."]
#[doc = ""]
#[doc = " A `br_block_cbcdec_class` instance points to the functions implementing"]
#[doc = " a specific block cipher, when used in CBC mode for decrypting data."]
pub type br_block_cbcdec_class = br_block_cbcdec_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_block_cbcdec_class_ {
    #[doc = " \\brief Size (in bytes) of the context structure appropriate"]
    #[doc = " for containing subkeys."]
    pub context_size: usize,
    #[doc = " \\brief Size of individual blocks (in bytes)."]
    pub block_size: cty::c_uint,
    #[doc = " \\brief Base-2 logarithm of the size of individual blocks,"]
    #[doc = " expressed in bytes."]
    pub log_block_size: cty::c_uint,
    #[doc = " \\brief Initialisation function."]
    #[doc = ""]
    #[doc = " This function sets the `vtable` field in the context structure."]
    #[doc = " The key length MUST be one of the key lengths supported by"]
    #[doc = " the implementation."]
    #[doc = ""]
    #[doc = " \\param ctx       context structure to initialise."]
    #[doc = " \\param key       secret key."]
    #[doc = " \\param key_len   key length (in bytes)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_block_cbcdec_class,
            key: *const cty::c_void,
            key_len: usize,
        ),
    >,
    #[doc = " \\brief Run the CBC decryption."]
    #[doc = ""]
    #[doc = " The `iv` parameter points to the IV for this run; it is"]
    #[doc = " updated with a copy of the last encrypted block. The data"]
    #[doc = " is decrypted \"in place\"; its length (`len`) MUST be a"]
    #[doc = " multiple of the block size."]
    #[doc = ""]
    #[doc = " \\param ctx    context structure (already initialised)."]
    #[doc = " \\param iv     IV for CBC decryption (updated)."]
    #[doc = " \\param data   data to decrypt."]
    #[doc = " \\param len    data length (in bytes, multiple of block size)."]
    pub run: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_block_cbcdec_class,
            iv: *mut cty::c_void,
            data: *mut cty::c_void,
            len: usize,
        ),
    >,
}
#[doc = " \\brief Class type for CTR encryption/decryption implementations."]
#[doc = ""]
#[doc = " A `br_block_ctr_class` instance points to the functions implementing"]
#[doc = " a specific block cipher, when used in CTR mode for encrypting or"]
#[doc = " decrypting data."]
pub type br_block_ctr_class = br_block_ctr_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_block_ctr_class_ {
    #[doc = " \\brief Size (in bytes) of the context structure appropriate"]
    #[doc = " for containing subkeys."]
    pub context_size: usize,
    #[doc = " \\brief Size of individual blocks (in bytes)."]
    pub block_size: cty::c_uint,
    #[doc = " \\brief Base-2 logarithm of the size of individual blocks,"]
    #[doc = " expressed in bytes."]
    pub log_block_size: cty::c_uint,
    #[doc = " \\brief Initialisation function."]
    #[doc = ""]
    #[doc = " This function sets the `vtable` field in the context structure."]
    #[doc = " The key length MUST be one of the key lengths supported by"]
    #[doc = " the implementation."]
    #[doc = ""]
    #[doc = " \\param ctx       context structure to initialise."]
    #[doc = " \\param key       secret key."]
    #[doc = " \\param key_len   key length (in bytes)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_block_ctr_class,
            key: *const cty::c_void,
            key_len: usize,
        ),
    >,
    #[doc = " \\brief Run the CTR encryption or decryption."]
    #[doc = ""]
    #[doc = " The `iv` parameter points to the IV for this run; its"]
    #[doc = " length is exactly 4 bytes less than the block size (e.g."]
    #[doc = " 12 bytes for AES/CTR). The IV is combined with a 32-bit"]
    #[doc = " block counter to produce the block value which is processed"]
    #[doc = " with the block cipher."]
    #[doc = ""]
    #[doc = " The data to encrypt or decrypt is updated \"in place\". Its"]
    #[doc = " length (`len` bytes) is not required to be a multiple of"]
    #[doc = " the block size; if the final block is partial, then the"]
    #[doc = " corresponding key stream bits are dropped."]
    #[doc = ""]
    #[doc = " The resulting counter value is returned."]
    #[doc = ""]
    #[doc = " \\param ctx    context structure (already initialised)."]
    #[doc = " \\param iv     IV for CTR encryption/decryption."]
    #[doc = " \\param cc     initial value for the block counter."]
    #[doc = " \\param data   data to encrypt or decrypt."]
    #[doc = " \\param len    data length (in bytes)."]
    #[doc = " \\return  the new block counter value."]
    pub run: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_block_ctr_class,
            iv: *const cty::c_void,
            cc: u32,
            data: *mut cty::c_void,
            len: usize,
        ) -> u32,
    >,
}
#[doc = " \\brief Class type for combined CTR and CBC-MAC implementations."]
#[doc = ""]
#[doc = " A `br_block_ctrcbc_class` instance points to the functions implementing"]
#[doc = " a specific block cipher, when used in CTR mode for encrypting or"]
#[doc = " decrypting data, along with CBC-MAC."]
pub type br_block_ctrcbc_class = br_block_ctrcbc_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_block_ctrcbc_class_ {
    #[doc = " \\brief Size (in bytes) of the context structure appropriate"]
    #[doc = " for containing subkeys."]
    pub context_size: usize,
    #[doc = " \\brief Size of individual blocks (in bytes)."]
    pub block_size: cty::c_uint,
    #[doc = " \\brief Base-2 logarithm of the size of individual blocks,"]
    #[doc = " expressed in bytes."]
    pub log_block_size: cty::c_uint,
    #[doc = " \\brief Initialisation function."]
    #[doc = ""]
    #[doc = " This function sets the `vtable` field in the context structure."]
    #[doc = " The key length MUST be one of the key lengths supported by"]
    #[doc = " the implementation."]
    #[doc = ""]
    #[doc = " \\param ctx       context structure to initialise."]
    #[doc = " \\param key       secret key."]
    #[doc = " \\param key_len   key length (in bytes)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_block_ctrcbc_class,
            key: *const cty::c_void,
            key_len: usize,
        ),
    >,
    #[doc = " \\brief Run the CTR encryption + CBC-MAC."]
    #[doc = ""]
    #[doc = " The `ctr` parameter points to the counter; its length shall"]
    #[doc = " be equal to the block size. It is updated by this function"]
    #[doc = " as encryption proceeds."]
    #[doc = ""]
    #[doc = " The `cbcmac` parameter points to the IV for CBC-MAC. The MAC"]
    #[doc = " is computed over the encrypted data (output of CTR"]
    #[doc = " encryption). Its length shall be equal to the block size. The"]
    #[doc = " computed CBC-MAC value is written over the `cbcmac` array."]
    #[doc = ""]
    #[doc = " The data to encrypt is updated \"in place\". Its length (`len`"]
    #[doc = " bytes) MUST be a multiple of the block size."]
    #[doc = ""]
    #[doc = " \\param ctx      context structure (already initialised)."]
    #[doc = " \\param ctr      counter for CTR encryption (initial and final)."]
    #[doc = " \\param cbcmac   IV and output buffer for CBC-MAC."]
    #[doc = " \\param data     data to encrypt."]
    #[doc = " \\param len      data length (in bytes)."]
    pub encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_block_ctrcbc_class,
            ctr: *mut cty::c_void,
            cbcmac: *mut cty::c_void,
            data: *mut cty::c_void,
            len: usize,
        ),
    >,
    #[doc = " \\brief Run the CTR decryption + CBC-MAC."]
    #[doc = ""]
    #[doc = " The `ctr` parameter points to the counter; its length shall"]
    #[doc = " be equal to the block size. It is updated by this function"]
    #[doc = " as decryption proceeds."]
    #[doc = ""]
    #[doc = " The `cbcmac` parameter points to the IV for CBC-MAC. The MAC"]
    #[doc = " is computed over the encrypted data (i.e. before CTR"]
    #[doc = " decryption). Its length shall be equal to the block size. The"]
    #[doc = " computed CBC-MAC value is written over the `cbcmac` array."]
    #[doc = ""]
    #[doc = " The data to decrypt is updated \"in place\". Its length (`len`"]
    #[doc = " bytes) MUST be a multiple of the block size."]
    #[doc = ""]
    #[doc = " \\param ctx      context structure (already initialised)."]
    #[doc = " \\param ctr      counter for CTR encryption (initial and final)."]
    #[doc = " \\param cbcmac   IV and output buffer for CBC-MAC."]
    #[doc = " \\param data     data to decrypt."]
    #[doc = " \\param len      data length (in bytes)."]
    pub decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_block_ctrcbc_class,
            ctr: *mut cty::c_void,
            cbcmac: *mut cty::c_void,
            data: *mut cty::c_void,
            len: usize,
        ),
    >,
    #[doc = " \\brief Run the CTR encryption/decryption only."]
    #[doc = ""]
    #[doc = " The `ctr` parameter points to the counter; its length shall"]
    #[doc = " be equal to the block size. It is updated by this function"]
    #[doc = " as decryption proceeds."]
    #[doc = ""]
    #[doc = " The data to decrypt is updated \"in place\". Its length (`len`"]
    #[doc = " bytes) MUST be a multiple of the block size."]
    #[doc = ""]
    #[doc = " \\param ctx      context structure (already initialised)."]
    #[doc = " \\param ctr      counter for CTR encryption (initial and final)."]
    #[doc = " \\param data     data to decrypt."]
    #[doc = " \\param len      data length (in bytes)."]
    pub ctr: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_block_ctrcbc_class,
            ctr: *mut cty::c_void,
            data: *mut cty::c_void,
            len: usize,
        ),
    >,
    #[doc = " \\brief Run the CBC-MAC only."]
    #[doc = ""]
    #[doc = " The `cbcmac` parameter points to the IV for CBC-MAC. The MAC"]
    #[doc = " is computed over the encrypted data (i.e. before CTR"]
    #[doc = " decryption). Its length shall be equal to the block size. The"]
    #[doc = " computed CBC-MAC value is written over the `cbcmac` array."]
    #[doc = ""]
    #[doc = " The data is unmodified. Its length (`len` bytes) MUST be a"]
    #[doc = " multiple of the block size."]
    #[doc = ""]
    #[doc = " \\param ctx      context structure (already initialised)."]
    #[doc = " \\param cbcmac   IV and output buffer for CBC-MAC."]
    #[doc = " \\param data     data to decrypt."]
    #[doc = " \\param len      data length (in bytes)."]
    pub mac: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_block_ctrcbc_class,
            cbcmac: *mut cty::c_void,
            data: *const cty::c_void,
            len: usize,
        ),
    >,
}
#[doc = " \\brief Context for AES subkeys (`aes_big` implementation, CBC encryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_big_cbcenc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcenc_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for AES subkeys (`aes_big` implementation, CBC decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_big_cbcdec_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcdec_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for AES subkeys (`aes_big` implementation, CTR encryption"]
#[doc = " and decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_big_ctr_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctr_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for AES subkeys (`aes_big` implementation, CTR encryption"]
#[doc = " and decryption + CBC-MAC)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_big_ctrcbc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctrcbc_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
extern "C" {
    pub static br_aes_big_cbcenc_vtable: br_block_cbcenc_class;
}
extern "C" {
    pub static br_aes_big_cbcdec_vtable: br_block_cbcdec_class;
}
extern "C" {
    pub static br_aes_big_ctr_vtable: br_block_ctr_class;
}
extern "C" {
    pub static br_aes_big_ctrcbc_vtable: br_block_ctrcbc_class;
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC encryption"]
    #[doc = " (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_big_cbcenc_init(
        ctx: *mut br_aes_big_cbcenc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC decryption"]
    #[doc = " (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_big_cbcdec_init(
        ctx: *mut br_aes_big_cbcdec_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR encryption"]
    #[doc = " and decryption (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_big_ctr_init(ctx: *mut br_aes_big_ctr_keys, key: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR + CBC-MAC"]
    #[doc = " (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_big_ctrcbc_init(
        ctx: *mut br_aes_big_ctrcbc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC encryption with AES (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to encrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_big_cbcenc_run(
        ctx: *const br_aes_big_cbcenc_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC decryption with AES (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_big_cbcdec_run(
        ctx: *const br_aes_big_cbcdec_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption and decryption with AES (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (constant, 12 bytes)."]
    #[doc = " \\param cc     initial block counter value."]
    #[doc = " \\param data   data to encrypt or decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes)."]
    #[doc = " \\return  new block counter value."]
    pub fn br_aes_big_ctr_run(
        ctx: *const br_aes_big_ctr_keys,
        iv: *const cty::c_void,
        cc: u32,
        data: *mut cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief CTR encryption + CBC-MAC with AES (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to encrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_big_ctrcbc_encrypt(
        ctx: *const br_aes_big_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR decryption + CBC-MAC with AES (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to decrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_big_ctrcbc_decrypt(
        ctx: *const br_aes_big_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption/decryption with AES (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param data     data to MAC (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_big_ctrcbc_ctr(
        ctx: *const br_aes_big_ctrcbc_keys,
        ctr: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC-MAC with AES (`aes_big` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to MAC (unmodified)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_big_ctrcbc_mac(
        ctx: *const br_aes_big_ctrcbc_keys,
        cbcmac: *mut cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
#[doc = " \\brief Context for AES subkeys (`aes_small` implementation, CBC encryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_small_cbcenc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcenc_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for AES subkeys (`aes_small` implementation, CBC decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_small_cbcdec_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcdec_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for AES subkeys (`aes_small` implementation, CTR encryption"]
#[doc = " and decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_small_ctr_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctr_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for AES subkeys (`aes_small` implementation, CTR encryption"]
#[doc = " and decryption + CBC-MAC)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_small_ctrcbc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctrcbc_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
extern "C" {
    pub static br_aes_small_cbcenc_vtable: br_block_cbcenc_class;
}
extern "C" {
    pub static br_aes_small_cbcdec_vtable: br_block_cbcdec_class;
}
extern "C" {
    pub static br_aes_small_ctr_vtable: br_block_ctr_class;
}
extern "C" {
    pub static br_aes_small_ctrcbc_vtable: br_block_ctrcbc_class;
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC encryption"]
    #[doc = " (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_small_cbcenc_init(
        ctx: *mut br_aes_small_cbcenc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC decryption"]
    #[doc = " (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_small_cbcdec_init(
        ctx: *mut br_aes_small_cbcdec_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR encryption"]
    #[doc = " and decryption (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_small_ctr_init(
        ctx: *mut br_aes_small_ctr_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR + CBC-MAC"]
    #[doc = " (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_small_ctrcbc_init(
        ctx: *mut br_aes_small_ctrcbc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC encryption with AES (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to encrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_small_cbcenc_run(
        ctx: *const br_aes_small_cbcenc_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC decryption with AES (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_small_cbcdec_run(
        ctx: *const br_aes_small_cbcdec_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption and decryption with AES (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (constant, 12 bytes)."]
    #[doc = " \\param cc     initial block counter value."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes)."]
    #[doc = " \\return  new block counter value."]
    pub fn br_aes_small_ctr_run(
        ctx: *const br_aes_small_ctr_keys,
        iv: *const cty::c_void,
        cc: u32,
        data: *mut cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief CTR encryption + CBC-MAC with AES (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to encrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_small_ctrcbc_encrypt(
        ctx: *const br_aes_small_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR decryption + CBC-MAC with AES (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to decrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_small_ctrcbc_decrypt(
        ctx: *const br_aes_small_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption/decryption with AES (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param data     data to MAC (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_small_ctrcbc_ctr(
        ctx: *const br_aes_small_ctrcbc_keys,
        ctr: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC-MAC with AES (`aes_small` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to MAC (unmodified)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_small_ctrcbc_mac(
        ctx: *const br_aes_small_ctrcbc_keys,
        cbcmac: *mut cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
#[doc = " \\brief Context for AES subkeys (`aes_ct` implementation, CBC encryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_ct_cbcenc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcenc_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for AES subkeys (`aes_ct` implementation, CBC decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_ct_cbcdec_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcdec_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for AES subkeys (`aes_ct` implementation, CTR encryption"]
#[doc = " and decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_ct_ctr_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctr_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for AES subkeys (`aes_ct` implementation, CTR encryption"]
#[doc = " and decryption + CBC-MAC)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_ct_ctrcbc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctrcbc_class,
    pub skey: [u32; 60usize],
    pub num_rounds: cty::c_uint,
}
extern "C" {
    pub static br_aes_ct_cbcenc_vtable: br_block_cbcenc_class;
}
extern "C" {
    pub static br_aes_ct_cbcdec_vtable: br_block_cbcdec_class;
}
extern "C" {
    pub static br_aes_ct_ctr_vtable: br_block_ctr_class;
}
extern "C" {
    pub static br_aes_ct_ctrcbc_vtable: br_block_ctrcbc_class;
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC encryption"]
    #[doc = " (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_ct_cbcenc_init(
        ctx: *mut br_aes_ct_cbcenc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC decryption"]
    #[doc = " (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_ct_cbcdec_init(
        ctx: *mut br_aes_ct_cbcdec_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR encryption"]
    #[doc = " and decryption (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_ct_ctr_init(ctx: *mut br_aes_ct_ctr_keys, key: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR + CBC-MAC"]
    #[doc = " (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_ct_ctrcbc_init(
        ctx: *mut br_aes_ct_ctrcbc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC encryption with AES (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to encrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_ct_cbcenc_run(
        ctx: *const br_aes_ct_cbcenc_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC decryption with AES (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_ct_cbcdec_run(
        ctx: *const br_aes_ct_cbcdec_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption and decryption with AES (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (constant, 12 bytes)."]
    #[doc = " \\param cc     initial block counter value."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes)."]
    #[doc = " \\return  new block counter value."]
    pub fn br_aes_ct_ctr_run(
        ctx: *const br_aes_ct_ctr_keys,
        iv: *const cty::c_void,
        cc: u32,
        data: *mut cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief CTR encryption + CBC-MAC with AES (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to encrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_ct_ctrcbc_encrypt(
        ctx: *const br_aes_ct_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR decryption + CBC-MAC with AES (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to decrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_ct_ctrcbc_decrypt(
        ctx: *const br_aes_ct_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption/decryption with AES (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param data     data to MAC (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_ct_ctrcbc_ctr(
        ctx: *const br_aes_ct_ctrcbc_keys,
        ctr: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC-MAC with AES (`aes_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to MAC (unmodified)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_ct_ctrcbc_mac(
        ctx: *const br_aes_ct_ctrcbc_keys,
        cbcmac: *mut cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
#[doc = " \\brief Context for AES subkeys (`aes_ct64` implementation, CBC encryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct br_aes_ct64_cbcenc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcenc_class,
    pub __bindgen_padding_0: u32,
    pub skey: [u64; 30usize],
    pub num_rounds: cty::c_uint,
    pub __bindgen_padding_1: u32,
}
#[doc = " \\brief Context for AES subkeys (`aes_ct64` implementation, CBC decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct br_aes_ct64_cbcdec_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcdec_class,
    pub __bindgen_padding_0: u32,
    pub skey: [u64; 30usize],
    pub num_rounds: cty::c_uint,
    pub __bindgen_padding_1: u32,
}
#[doc = " \\brief Context for AES subkeys (`aes_ct64` implementation, CTR encryption"]
#[doc = " and decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct br_aes_ct64_ctr_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctr_class,
    pub __bindgen_padding_0: u32,
    pub skey: [u64; 30usize],
    pub num_rounds: cty::c_uint,
    pub __bindgen_padding_1: u32,
}
#[doc = " \\brief Context for AES subkeys (`aes_ct64` implementation, CTR encryption"]
#[doc = " and decryption + CBC-MAC)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct br_aes_ct64_ctrcbc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctrcbc_class,
    pub __bindgen_padding_0: u32,
    pub skey: [u64; 30usize],
    pub num_rounds: cty::c_uint,
    pub __bindgen_padding_1: u32,
}
extern "C" {
    pub static br_aes_ct64_cbcenc_vtable: br_block_cbcenc_class;
}
extern "C" {
    pub static br_aes_ct64_cbcdec_vtable: br_block_cbcdec_class;
}
extern "C" {
    pub static br_aes_ct64_ctr_vtable: br_block_ctr_class;
}
extern "C" {
    pub static br_aes_ct64_ctrcbc_vtable: br_block_ctrcbc_class;
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC encryption"]
    #[doc = " (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_ct64_cbcenc_init(
        ctx: *mut br_aes_ct64_cbcenc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC decryption"]
    #[doc = " (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_ct64_cbcdec_init(
        ctx: *mut br_aes_ct64_cbcdec_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR encryption"]
    #[doc = " and decryption (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_ct64_ctr_init(
        ctx: *mut br_aes_ct64_ctr_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR + CBC-MAC"]
    #[doc = " (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_ct64_ctrcbc_init(
        ctx: *mut br_aes_ct64_ctrcbc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC encryption with AES (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to encrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_ct64_cbcenc_run(
        ctx: *const br_aes_ct64_cbcenc_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC decryption with AES (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_ct64_cbcdec_run(
        ctx: *const br_aes_ct64_cbcdec_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption and decryption with AES (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (constant, 12 bytes)."]
    #[doc = " \\param cc     initial block counter value."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes)."]
    #[doc = " \\return  new block counter value."]
    pub fn br_aes_ct64_ctr_run(
        ctx: *const br_aes_ct64_ctr_keys,
        iv: *const cty::c_void,
        cc: u32,
        data: *mut cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief CTR encryption + CBC-MAC with AES (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to encrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_ct64_ctrcbc_encrypt(
        ctx: *const br_aes_ct64_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR decryption + CBC-MAC with AES (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to decrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_ct64_ctrcbc_decrypt(
        ctx: *const br_aes_ct64_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption/decryption with AES (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param data     data to MAC (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_ct64_ctrcbc_ctr(
        ctx: *const br_aes_ct64_ctrcbc_keys,
        ctr: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC-MAC with AES (`aes_ct64` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to MAC (unmodified)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_ct64_ctrcbc_mac(
        ctx: *const br_aes_ct64_ctrcbc_keys,
        cbcmac: *mut cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
#[doc = " \\brief Context for AES subkeys (`aes_x86ni` implementation, CBC encryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_x86ni_cbcenc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcenc_class,
    pub skey: br_aes_x86ni_cbcenc_keys__bindgen_ty_1,
    pub num_rounds: cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_x86ni_cbcenc_keys__bindgen_ty_1 {
    pub skni: [cty::c_uchar; 240usize],
    _bindgen_union_align: [u8; 240usize],
}
#[doc = " \\brief Context for AES subkeys (`aes_x86ni` implementation, CBC decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_x86ni_cbcdec_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcdec_class,
    pub skey: br_aes_x86ni_cbcdec_keys__bindgen_ty_1,
    pub num_rounds: cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_x86ni_cbcdec_keys__bindgen_ty_1 {
    pub skni: [cty::c_uchar; 240usize],
    _bindgen_union_align: [u8; 240usize],
}
#[doc = " \\brief Context for AES subkeys (`aes_x86ni` implementation, CTR encryption"]
#[doc = " and decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_x86ni_ctr_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctr_class,
    pub skey: br_aes_x86ni_ctr_keys__bindgen_ty_1,
    pub num_rounds: cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_x86ni_ctr_keys__bindgen_ty_1 {
    pub skni: [cty::c_uchar; 240usize],
    _bindgen_union_align: [u8; 240usize],
}
#[doc = " \\brief Context for AES subkeys (`aes_x86ni` implementation, CTR encryption"]
#[doc = " and decryption + CBC-MAC)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_x86ni_ctrcbc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctrcbc_class,
    pub skey: br_aes_x86ni_ctrcbc_keys__bindgen_ty_1,
    pub num_rounds: cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 {
    pub skni: [cty::c_uchar; 240usize],
    _bindgen_union_align: [u8; 240usize],
}
extern "C" {
    pub static br_aes_x86ni_cbcenc_vtable: br_block_cbcenc_class;
}
extern "C" {
    pub static br_aes_x86ni_cbcdec_vtable: br_block_cbcdec_class;
}
extern "C" {
    pub static br_aes_x86ni_ctr_vtable: br_block_ctr_class;
}
extern "C" {
    pub static br_aes_x86ni_ctrcbc_vtable: br_block_ctrcbc_class;
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC encryption"]
    #[doc = " (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_x86ni_cbcenc_init(
        ctx: *mut br_aes_x86ni_cbcenc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC decryption"]
    #[doc = " (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_x86ni_cbcdec_init(
        ctx: *mut br_aes_x86ni_cbcdec_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR encryption"]
    #[doc = " and decryption (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_x86ni_ctr_init(
        ctx: *mut br_aes_x86ni_ctr_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR + CBC-MAC"]
    #[doc = " (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_x86ni_ctrcbc_init(
        ctx: *mut br_aes_x86ni_ctrcbc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC encryption with AES (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to encrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_x86ni_cbcenc_run(
        ctx: *const br_aes_x86ni_cbcenc_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC decryption with AES (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_x86ni_cbcdec_run(
        ctx: *const br_aes_x86ni_cbcdec_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption and decryption with AES (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (constant, 12 bytes)."]
    #[doc = " \\param cc     initial block counter value."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes)."]
    #[doc = " \\return  new block counter value."]
    pub fn br_aes_x86ni_ctr_run(
        ctx: *const br_aes_x86ni_ctr_keys,
        iv: *const cty::c_void,
        cc: u32,
        data: *mut cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief CTR encryption + CBC-MAC with AES (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to encrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_x86ni_ctrcbc_encrypt(
        ctx: *const br_aes_x86ni_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR decryption + CBC-MAC with AES (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to decrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_x86ni_ctrcbc_decrypt(
        ctx: *const br_aes_x86ni_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption/decryption with AES (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param data     data to MAC (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_x86ni_ctrcbc_ctr(
        ctx: *const br_aes_x86ni_ctrcbc_keys,
        ctr: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC-MAC with AES (`aes_x86ni` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to MAC (unmodified)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_x86ni_ctrcbc_mac(
        ctx: *const br_aes_x86ni_ctrcbc_keys,
        cbcmac: *mut cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Obtain the `aes_x86ni` AES-CBC (encryption) implementation, if"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to `br_aes_x86ni_cbcenc_vtable`, if"]
    #[doc = " that implementation was compiled in the library _and_ the x86 AES"]
    #[doc = " opcodes are available on the currently running CPU. If either of"]
    #[doc = " these conditions is not met, then this function returns `NULL`."]
    #[doc = ""]
    #[doc = " \\return  the `aes_x86ni` AES-CBC (encryption) implementation, or `NULL`."]
    pub fn br_aes_x86ni_cbcenc_get_vtable() -> *const br_block_cbcenc_class;
}
extern "C" {
    #[doc = " \\brief Obtain the `aes_x86ni` AES-CBC (decryption) implementation, if"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to `br_aes_x86ni_cbcdec_vtable`, if"]
    #[doc = " that implementation was compiled in the library _and_ the x86 AES"]
    #[doc = " opcodes are available on the currently running CPU. If either of"]
    #[doc = " these conditions is not met, then this function returns `NULL`."]
    #[doc = ""]
    #[doc = " \\return  the `aes_x86ni` AES-CBC (decryption) implementation, or `NULL`."]
    pub fn br_aes_x86ni_cbcdec_get_vtable() -> *const br_block_cbcdec_class;
}
extern "C" {
    #[doc = " \\brief Obtain the `aes_x86ni` AES-CTR implementation, if available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to `br_aes_x86ni_ctr_vtable`, if"]
    #[doc = " that implementation was compiled in the library _and_ the x86 AES"]
    #[doc = " opcodes are available on the currently running CPU. If either of"]
    #[doc = " these conditions is not met, then this function returns `NULL`."]
    #[doc = ""]
    #[doc = " \\return  the `aes_x86ni` AES-CTR implementation, or `NULL`."]
    pub fn br_aes_x86ni_ctr_get_vtable() -> *const br_block_ctr_class;
}
extern "C" {
    #[doc = " \\brief Obtain the `aes_x86ni` AES-CTR + CBC-MAC implementation, if"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to `br_aes_x86ni_ctrcbc_vtable`, if"]
    #[doc = " that implementation was compiled in the library _and_ the x86 AES"]
    #[doc = " opcodes are available on the currently running CPU. If either of"]
    #[doc = " these conditions is not met, then this function returns `NULL`."]
    #[doc = ""]
    #[doc = " \\return  the `aes_x86ni` AES-CTR implementation, or `NULL`."]
    pub fn br_aes_x86ni_ctrcbc_get_vtable() -> *const br_block_ctrcbc_class;
}
#[doc = " \\brief Context for AES subkeys (`aes_pwr8` implementation, CBC encryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_pwr8_cbcenc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcenc_class,
    pub skey: br_aes_pwr8_cbcenc_keys__bindgen_ty_1,
    pub num_rounds: cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_pwr8_cbcenc_keys__bindgen_ty_1 {
    pub skni: [cty::c_uchar; 240usize],
    _bindgen_union_align: [u8; 240usize],
}
#[doc = " \\brief Context for AES subkeys (`aes_pwr8` implementation, CBC decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_pwr8_cbcdec_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcdec_class,
    pub skey: br_aes_pwr8_cbcdec_keys__bindgen_ty_1,
    pub num_rounds: cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_pwr8_cbcdec_keys__bindgen_ty_1 {
    pub skni: [cty::c_uchar; 240usize],
    _bindgen_union_align: [u8; 240usize],
}
#[doc = " \\brief Context for AES subkeys (`aes_pwr8` implementation, CTR encryption"]
#[doc = " and decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_pwr8_ctr_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctr_class,
    pub skey: br_aes_pwr8_ctr_keys__bindgen_ty_1,
    pub num_rounds: cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_pwr8_ctr_keys__bindgen_ty_1 {
    pub skni: [cty::c_uchar; 240usize],
    _bindgen_union_align: [u8; 240usize],
}
#[doc = " \\brief Context for AES subkeys (`aes_pwr8` implementation, CTR encryption"]
#[doc = " and decryption + CBC-MAC)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aes_pwr8_ctrcbc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_ctrcbc_class,
    pub skey: br_aes_pwr8_ctrcbc_keys__bindgen_ty_1,
    pub num_rounds: cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_pwr8_ctrcbc_keys__bindgen_ty_1 {
    pub skni: [cty::c_uchar; 240usize],
    _bindgen_union_align: [u8; 240usize],
}
extern "C" {
    pub static br_aes_pwr8_cbcenc_vtable: br_block_cbcenc_class;
}
extern "C" {
    pub static br_aes_pwr8_cbcdec_vtable: br_block_cbcdec_class;
}
extern "C" {
    pub static br_aes_pwr8_ctr_vtable: br_block_ctr_class;
}
extern "C" {
    pub static br_aes_pwr8_ctrcbc_vtable: br_block_ctrcbc_class;
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC encryption"]
    #[doc = " (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_pwr8_cbcenc_init(
        ctx: *mut br_aes_pwr8_cbcenc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CBC decryption"]
    #[doc = " (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_pwr8_cbcdec_init(
        ctx: *mut br_aes_pwr8_cbcdec_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR encryption"]
    #[doc = " and decryption (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_pwr8_ctr_init(
        ctx: *mut br_aes_pwr8_ctr_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for AES CTR + CBC-MAC"]
    #[doc = " (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_aes_pwr8_ctrcbc_init(
        ctx: *mut br_aes_pwr8_ctrcbc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC encryption with AES (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to encrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_pwr8_cbcenc_run(
        ctx: *const br_aes_pwr8_cbcenc_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC decryption with AES (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 16)."]
    pub fn br_aes_pwr8_cbcdec_run(
        ctx: *const br_aes_pwr8_cbcdec_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption and decryption with AES (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (constant, 12 bytes)."]
    #[doc = " \\param cc     initial block counter value."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes)."]
    #[doc = " \\return  new block counter value."]
    pub fn br_aes_pwr8_ctr_run(
        ctx: *const br_aes_pwr8_ctr_keys,
        iv: *const cty::c_void,
        cc: u32,
        data: *mut cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief CTR encryption + CBC-MAC with AES (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to encrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_pwr8_ctrcbc_encrypt(
        ctx: *const br_aes_pwr8_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR decryption + CBC-MAC with AES (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to decrypt (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_pwr8_ctrcbc_decrypt(
        ctx: *const br_aes_pwr8_ctrcbc_keys,
        ctr: *mut cty::c_void,
        cbcmac: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CTR encryption/decryption with AES (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param ctr      counter for CTR (16 bytes, updated)."]
    #[doc = " \\param data     data to MAC (updated)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_pwr8_ctrcbc_ctr(
        ctx: *const br_aes_pwr8_ctrcbc_keys,
        ctr: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC-MAC with AES (`aes_pwr8` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx      context (already initialised)."]
    #[doc = " \\param cbcmac   IV for CBC-MAC (updated)."]
    #[doc = " \\param data     data to MAC (unmodified)."]
    #[doc = " \\param len      data length (in bytes, MUST be a multiple of 16)."]
    pub fn br_aes_pwr8_ctrcbc_mac(
        ctx: *const br_aes_pwr8_ctrcbc_keys,
        cbcmac: *mut cty::c_void,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Obtain the `aes_pwr8` AES-CBC (encryption) implementation, if"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to `br_aes_pwr8_cbcenc_vtable`, if"]
    #[doc = " that implementation was compiled in the library _and_ the POWER8"]
    #[doc = " crypto opcodes are available on the currently running CPU. If either"]
    #[doc = " of these conditions is not met, then this function returns `NULL`."]
    #[doc = ""]
    #[doc = " \\return  the `aes_pwr8` AES-CBC (encryption) implementation, or `NULL`."]
    pub fn br_aes_pwr8_cbcenc_get_vtable() -> *const br_block_cbcenc_class;
}
extern "C" {
    #[doc = " \\brief Obtain the `aes_pwr8` AES-CBC (decryption) implementation, if"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to `br_aes_pwr8_cbcdec_vtable`, if"]
    #[doc = " that implementation was compiled in the library _and_ the POWER8"]
    #[doc = " crypto opcodes are available on the currently running CPU. If either"]
    #[doc = " of these conditions is not met, then this function returns `NULL`."]
    #[doc = ""]
    #[doc = " \\return  the `aes_pwr8` AES-CBC (decryption) implementation, or `NULL`."]
    pub fn br_aes_pwr8_cbcdec_get_vtable() -> *const br_block_cbcdec_class;
}
extern "C" {
    #[doc = " \\brief Obtain the `aes_pwr8` AES-CTR implementation, if available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to `br_aes_pwr8_ctr_vtable`, if that"]
    #[doc = " implementation was compiled in the library _and_ the POWER8 crypto"]
    #[doc = " opcodes are available on the currently running CPU. If either of"]
    #[doc = " these conditions is not met, then this function returns `NULL`."]
    #[doc = ""]
    #[doc = " \\return  the `aes_pwr8` AES-CTR implementation, or `NULL`."]
    pub fn br_aes_pwr8_ctr_get_vtable() -> *const br_block_ctr_class;
}
extern "C" {
    #[doc = " \\brief Obtain the `aes_pwr8` AES-CTR + CBC-MAC implementation, if"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to `br_aes_pwr8_ctrcbc_vtable`, if"]
    #[doc = " that implementation was compiled in the library _and_ the POWER8 AES"]
    #[doc = " opcodes are available on the currently running CPU. If either of"]
    #[doc = " these conditions is not met, then this function returns `NULL`."]
    #[doc = ""]
    #[doc = " \\return  the `aes_pwr8` AES-CTR implementation, or `NULL`."]
    pub fn br_aes_pwr8_ctrcbc_get_vtable() -> *const br_block_ctrcbc_class;
}
#[doc = " \\brief Aggregate structure large enough to be used as context for"]
#[doc = " subkeys (CBC encryption) for all AES implementations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_gen_cbcenc_keys {
    pub vtable: *const br_block_cbcenc_class,
    pub c_big: br_aes_big_cbcenc_keys,
    pub c_small: br_aes_small_cbcenc_keys,
    pub c_ct: br_aes_ct_cbcenc_keys,
    pub c_ct64: br_aes_ct64_cbcenc_keys,
    pub c_x86ni: br_aes_x86ni_cbcenc_keys,
    pub c_pwr8: br_aes_pwr8_cbcenc_keys,
    _bindgen_union_align: [u64; 32usize],
}
#[doc = " \\brief Aggregate structure large enough to be used as context for"]
#[doc = " subkeys (CBC decryption) for all AES implementations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_gen_cbcdec_keys {
    pub vtable: *const br_block_cbcdec_class,
    pub c_big: br_aes_big_cbcdec_keys,
    pub c_small: br_aes_small_cbcdec_keys,
    pub c_ct: br_aes_ct_cbcdec_keys,
    pub c_ct64: br_aes_ct64_cbcdec_keys,
    pub c_x86ni: br_aes_x86ni_cbcdec_keys,
    pub c_pwr8: br_aes_pwr8_cbcdec_keys,
    _bindgen_union_align: [u64; 32usize],
}
#[doc = " \\brief Aggregate structure large enough to be used as context for"]
#[doc = " subkeys (CTR encryption and decryption) for all AES implementations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_gen_ctr_keys {
    pub vtable: *const br_block_ctr_class,
    pub c_big: br_aes_big_ctr_keys,
    pub c_small: br_aes_small_ctr_keys,
    pub c_ct: br_aes_ct_ctr_keys,
    pub c_ct64: br_aes_ct64_ctr_keys,
    pub c_x86ni: br_aes_x86ni_ctr_keys,
    pub c_pwr8: br_aes_pwr8_ctr_keys,
    _bindgen_union_align: [u64; 32usize],
}
#[doc = " \\brief Aggregate structure large enough to be used as context for"]
#[doc = " subkeys (CTR encryption/decryption + CBC-MAC) for all AES implementations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_aes_gen_ctrcbc_keys {
    pub vtable: *const br_block_ctrcbc_class,
    pub c_big: br_aes_big_ctrcbc_keys,
    pub c_small: br_aes_small_ctrcbc_keys,
    pub c_ct: br_aes_ct_ctrcbc_keys,
    pub c_ct64: br_aes_ct64_ctrcbc_keys,
    pub c_x86ni: br_aes_x86ni_ctrcbc_keys,
    pub c_pwr8: br_aes_pwr8_ctrcbc_keys,
    _bindgen_union_align: [u64; 32usize],
}
#[doc = " \\brief Context for DES subkeys (`des_tab` implementation, CBC encryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_des_tab_cbcenc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcenc_class,
    pub skey: [u32; 96usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for DES subkeys (`des_tab` implementation, CBC decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_des_tab_cbcdec_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcdec_class,
    pub skey: [u32; 96usize],
    pub num_rounds: cty::c_uint,
}
extern "C" {
    pub static br_des_tab_cbcenc_vtable: br_block_cbcenc_class;
}
extern "C" {
    pub static br_des_tab_cbcdec_vtable: br_block_cbcdec_class;
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for DES CBC encryption"]
    #[doc = " (`des_tab` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_des_tab_cbcenc_init(
        ctx: *mut br_des_tab_cbcenc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for DES CBC decryption"]
    #[doc = " (`des_tab` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_des_tab_cbcdec_init(
        ctx: *mut br_des_tab_cbcdec_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC encryption with DES (`des_tab` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to encrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 8)."]
    pub fn br_des_tab_cbcenc_run(
        ctx: *const br_des_tab_cbcenc_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC decryption with DES (`des_tab` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 8)."]
    pub fn br_des_tab_cbcdec_run(
        ctx: *const br_des_tab_cbcdec_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
#[doc = " \\brief Context for DES subkeys (`des_ct` implementation, CBC encryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_des_ct_cbcenc_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcenc_class,
    pub skey: [u32; 96usize],
    pub num_rounds: cty::c_uint,
}
#[doc = " \\brief Context for DES subkeys (`des_ct` implementation, CBC decryption)."]
#[doc = ""]
#[doc = " First field is a pointer to the vtable; it is set by the initialisation"]
#[doc = " function. Other fields are not supposed to be accessed by user code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_des_ct_cbcdec_keys {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_block_cbcdec_class,
    pub skey: [u32; 96usize],
    pub num_rounds: cty::c_uint,
}
extern "C" {
    pub static br_des_ct_cbcenc_vtable: br_block_cbcenc_class;
}
extern "C" {
    pub static br_des_ct_cbcdec_vtable: br_block_cbcdec_class;
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for DES CBC encryption"]
    #[doc = " (`des_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_des_ct_cbcenc_init(
        ctx: *mut br_des_ct_cbcenc_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Context initialisation (key schedule) for DES CBC decryption"]
    #[doc = " (`des_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx   context to initialise."]
    #[doc = " \\param key   secret key."]
    #[doc = " \\param len   secret key length (in bytes)."]
    pub fn br_des_ct_cbcdec_init(
        ctx: *mut br_des_ct_cbcdec_keys,
        key: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC encryption with DES (`des_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to encrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 8)."]
    pub fn br_des_ct_cbcenc_run(
        ctx: *const br_des_ct_cbcenc_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief CBC decryption with DES (`des_ct` implementation)."]
    #[doc = ""]
    #[doc = " \\param ctx    context (already initialised)."]
    #[doc = " \\param iv     IV (updated)."]
    #[doc = " \\param data   data to decrypt (updated)."]
    #[doc = " \\param len    data length (in bytes, MUST be multiple of 8)."]
    pub fn br_des_ct_cbcdec_run(
        ctx: *const br_des_ct_cbcdec_keys,
        iv: *mut cty::c_void,
        data: *mut cty::c_void,
        len: usize,
    );
}
#[doc = " \\brief Aggregate structure large enough to be used as context for"]
#[doc = " subkeys (CBC encryption) for all DES implementations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_des_gen_cbcenc_keys {
    pub vtable: *const br_block_cbcenc_class,
    pub tab: br_des_tab_cbcenc_keys,
    pub ct: br_des_ct_cbcenc_keys,
    _bindgen_union_align: [u32; 98usize],
}
#[doc = " \\brief Aggregate structure large enough to be used as context for"]
#[doc = " subkeys (CBC decryption) for all DES implementations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_des_gen_cbcdec_keys {
    pub vtable: *const br_block_cbcdec_class,
    pub c_tab: br_des_tab_cbcdec_keys,
    pub c_ct: br_des_ct_cbcdec_keys,
    _bindgen_union_align: [u32; 98usize],
}
#[doc = " \\brief Type for a ChaCha20 implementation."]
#[doc = ""]
#[doc = " An implementation follows the description in RFC 7539:"]
#[doc = ""]
#[doc = "   - Key is 256 bits (`key` points to exactly 32 bytes)."]
#[doc = ""]
#[doc = "   - IV is 96 bits (`iv` points to exactly 12 bytes)."]
#[doc = ""]
#[doc = "   - Block counter is over 32 bits and starts at value `cc`; the"]
#[doc = "     resulting value is returned."]
#[doc = ""]
#[doc = " Data (pointed to by `data`, of length `len`) is encrypted/decrypted"]
#[doc = " in place. If `len` is not a multiple of 64, then the excess bytes from"]
#[doc = " the last block processing are dropped (therefore, \"chunked\" processing"]
#[doc = " works only as long as each non-final chunk has a length multiple of 64)."]
#[doc = ""]
#[doc = " \\param key    secret key (32 bytes)."]
#[doc = " \\param iv     IV (12 bytes)."]
#[doc = " \\param cc     initial counter value."]
#[doc = " \\param data   data to encrypt or decrypt."]
#[doc = " \\param len    data length (in bytes)."]
pub type br_chacha20_run = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_void,
        iv: *const cty::c_void,
        cc: u32,
        data: *mut cty::c_void,
        len: usize,
    ) -> u32,
>;
extern "C" {
    #[doc = " \\brief ChaCha20 implementation (straightforward C code, constant-time)."]
    #[doc = ""]
    #[doc = " \\see br_chacha20_run"]
    #[doc = ""]
    #[doc = " \\param key    secret key (32 bytes)."]
    #[doc = " \\param iv     IV (12 bytes)."]
    #[doc = " \\param cc     initial counter value."]
    #[doc = " \\param data   data to encrypt or decrypt."]
    #[doc = " \\param len    data length (in bytes)."]
    pub fn br_chacha20_ct_run(
        key: *const cty::c_void,
        iv: *const cty::c_void,
        cc: u32,
        data: *mut cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief ChaCha20 implementation (SSE2 code, constant-time)."]
    #[doc = ""]
    #[doc = " This implementation is available only on x86 platforms, depending on"]
    #[doc = " compiler support. Moreover, in 32-bit mode, it might not actually run,"]
    #[doc = " if the underlying hardware does not implement the SSE2 opcode (in"]
    #[doc = " 64-bit mode, SSE2 is part of the ABI, so if the code could be compiled"]
    #[doc = " at all, then it can run). Use `br_chacha20_sse2_get()` to safely obtain"]
    #[doc = " a pointer to that function."]
    #[doc = ""]
    #[doc = " \\see br_chacha20_run"]
    #[doc = ""]
    #[doc = " \\param key    secret key (32 bytes)."]
    #[doc = " \\param iv     IV (12 bytes)."]
    #[doc = " \\param cc     initial counter value."]
    #[doc = " \\param data   data to encrypt or decrypt."]
    #[doc = " \\param len    data length (in bytes)."]
    pub fn br_chacha20_sse2_run(
        key: *const cty::c_void,
        iv: *const cty::c_void,
        cc: u32,
        data: *mut cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief Obtain the `sse2` ChaCha20 implementation, if available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to `br_chacha20_sse2_run`, if"]
    #[doc = " that implementation was compiled in the library _and_ the SSE2"]
    #[doc = " opcodes are available on the currently running CPU. If either of"]
    #[doc = " these conditions is not met, then this function returns `0`."]
    #[doc = ""]
    #[doc = " \\return  the `sse2` ChaCha20 implementation, or `0`."]
    pub fn br_chacha20_sse2_get() -> br_chacha20_run;
}
#[doc = " \\brief Type for a ChaCha20+Poly1305 AEAD implementation."]
#[doc = ""]
#[doc = " The provided data is encrypted or decrypted with ChaCha20. The"]
#[doc = " authentication tag is computed on the concatenation of the"]
#[doc = " additional data and the ciphertext, with the padding and lengths"]
#[doc = " as described in RFC 7539 (section 2.8)."]
#[doc = ""]
#[doc = " After decryption, the caller is responsible for checking that the"]
#[doc = " computed tag matches the expected value."]
#[doc = ""]
#[doc = " \\param key       secret key (32 bytes)."]
#[doc = " \\param iv        nonce (12 bytes)."]
#[doc = " \\param data      data to encrypt or decrypt."]
#[doc = " \\param len       data length (in bytes)."]
#[doc = " \\param aad       additional authenticated data."]
#[doc = " \\param aad_len   length of additional authenticated data (in bytes)."]
#[doc = " \\param tag       output buffer for the authentication tag."]
#[doc = " \\param ichacha   implementation of ChaCha20."]
#[doc = " \\param encrypt   non-zero for encryption, zero for decryption."]
pub type br_poly1305_run = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_void,
        iv: *const cty::c_void,
        data: *mut cty::c_void,
        len: usize,
        aad: *const cty::c_void,
        aad_len: usize,
        tag: *mut cty::c_void,
        ichacha: br_chacha20_run,
        encrypt: cty::c_int,
    ),
>;
extern "C" {
    #[doc = " \\brief ChaCha20+Poly1305 AEAD implementation (mixed 32-bit multiplications)."]
    #[doc = ""]
    #[doc = " \\see br_poly1305_run"]
    #[doc = ""]
    #[doc = " \\param key       secret key (32 bytes)."]
    #[doc = " \\param iv        nonce (12 bytes)."]
    #[doc = " \\param data      data to encrypt or decrypt."]
    #[doc = " \\param len       data length (in bytes)."]
    #[doc = " \\param aad       additional authenticated data."]
    #[doc = " \\param aad_len   length of additional authenticated data (in bytes)."]
    #[doc = " \\param tag       output buffer for the authentication tag."]
    #[doc = " \\param ichacha   implementation of ChaCha20."]
    #[doc = " \\param encrypt   non-zero for encryption, zero for decryption."]
    pub fn br_poly1305_ctmul_run(
        key: *const cty::c_void,
        iv: *const cty::c_void,
        data: *mut cty::c_void,
        len: usize,
        aad: *const cty::c_void,
        aad_len: usize,
        tag: *mut cty::c_void,
        ichacha: br_chacha20_run,
        encrypt: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief ChaCha20+Poly1305 AEAD implementation (pure 32-bit multiplications)."]
    #[doc = ""]
    #[doc = " \\see br_poly1305_run"]
    #[doc = ""]
    #[doc = " \\param key       secret key (32 bytes)."]
    #[doc = " \\param iv        nonce (12 bytes)."]
    #[doc = " \\param data      data to encrypt or decrypt."]
    #[doc = " \\param len       data length (in bytes)."]
    #[doc = " \\param aad       additional authenticated data."]
    #[doc = " \\param aad_len   length of additional authenticated data (in bytes)."]
    #[doc = " \\param tag       output buffer for the authentication tag."]
    #[doc = " \\param ichacha   implementation of ChaCha20."]
    #[doc = " \\param encrypt   non-zero for encryption, zero for decryption."]
    pub fn br_poly1305_ctmul32_run(
        key: *const cty::c_void,
        iv: *const cty::c_void,
        data: *mut cty::c_void,
        len: usize,
        aad: *const cty::c_void,
        aad_len: usize,
        tag: *mut cty::c_void,
        ichacha: br_chacha20_run,
        encrypt: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief ChaCha20+Poly1305 AEAD implementation (i15)."]
    #[doc = ""]
    #[doc = " This implementation relies on the generic big integer code \"i15\""]
    #[doc = " (which uses pure 32-bit multiplications). As such, it may save a"]
    #[doc = " little code footprint in a context where \"i15\" is already included"]
    #[doc = " (e.g. for elliptic curves or for RSA); however, it is also"]
    #[doc = " substantially slower than the ctmul and ctmul32 implementations."]
    #[doc = ""]
    #[doc = " \\see br_poly1305_run"]
    #[doc = ""]
    #[doc = " \\param key       secret key (32 bytes)."]
    #[doc = " \\param iv        nonce (12 bytes)."]
    #[doc = " \\param data      data to encrypt or decrypt."]
    #[doc = " \\param len       data length (in bytes)."]
    #[doc = " \\param aad       additional authenticated data."]
    #[doc = " \\param aad_len   length of additional authenticated data (in bytes)."]
    #[doc = " \\param tag       output buffer for the authentication tag."]
    #[doc = " \\param ichacha   implementation of ChaCha20."]
    #[doc = " \\param encrypt   non-zero for encryption, zero for decryption."]
    pub fn br_poly1305_i15_run(
        key: *const cty::c_void,
        iv: *const cty::c_void,
        data: *mut cty::c_void,
        len: usize,
        aad: *const cty::c_void,
        aad_len: usize,
        tag: *mut cty::c_void,
        ichacha: br_chacha20_run,
        encrypt: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief ChaCha20+Poly1305 AEAD implementation (ctmulq)."]
    #[doc = ""]
    #[doc = " This implementation uses 64-bit multiplications (result over 128 bits)."]
    #[doc = " It is available only on platforms that offer such a primitive (in"]
    #[doc = " practice, 64-bit architectures). Use `br_poly1305_ctmulq_get()` to"]
    #[doc = " dynamically obtain a pointer to that function, or 0 if not supported."]
    #[doc = ""]
    #[doc = " \\see br_poly1305_run"]
    #[doc = ""]
    #[doc = " \\param key       secret key (32 bytes)."]
    #[doc = " \\param iv        nonce (12 bytes)."]
    #[doc = " \\param data      data to encrypt or decrypt."]
    #[doc = " \\param len       data length (in bytes)."]
    #[doc = " \\param aad       additional authenticated data."]
    #[doc = " \\param aad_len   length of additional authenticated data (in bytes)."]
    #[doc = " \\param tag       output buffer for the authentication tag."]
    #[doc = " \\param ichacha   implementation of ChaCha20."]
    #[doc = " \\param encrypt   non-zero for encryption, zero for decryption."]
    pub fn br_poly1305_ctmulq_run(
        key: *const cty::c_void,
        iv: *const cty::c_void,
        data: *mut cty::c_void,
        len: usize,
        aad: *const cty::c_void,
        aad_len: usize,
        tag: *mut cty::c_void,
        ichacha: br_chacha20_run,
        encrypt: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Get the ChaCha20+Poly1305 \"ctmulq\" implementation, if available."]
    #[doc = ""]
    #[doc = " This function returns a pointer to the `br_poly1305_ctmulq_run()`"]
    #[doc = " function if supported on the current platform; otherwise, it returns 0."]
    #[doc = ""]
    #[doc = " \\return  the ctmulq ChaCha20+Poly1305 implementation, or 0."]
    pub fn br_poly1305_ctmulq_get() -> br_poly1305_run;
}
#[doc = " \\brief Class type for PRNG implementations."]
#[doc = ""]
#[doc = " A `br_prng_class` instance references the methods implementing a PRNG."]
#[doc = " Constant instances of this structure are defined for each implemented"]
#[doc = " PRNG. Such instances are also called \"vtables\"."]
pub type br_prng_class = br_prng_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_prng_class_ {
    #[doc = " \\brief Size (in bytes) of the context structure appropriate for"]
    #[doc = " running this PRNG."]
    pub context_size: usize,
    #[doc = " \\brief Initialisation method."]
    #[doc = ""]
    #[doc = " The context to initialise is provided as a pointer to its"]
    #[doc = " first field (the vtable pointer); this function sets that"]
    #[doc = " first field to a pointer to the vtable."]
    #[doc = ""]
    #[doc = " The extra parameters depend on the implementation; each"]
    #[doc = " implementation defines what kind of extra parameters it"]
    #[doc = " expects (if any)."]
    #[doc = ""]
    #[doc = " Requirements on the initial seed depend on the implemented"]
    #[doc = " PRNG."]
    #[doc = ""]
    #[doc = " \\param ctx        PRNG context to initialise."]
    #[doc = " \\param params     extra parameters for the PRNG."]
    #[doc = " \\param seed       initial seed."]
    #[doc = " \\param seed_len   initial seed length (in bytes)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_prng_class,
            params: *const cty::c_void,
            seed: *const cty::c_void,
            seed_len: usize,
        ),
    >,
    #[doc = " \\brief Random bytes generation."]
    #[doc = ""]
    #[doc = " This method produces `len` pseudorandom bytes, in the `out`"]
    #[doc = " buffer. The context is updated accordingly."]
    #[doc = ""]
    #[doc = " \\param ctx   PRNG context."]
    #[doc = " \\param out   output buffer."]
    #[doc = " \\param len   number of pseudorandom bytes to produce."]
    pub generate: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut *const br_prng_class, out: *mut cty::c_void, len: usize),
    >,
    #[doc = " \\brief Inject additional seed bytes."]
    #[doc = ""]
    #[doc = " The provided seed bytes are added into the PRNG internal"]
    #[doc = " entropy pool."]
    #[doc = ""]
    #[doc = " \\param ctx        PRNG context."]
    #[doc = " \\param seed       additional seed."]
    #[doc = " \\param seed_len   additional seed length (in bytes)."]
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_prng_class,
            seed: *const cty::c_void,
            seed_len: usize,
        ),
    >,
}
#[doc = " \\brief Context for HMAC_DRBG."]
#[doc = ""]
#[doc = " The context contents are opaque, except the first field, which"]
#[doc = " supports OOP."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_hmac_drbg_context {
    #[doc = " \\brief Pointer to the vtable."]
    #[doc = ""]
    #[doc = " This field is set with the initialisation method/function."]
    pub vtable: *const br_prng_class,
    pub K: [cty::c_uchar; 64usize],
    pub V: [cty::c_uchar; 64usize],
    pub digest_class: *const br_hash_class,
}
extern "C" {
    pub static br_hmac_drbg_vtable: br_prng_class;
}
extern "C" {
    #[doc = " \\brief HMAC_DRBG initialisation."]
    #[doc = ""]
    #[doc = " The context to initialise is provided as a pointer to its first field"]
    #[doc = " (the vtable pointer); this function sets that first field to a"]
    #[doc = " pointer to the vtable."]
    #[doc = ""]
    #[doc = " The `seed` value is what is called, in NIST terminology, the"]
    #[doc = " concatenation of the \"seed\", \"nonce\" and \"personalization string\", in"]
    #[doc = " that order."]
    #[doc = ""]
    #[doc = " The `digest_class` parameter defines the underlying hash function."]
    #[doc = " Formally, the NIST standard specifies that the hash function shall"]
    #[doc = " be only SHA-1 or one of the SHA-2 functions. This implementation also"]
    #[doc = " works with any other implemented hash function (such as MD5), but"]
    #[doc = " this is non-standard and therefore not recommended."]
    #[doc = ""]
    #[doc = " \\param ctx            HMAC_DRBG context to initialise."]
    #[doc = " \\param digest_class   vtable for the underlying hash function."]
    #[doc = " \\param seed           initial seed."]
    #[doc = " \\param seed_len       initial seed length (in bytes)."]
    pub fn br_hmac_drbg_init(
        ctx: *mut br_hmac_drbg_context,
        digest_class: *const br_hash_class,
        seed: *const cty::c_void,
        seed_len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Random bytes generation with HMAC_DRBG."]
    #[doc = ""]
    #[doc = " This method produces `len` pseudorandom bytes, in the `out`"]
    #[doc = " buffer. The context is updated accordingly. Formally, requesting"]
    #[doc = " more than 65536 bytes in one request falls out of specification"]
    #[doc = " limits (but it won't fail)."]
    #[doc = ""]
    #[doc = " \\param ctx   HMAC_DRBG context."]
    #[doc = " \\param out   output buffer."]
    #[doc = " \\param len   number of pseudorandom bytes to produce."]
    pub fn br_hmac_drbg_generate(ctx: *mut br_hmac_drbg_context, out: *mut cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Inject additional seed bytes in HMAC_DRBG."]
    #[doc = ""]
    #[doc = " The provided seed bytes are added into the HMAC_DRBG internal"]
    #[doc = " entropy pool. The process does not _replace_ existing entropy,"]
    #[doc = " thus pushing non-random bytes (i.e. bytes which are known to the"]
    #[doc = " attackers) does not degrade the overall quality of generated bytes."]
    #[doc = ""]
    #[doc = " \\param ctx        HMAC_DRBG context."]
    #[doc = " \\param seed       additional seed."]
    #[doc = " \\param seed_len   additional seed length (in bytes)."]
    pub fn br_hmac_drbg_update(
        ctx: *mut br_hmac_drbg_context,
        seed: *const cty::c_void,
        seed_len: usize,
    );
}
#[doc = " \\brief Type for a provider of entropy seeds."]
#[doc = ""]
#[doc = " A \"seeder\" is a function that is able to obtain random values from"]
#[doc = " some source and inject them as entropy seed in a PRNG. A seeder"]
#[doc = " shall guarantee that the total entropy of the injected seed is large"]
#[doc = " enough to seed a PRNG for purposes of cryptographic key generation"]
#[doc = " (i.e. at least 128 bits)."]
#[doc = ""]
#[doc = " A seeder may report a failure to obtain adequate entropy. Seeders"]
#[doc = " shall endeavour to fix themselves transient errors by trying again;"]
#[doc = " thus, callers may consider reported errors as permanent."]
#[doc = ""]
#[doc = " \\param ctx   PRNG context to seed."]
#[doc = " \\return  1 on success, 0 on error."]
pub type br_prng_seeder =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut *const br_prng_class) -> cty::c_int>;
extern "C" {
    #[doc = " \\brief Get a seeder backed by the operating system or hardware."]
    #[doc = ""]
    #[doc = " Get a seeder that feeds on RNG facilities provided by the current"]
    #[doc = " operating system or hardware. If no such facility is known, then 0"]
    #[doc = " is returned."]
    #[doc = ""]
    #[doc = " If `name` is not `NULL`, then `*name` is set to a symbolic string"]
    #[doc = " that identifies the seeder implementation. If no seeder is returned"]
    #[doc = " and `name` is not `NULL`, then `*name` is set to a pointer to the"]
    #[doc = " constant string `\"none\"`."]
    #[doc = ""]
    #[doc = " \\param name   receiver for seeder name, or `NULL`."]
    #[doc = " \\return  the system seeder, if available, or 0."]
    pub fn br_prng_seeder_system(name: *mut *const cty::c_char) -> br_prng_seeder;
}
#[doc = " \\brief Context for AESCTR_DRBG."]
#[doc = ""]
#[doc = " The context contents are opaque, except the first field, which"]
#[doc = " supports OOP."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_aesctr_drbg_context {
    #[doc = " \\brief Pointer to the vtable."]
    #[doc = ""]
    #[doc = " This field is set with the initialisation method/function."]
    pub vtable: *const br_prng_class,
    pub __bindgen_padding_0: u32,
    pub sk: br_aes_gen_ctr_keys,
    pub cc: u32,
    pub __bindgen_padding_1: u32,
}
extern "C" {
    pub static br_aesctr_drbg_vtable: br_prng_class;
}
extern "C" {
    #[doc = " \\brief AESCTR_DRBG initialisation."]
    #[doc = ""]
    #[doc = " The context to initialise is provided as a pointer to its first field"]
    #[doc = " (the vtable pointer); this function sets that first field to a"]
    #[doc = " pointer to the vtable."]
    #[doc = ""]
    #[doc = " The internal AES key is first set to the all-zero key; then, the"]
    #[doc = " `br_aesctr_drbg_update()` function is called with the provided `seed`."]
    #[doc = " The call is performed even if the seed length (`seed_len`) is zero."]
    #[doc = ""]
    #[doc = " The `aesctr` parameter defines the underlying AES/CTR implementation."]
    #[doc = ""]
    #[doc = " \\param ctx        AESCTR_DRBG context to initialise."]
    #[doc = " \\param aesctr     vtable for the AES/CTR implementation."]
    #[doc = " \\param seed       initial seed (can be `NULL` if `seed_len` is zero)."]
    #[doc = " \\param seed_len   initial seed length (in bytes)."]
    pub fn br_aesctr_drbg_init(
        ctx: *mut br_aesctr_drbg_context,
        aesctr: *const br_block_ctr_class,
        seed: *const cty::c_void,
        seed_len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Random bytes generation with AESCTR_DRBG."]
    #[doc = ""]
    #[doc = " This method produces `len` pseudorandom bytes, in the `out`"]
    #[doc = " buffer. The context is updated accordingly."]
    #[doc = ""]
    #[doc = " \\param ctx   AESCTR_DRBG context."]
    #[doc = " \\param out   output buffer."]
    #[doc = " \\param len   number of pseudorandom bytes to produce."]
    pub fn br_aesctr_drbg_generate(
        ctx: *mut br_aesctr_drbg_context,
        out: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Inject additional seed bytes in AESCTR_DRBG."]
    #[doc = ""]
    #[doc = " The provided seed bytes are added into the AESCTR_DRBG internal"]
    #[doc = " entropy pool. The process does not _replace_ existing entropy,"]
    #[doc = " thus pushing non-random bytes (i.e. bytes which are known to the"]
    #[doc = " attackers) does not degrade the overall quality of generated bytes."]
    #[doc = ""]
    #[doc = " \\param ctx        AESCTR_DRBG context."]
    #[doc = " \\param seed       additional seed."]
    #[doc = " \\param seed_len   additional seed length (in bytes)."]
    pub fn br_aesctr_drbg_update(
        ctx: *mut br_aesctr_drbg_context,
        seed: *const cty::c_void,
        seed_len: usize,
    );
}
#[doc = " \\brief Type for a seed chunk."]
#[doc = ""]
#[doc = " Each chunk may have an arbitrary length, and may be empty (no byte at"]
#[doc = " all). If the chunk length is zero, then the pointer to the chunk data"]
#[doc = " may be `NULL`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_tls_prf_seed_chunk {
    #[doc = " \\brief Pointer to the chunk data."]
    pub data: *const cty::c_void,
    #[doc = " \\brief Chunk length (in bytes)."]
    pub len: usize,
}
extern "C" {
    #[doc = " \\brief PRF implementation for TLS 1.0 and 1.1."]
    #[doc = ""]
    #[doc = " This PRF is the one specified by TLS 1.0 and 1.1. It internally uses"]
    #[doc = " MD5 and SHA-1."]
    #[doc = ""]
    #[doc = " \\param dst          destination buffer."]
    #[doc = " \\param len          output length (in bytes)."]
    #[doc = " \\param secret       secret value (key) for this computation."]
    #[doc = " \\param secret_len   length of \"secret\" (in bytes)."]
    #[doc = " \\param label        PRF label (zero-terminated ASCII string)."]
    #[doc = " \\param seed_num     number of seed chunks."]
    #[doc = " \\param seed         seed chnks for this computation (usually non-secret)."]
    pub fn br_tls10_prf(
        dst: *mut cty::c_void,
        len: usize,
        secret: *const cty::c_void,
        secret_len: usize,
        label: *const cty::c_char,
        seed_num: usize,
        seed: *const br_tls_prf_seed_chunk,
    );
}
extern "C" {
    #[doc = " \\brief PRF implementation for TLS 1.2, with SHA-256."]
    #[doc = ""]
    #[doc = " This PRF is the one specified by TLS 1.2, when the underlying hash"]
    #[doc = " function is SHA-256."]
    #[doc = ""]
    #[doc = " \\param dst          destination buffer."]
    #[doc = " \\param len          output length (in bytes)."]
    #[doc = " \\param secret       secret value (key) for this computation."]
    #[doc = " \\param secret_len   length of \"secret\" (in bytes)."]
    #[doc = " \\param label        PRF label (zero-terminated ASCII string)."]
    #[doc = " \\param seed_num     number of seed chunks."]
    #[doc = " \\param seed         seed chnks for this computation (usually non-secret)."]
    pub fn br_tls12_sha256_prf(
        dst: *mut cty::c_void,
        len: usize,
        secret: *const cty::c_void,
        secret_len: usize,
        label: *const cty::c_char,
        seed_num: usize,
        seed: *const br_tls_prf_seed_chunk,
    );
}
extern "C" {
    #[doc = " \\brief PRF implementation for TLS 1.2, with SHA-384."]
    #[doc = ""]
    #[doc = " This PRF is the one specified by TLS 1.2, when the underlying hash"]
    #[doc = " function is SHA-384."]
    #[doc = ""]
    #[doc = " \\param dst          destination buffer."]
    #[doc = " \\param len          output length (in bytes)."]
    #[doc = " \\param secret       secret value (key) for this computation."]
    #[doc = " \\param secret_len   length of \"secret\" (in bytes)."]
    #[doc = " \\param label        PRF label (zero-terminated ASCII string)."]
    #[doc = " \\param seed_num     number of seed chunks."]
    #[doc = " \\param seed         seed chnks for this computation (usually non-secret)."]
    pub fn br_tls12_sha384_prf(
        dst: *mut cty::c_void,
        len: usize,
        secret: *const cty::c_void,
        secret_len: usize,
        label: *const cty::c_char,
        seed_num: usize,
        seed: *const br_tls_prf_seed_chunk,
    );
}
#[doc = " brief A convenient type name for a PRF implementation."]
#[doc = ""]
#[doc = " \\param dst          destination buffer."]
#[doc = " \\param len          output length (in bytes)."]
#[doc = " \\param secret       secret value (key) for this computation."]
#[doc = " \\param secret_len   length of \"secret\" (in bytes)."]
#[doc = " \\param label        PRF label (zero-terminated ASCII string)."]
#[doc = " \\param seed_num     number of seed chunks."]
#[doc = " \\param seed         seed chnks for this computation (usually non-secret)."]
pub type br_tls_prf_impl = ::core::option::Option<
    unsafe extern "C" fn(
        dst: *mut cty::c_void,
        len: usize,
        secret: *const cty::c_void,
        secret_len: usize,
        label: *const cty::c_char,
        seed_num: usize,
        seed: *const br_tls_prf_seed_chunk,
    ),
>;
#[doc = " \\brief Class type of an AEAD algorithm."]
pub type br_aead_class = br_aead_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_aead_class_ {
    #[doc = " \\brief Size (in bytes) of authentication tags created by"]
    #[doc = " this AEAD algorithm."]
    pub tag_size: usize,
    #[doc = " \\brief Reset an AEAD context."]
    #[doc = ""]
    #[doc = " This function resets an already initialised AEAD context for"]
    #[doc = " a new computation run. Implementations and keys are"]
    #[doc = " conserved. This function can be called at any time; it"]
    #[doc = " cancels any ongoing AEAD computation that uses the provided"]
    #[doc = " context structure."]
    #[doc = ""]
    #[doc = " The provided IV is a _nonce_. Each AEAD algorithm has its"]
    #[doc = " own requirements on IV size and contents; for most of them,"]
    #[doc = " it is crucial to security that each nonce value is used"]
    #[doc = " only once for a given secret key."]
    #[doc = ""]
    #[doc = " \\param cc    AEAD context structure."]
    #[doc = " \\param iv    AEAD nonce to use."]
    #[doc = " \\param len   AEAD nonce length (in bytes)."]
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(cc: *mut *const br_aead_class, iv: *const cty::c_void, len: usize),
    >,
    #[doc = " \\brief Inject additional authenticated data."]
    #[doc = ""]
    #[doc = " The provided data is injected into a running AEAD"]
    #[doc = " computation. Additional data must be injected _before_ the"]
    #[doc = " call to `flip()`. Additional data can be injected in several"]
    #[doc = " chunks of arbitrary length."]
    #[doc = ""]
    #[doc = " \\param cc     AEAD context structure."]
    #[doc = " \\param data   pointer to additional authenticated data."]
    #[doc = " \\param len    length of additional authenticated data (in bytes)."]
    pub aad_inject: ::core::option::Option<
        unsafe extern "C" fn(cc: *mut *const br_aead_class, data: *const cty::c_void, len: usize),
    >,
    #[doc = " \\brief Finish injection of additional authenticated data."]
    #[doc = ""]
    #[doc = " This function MUST be called before beginning the actual"]
    #[doc = " encryption or decryption (with `run()`), even if no"]
    #[doc = " additional authenticated data was injected. No additional"]
    #[doc = " authenticated data may be injected after this function call."]
    #[doc = ""]
    #[doc = " \\param cc   AEAD context structure."]
    pub flip: ::core::option::Option<unsafe extern "C" fn(cc: *mut *const br_aead_class)>,
    #[doc = " \\brief Encrypt or decrypt some data."]
    #[doc = ""]
    #[doc = " Data encryption or decryption can be done after `flip()` has"]
    #[doc = " been called on the context. If `encrypt` is non-zero, then"]
    #[doc = " the provided data shall be plaintext, and it is encrypted in"]
    #[doc = " place. Otherwise, the data shall be ciphertext, and it is"]
    #[doc = " decrypted in place."]
    #[doc = ""]
    #[doc = " Data may be provided in several chunks of arbitrary length."]
    #[doc = ""]
    #[doc = " \\param cc        AEAD context structure."]
    #[doc = " \\param encrypt   non-zero for encryption, zero for decryption."]
    #[doc = " \\param data      data to encrypt or decrypt."]
    #[doc = " \\param len       data length (in bytes)."]
    pub run: ::core::option::Option<
        unsafe extern "C" fn(
            cc: *mut *const br_aead_class,
            encrypt: cty::c_int,
            data: *mut cty::c_void,
            len: usize,
        ),
    >,
    #[doc = " \\brief Compute authentication tag."]
    #[doc = ""]
    #[doc = " Compute the AEAD authentication tag. The tag length depends"]
    #[doc = " on the AEAD algorithm; it is written in the provided `tag`"]
    #[doc = " buffer. This call terminates the AEAD run: no data may be"]
    #[doc = " processed with that AEAD context afterwards, until `reset()`"]
    #[doc = " is called to initiate a new AEAD run."]
    #[doc = ""]
    #[doc = " The tag value must normally be sent along with the encrypted"]
    #[doc = " data. When decrypting, the tag value must be recomputed and"]
    #[doc = " compared with the received tag: if the two tag values differ,"]
    #[doc = " then either the tag or the encrypted data was altered in"]
    #[doc = " transit. As an alternative to this function, the"]
    #[doc = " `check_tag()` function may be used to compute and check the"]
    #[doc = " tag value."]
    #[doc = ""]
    #[doc = " Tag length depends on the AEAD algorithm."]
    #[doc = ""]
    #[doc = " \\param cc    AEAD context structure."]
    #[doc = " \\param tag   destination buffer for the tag."]
    pub get_tag: ::core::option::Option<
        unsafe extern "C" fn(cc: *mut *const br_aead_class, tag: *mut cty::c_void),
    >,
    #[doc = " \\brief Compute and check authentication tag."]
    #[doc = ""]
    #[doc = " This function is an alternative to `get_tag()`, and is"]
    #[doc = " normally used on the receiving end (i.e. when decrypting"]
    #[doc = " messages). The tag value is recomputed and compared with the"]
    #[doc = " provided tag value. If they match, 1 is returned; on"]
    #[doc = " mismatch, 0 is returned. A returned value of 0 means that the"]
    #[doc = " data or the tag was altered in transit, normally leading to"]
    #[doc = " wholesale rejection of the complete message."]
    #[doc = ""]
    #[doc = " Tag length depends on the AEAD algorithm."]
    #[doc = ""]
    #[doc = " \\param cc    AEAD context structure."]
    #[doc = " \\param tag   tag value to compare with."]
    #[doc = " \\return  1 on success (exact match of tag value), 0 otherwise."]
    pub check_tag: ::core::option::Option<
        unsafe extern "C" fn(cc: *mut *const br_aead_class, tag: *const cty::c_void) -> u32,
    >,
    #[doc = " \\brief Compute authentication tag (with truncation)."]
    #[doc = ""]
    #[doc = " This function is similar to `get_tag()`, except that the tag"]
    #[doc = " length is provided. Some AEAD algorithms allow several tag"]
    #[doc = " lengths, usually by truncating the normal tag. Shorter tags"]
    #[doc = " mechanically increase success probability of forgeries."]
    #[doc = " The range of allowed tag lengths depends on the algorithm."]
    #[doc = ""]
    #[doc = " \\param cc    AEAD context structure."]
    #[doc = " \\param tag   destination buffer for the tag."]
    #[doc = " \\param len   tag length (in bytes)."]
    pub get_tag_trunc: ::core::option::Option<
        unsafe extern "C" fn(cc: *mut *const br_aead_class, tag: *mut cty::c_void, len: usize),
    >,
    #[doc = " \\brief Compute and check authentication tag (with truncation)."]
    #[doc = ""]
    #[doc = " This function is similar to `check_tag()` except that it"]
    #[doc = " works over an explicit tag length. See `get_tag()` for a"]
    #[doc = " discussion of explicit tag lengths; the range of allowed tag"]
    #[doc = " lengths depends on the algorithm."]
    #[doc = ""]
    #[doc = " \\param cc    AEAD context structure."]
    #[doc = " \\param tag   tag value to compare with."]
    #[doc = " \\param len   tag length (in bytes)."]
    #[doc = " \\return  1 on success (exact match of tag value), 0 otherwise."]
    pub check_tag_trunc: ::core::option::Option<
        unsafe extern "C" fn(
            cc: *mut *const br_aead_class,
            tag: *const cty::c_void,
            len: usize,
        ) -> u32,
    >,
}
#[doc = " \\brief Context structure for GCM."]
#[doc = ""]
#[doc = " GCM is an AEAD mode that combines a block cipher in CTR mode with a"]
#[doc = " MAC based on GHASH, to provide authenticated encryption:"]
#[doc = ""]
#[doc = "   - Any block cipher with 16-byte blocks can be used with GCM."]
#[doc = ""]
#[doc = "   - The nonce can have any length, from 0 up to 2^64-1 bits; however,"]
#[doc = "     96-bit nonces (12 bytes) are recommended (nonces with a length"]
#[doc = "     distinct from 12 bytes are internally hashed, which risks reusing"]
#[doc = "     nonce value with a small but not always negligible probability)."]
#[doc = ""]
#[doc = "   - Additional authenticated data may have length up to 2^64-1 bits."]
#[doc = ""]
#[doc = "   - Message length may range up to 2^39-256 bits at most."]
#[doc = ""]
#[doc = "   - The authentication tag has length 16 bytes."]
#[doc = ""]
#[doc = " The GCM initialisation function receives as parameter an"]
#[doc = " _initialised_ block cipher implementation context, with the secret"]
#[doc = " key already set. A pointer to that context will be kept within the"]
#[doc = " GCM context structure. It is up to the caller to allocate and"]
#[doc = " initialise that block cipher context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_gcm_context {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_aead_class,
    pub bctx: *mut *const br_block_ctr_class,
    pub gh: br_ghash,
    pub h: [cty::c_uchar; 16usize],
    pub j0_1: [cty::c_uchar; 12usize],
    pub buf: [cty::c_uchar; 16usize],
    pub y: [cty::c_uchar; 16usize],
    pub j0_2: u32,
    pub jc: u32,
    pub count_aad: u64,
    pub count_ctr: u64,
}
extern "C" {
    #[doc = " \\brief Initialize a GCM context."]
    #[doc = ""]
    #[doc = " A block cipher implementation, with its initialised context structure,"]
    #[doc = " is provided. The block cipher MUST use 16-byte blocks in CTR mode,"]
    #[doc = " and its secret key MUST have been already set in the provided context."]
    #[doc = " A GHASH implementation must also be provided. The parameters are linked"]
    #[doc = " in the GCM context."]
    #[doc = ""]
    #[doc = " After this function has been called, the `br_gcm_reset()` function must"]
    #[doc = " be called, to provide the IV for GCM computation."]
    #[doc = ""]
    #[doc = " \\param ctx    GCM context structure."]
    #[doc = " \\param bctx   block cipher context (already initialised with secret key)."]
    #[doc = " \\param gh     GHASH implementation."]
    pub fn br_gcm_init(
        ctx: *mut br_gcm_context,
        bctx: *mut *const br_block_ctr_class,
        gh: br_ghash,
    );
}
extern "C" {
    #[doc = " \\brief Reset a GCM context."]
    #[doc = ""]
    #[doc = " This function resets an already initialised GCM context for a new"]
    #[doc = " computation run. Implementations and keys are conserved. This function"]
    #[doc = " can be called at any time; it cancels any ongoing GCM computation that"]
    #[doc = " uses the provided context structure."]
    #[doc = ""]
    #[doc = " The provided IV is a _nonce_. It is critical to GCM security that IV"]
    #[doc = " values are not repeated for the same encryption key. IV can have"]
    #[doc = " arbitrary length (up to 2^64-1 bits), but the \"normal\" length is"]
    #[doc = " 96 bits (12 bytes)."]
    #[doc = ""]
    #[doc = " \\param ctx   GCM context structure."]
    #[doc = " \\param iv    GCM nonce to use."]
    #[doc = " \\param len   GCM nonce length (in bytes)."]
    pub fn br_gcm_reset(ctx: *mut br_gcm_context, iv: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Inject additional authenticated data into GCM."]
    #[doc = ""]
    #[doc = " The provided data is injected into a running GCM computation. Additional"]
    #[doc = " data must be injected _before_ the call to `br_gcm_flip()`."]
    #[doc = " Additional data can be injected in several chunks of arbitrary length;"]
    #[doc = " the maximum total size of additional authenticated data is 2^64-1"]
    #[doc = " bits."]
    #[doc = ""]
    #[doc = " \\param ctx    GCM context structure."]
    #[doc = " \\param data   pointer to additional authenticated data."]
    #[doc = " \\param len    length of additional authenticated data (in bytes)."]
    pub fn br_gcm_aad_inject(ctx: *mut br_gcm_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Finish injection of additional authenticated data into GCM."]
    #[doc = ""]
    #[doc = " This function MUST be called before beginning the actual encryption"]
    #[doc = " or decryption (with `br_gcm_run()`), even if no additional authenticated"]
    #[doc = " data was injected. No additional authenticated data may be injected"]
    #[doc = " after this function call."]
    #[doc = ""]
    #[doc = " \\param ctx   GCM context structure."]
    pub fn br_gcm_flip(ctx: *mut br_gcm_context);
}
extern "C" {
    #[doc = " \\brief Encrypt or decrypt some data with GCM."]
    #[doc = ""]
    #[doc = " Data encryption or decryption can be done after `br_gcm_flip()`"]
    #[doc = " has been called on the context. If `encrypt` is non-zero, then the"]
    #[doc = " provided data shall be plaintext, and it is encrypted in place."]
    #[doc = " Otherwise, the data shall be ciphertext, and it is decrypted in place."]
    #[doc = ""]
    #[doc = " Data may be provided in several chunks of arbitrary length. The maximum"]
    #[doc = " total length for data is 2^39-256 bits, i.e. about 65 gigabytes."]
    #[doc = ""]
    #[doc = " \\param ctx       GCM context structure."]
    #[doc = " \\param encrypt   non-zero for encryption, zero for decryption."]
    #[doc = " \\param data      data to encrypt or decrypt."]
    #[doc = " \\param len       data length (in bytes)."]
    pub fn br_gcm_run(
        ctx: *mut br_gcm_context,
        encrypt: cty::c_int,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Compute GCM authentication tag."]
    #[doc = ""]
    #[doc = " Compute the GCM authentication tag. The tag is a 16-byte value which"]
    #[doc = " is written in the provided `tag` buffer. This call terminates the"]
    #[doc = " GCM run: no data may be processed with that GCM context afterwards,"]
    #[doc = " until `br_gcm_reset()` is called to initiate a new GCM run."]
    #[doc = ""]
    #[doc = " The tag value must normally be sent along with the encrypted data."]
    #[doc = " When decrypting, the tag value must be recomputed and compared with"]
    #[doc = " the received tag: if the two tag values differ, then either the tag"]
    #[doc = " or the encrypted data was altered in transit. As an alternative to"]
    #[doc = " this function, the `br_gcm_check_tag()` function can be used to"]
    #[doc = " compute and check the tag value."]
    #[doc = ""]
    #[doc = " \\param ctx   GCM context structure."]
    #[doc = " \\param tag   destination buffer for the tag (16 bytes)."]
    pub fn br_gcm_get_tag(ctx: *mut br_gcm_context, tag: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Compute and check GCM authentication tag."]
    #[doc = ""]
    #[doc = " This function is an alternative to `br_gcm_get_tag()`, normally used"]
    #[doc = " on the receiving end (i.e. when decrypting value). The tag value is"]
    #[doc = " recomputed and compared with the provided tag value. If they match, 1"]
    #[doc = " is returned; on mismatch, 0 is returned. A returned value of 0 means"]
    #[doc = " that the data or the tag was altered in transit, normally leading to"]
    #[doc = " wholesale rejection of the complete message."]
    #[doc = ""]
    #[doc = " \\param ctx   GCM context structure."]
    #[doc = " \\param tag   tag value to compare with (16 bytes)."]
    #[doc = " \\return  1 on success (exact match of tag value), 0 otherwise."]
    pub fn br_gcm_check_tag(ctx: *mut br_gcm_context, tag: *const cty::c_void) -> u32;
}
extern "C" {
    #[doc = " \\brief Compute GCM authentication tag (with truncation)."]
    #[doc = ""]
    #[doc = " This function is similar to `br_gcm_get_tag()`, except that it allows"]
    #[doc = " the tag to be truncated to a smaller length. The intended tag length"]
    #[doc = " is provided as `len` (in bytes); it MUST be no more than 16, but"]
    #[doc = " it may be smaller. Note that decreasing tag length mechanically makes"]
    #[doc = " forgeries easier; NIST SP 800-38D specifies that the tag length shall"]
    #[doc = " lie between 12 and 16 bytes (inclusive), but may be truncated down to"]
    #[doc = " 4 or 8 bytes, for specific applications that can tolerate it. It must"]
    #[doc = " also be noted that successful forgeries leak information on the"]
    #[doc = " authentication key, making subsequent forgeries easier. Therefore,"]
    #[doc = " tag truncation, and in particular truncation to sizes lower than 12"]
    #[doc = " bytes, shall be envisioned only with great care."]
    #[doc = ""]
    #[doc = " The tag is written in the provided `tag` buffer. This call terminates"]
    #[doc = " the GCM run: no data may be processed with that GCM context"]
    #[doc = " afterwards, until `br_gcm_reset()` is called to initiate a new GCM"]
    #[doc = " run."]
    #[doc = ""]
    #[doc = " The tag value must normally be sent along with the encrypted data."]
    #[doc = " When decrypting, the tag value must be recomputed and compared with"]
    #[doc = " the received tag: if the two tag values differ, then either the tag"]
    #[doc = " or the encrypted data was altered in transit. As an alternative to"]
    #[doc = " this function, the `br_gcm_check_tag_trunc()` function can be used to"]
    #[doc = " compute and check the tag value."]
    #[doc = ""]
    #[doc = " \\param ctx   GCM context structure."]
    #[doc = " \\param tag   destination buffer for the tag."]
    #[doc = " \\param len   tag length (16 bytes or less)."]
    pub fn br_gcm_get_tag_trunc(ctx: *mut br_gcm_context, tag: *mut cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Compute and check GCM authentication tag (with truncation)."]
    #[doc = ""]
    #[doc = " This function is an alternative to `br_gcm_get_tag_trunc()`, normally used"]
    #[doc = " on the receiving end (i.e. when decrypting value). The tag value is"]
    #[doc = " recomputed and compared with the provided tag value. If they match, 1"]
    #[doc = " is returned; on mismatch, 0 is returned. A returned value of 0 means"]
    #[doc = " that the data or the tag was altered in transit, normally leading to"]
    #[doc = " wholesale rejection of the complete message."]
    #[doc = ""]
    #[doc = " Tag length MUST be 16 bytes or less. The normal GCM tag length is 16"]
    #[doc = " bytes. See `br_check_tag_trunc()` for some discussion on the potential"]
    #[doc = " perils of truncating authentication tags."]
    #[doc = ""]
    #[doc = " \\param ctx   GCM context structure."]
    #[doc = " \\param tag   tag value to compare with."]
    #[doc = " \\param len   tag length (in bytes)."]
    #[doc = " \\return  1 on success (exact match of tag value), 0 otherwise."]
    pub fn br_gcm_check_tag_trunc(
        ctx: *mut br_gcm_context,
        tag: *const cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    pub static br_gcm_vtable: br_aead_class;
}
#[doc = " \\brief Context structure for EAX."]
#[doc = ""]
#[doc = " EAX is an AEAD mode that combines a block cipher in CTR mode with"]
#[doc = " CBC-MAC using the same block cipher and the same key, to provide"]
#[doc = " authenticated encryption:"]
#[doc = ""]
#[doc = "   - Any block cipher with 16-byte blocks can be used with EAX"]
#[doc = "     (technically, other block sizes are defined as well, but this"]
#[doc = "     is not implemented by these functions; shorter blocks also"]
#[doc = "     imply numerous security issues)."]
#[doc = ""]
#[doc = "   - The nonce can have any length, as long as nonce values are"]
#[doc = "     not reused (thus, if nonces are randomly selected, the nonce"]
#[doc = "     size should be such that reuse probability is negligible)."]
#[doc = ""]
#[doc = "   - Additional authenticated data length is unlimited."]
#[doc = ""]
#[doc = "   - Message length is unlimited."]
#[doc = ""]
#[doc = "   - The authentication tag has length 16 bytes."]
#[doc = ""]
#[doc = " The EAX initialisation function receives as parameter an"]
#[doc = " _initialised_ block cipher implementation context, with the secret"]
#[doc = " key already set. A pointer to that context will be kept within the"]
#[doc = " EAX context structure. It is up to the caller to allocate and"]
#[doc = " initialise that block cipher context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_eax_context {
    #[doc = " \\brief Pointer to vtable for this context."]
    pub vtable: *const br_aead_class,
    pub bctx: *mut *const br_block_ctrcbc_class,
    pub L2: [cty::c_uchar; 16usize],
    pub L4: [cty::c_uchar; 16usize],
    pub nonce: [cty::c_uchar; 16usize],
    pub head: [cty::c_uchar; 16usize],
    pub ctr: [cty::c_uchar; 16usize],
    pub cbcmac: [cty::c_uchar; 16usize],
    pub buf: [cty::c_uchar; 16usize],
    pub ptr: usize,
}
#[doc = " \\brief EAX captured state."]
#[doc = ""]
#[doc = " Some internal values computed by EAX may be captured at various"]
#[doc = " points, and reused for another EAX run with the same secret key,"]
#[doc = " for lower per-message overhead. Captured values do not depend on"]
#[doc = " the nonce."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_eax_state {
    pub st: [[cty::c_uchar; 16usize]; 3usize],
}
extern "C" {
    #[doc = " \\brief Initialize an EAX context."]
    #[doc = ""]
    #[doc = " A block cipher implementation, with its initialised context"]
    #[doc = " structure, is provided. The block cipher MUST use 16-byte blocks in"]
    #[doc = " CTR + CBC-MAC mode, and its secret key MUST have been already set in"]
    #[doc = " the provided context. The parameters are linked in the EAX context."]
    #[doc = ""]
    #[doc = " After this function has been called, the `br_eax_reset()` function must"]
    #[doc = " be called, to provide the nonce for EAX computation."]
    #[doc = ""]
    #[doc = " \\param ctx    EAX context structure."]
    #[doc = " \\param bctx   block cipher context (already initialised with secret key)."]
    pub fn br_eax_init(ctx: *mut br_eax_context, bctx: *mut *const br_block_ctrcbc_class);
}
extern "C" {
    #[doc = " \\brief Capture pre-AAD state."]
    #[doc = ""]
    #[doc = " This function precomputes key-dependent data, and stores it in the"]
    #[doc = " provided `st` structure. This structure should then be used with"]
    #[doc = " `br_eax_reset_pre_aad()`, or updated with `br_eax_get_aad_mac()`"]
    #[doc = " and then used with `br_eax_reset_post_aad()`."]
    #[doc = ""]
    #[doc = " The EAX context structure is unmodified by this call."]
    #[doc = ""]
    #[doc = " \\param ctx   EAX context structure."]
    #[doc = " \\param st    recipient for captured state."]
    pub fn br_eax_capture(ctx: *const br_eax_context, st: *mut br_eax_state);
}
extern "C" {
    #[doc = " \\brief Reset an EAX context."]
    #[doc = ""]
    #[doc = " This function resets an already initialised EAX context for a new"]
    #[doc = " computation run. Implementations and keys are conserved. This function"]
    #[doc = " can be called at any time; it cancels any ongoing EAX computation that"]
    #[doc = " uses the provided context structure."]
    #[doc = ""]
    #[doc = " It is critical to EAX security that nonce values are not repeated for"]
    #[doc = " the same encryption key. Nonces can have arbitrary length. If nonces"]
    #[doc = " are randomly generated, then a nonce length of at least 128 bits (16"]
    #[doc = " bytes) is recommended, to make nonce reuse probability sufficiently"]
    #[doc = " low."]
    #[doc = ""]
    #[doc = " \\param ctx     EAX context structure."]
    #[doc = " \\param nonce   EAX nonce to use."]
    #[doc = " \\param len     EAX nonce length (in bytes)."]
    pub fn br_eax_reset(ctx: *mut br_eax_context, nonce: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Reset an EAX context with a pre-AAD captured state."]
    #[doc = ""]
    #[doc = " This function is an alternative to `br_eax_reset()`, that reuses a"]
    #[doc = " previously captured state structure for lower per-message overhead."]
    #[doc = " The state should have been populated with `br_eax_capture_state()`"]
    #[doc = " but not updated with `br_eax_get_aad_mac()`."]
    #[doc = ""]
    #[doc = " After this function is called, additional authenticated data MUST"]
    #[doc = " be injected. At least one byte of additional authenticated data"]
    #[doc = " MUST be provided with `br_eax_aad_inject()`; computation result will"]
    #[doc = " be incorrect if `br_eax_flip()` is called right away."]
    #[doc = ""]
    #[doc = " After injection of the AAD and call to `br_eax_flip()`, at least"]
    #[doc = " one message byte must be provided. Empty messages are not supported"]
    #[doc = " with this reset mode."]
    #[doc = ""]
    #[doc = " \\param ctx     EAX context structure."]
    #[doc = " \\param st      pre-AAD captured state."]
    #[doc = " \\param nonce   EAX nonce to use."]
    #[doc = " \\param len     EAX nonce length (in bytes)."]
    pub fn br_eax_reset_pre_aad(
        ctx: *mut br_eax_context,
        st: *const br_eax_state,
        nonce: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Reset an EAX context with a post-AAD captured state."]
    #[doc = ""]
    #[doc = " This function is an alternative to `br_eax_reset()`, that reuses a"]
    #[doc = " previously captured state structure for lower per-message overhead."]
    #[doc = " The state should have been populated with `br_eax_capture_state()`"]
    #[doc = " and then updated with `br_eax_get_aad_mac()`."]
    #[doc = ""]
    #[doc = " After this function is called, message data MUST be injected. The"]
    #[doc = " `br_eax_flip()` function MUST NOT be called. At least one byte of"]
    #[doc = " message data MUST be provided with `br_eax_run()`; empty messages"]
    #[doc = " are not supported with this reset mode."]
    #[doc = ""]
    #[doc = " \\param ctx     EAX context structure."]
    #[doc = " \\param st      post-AAD captured state."]
    #[doc = " \\param nonce   EAX nonce to use."]
    #[doc = " \\param len     EAX nonce length (in bytes)."]
    pub fn br_eax_reset_post_aad(
        ctx: *mut br_eax_context,
        st: *const br_eax_state,
        nonce: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Inject additional authenticated data into EAX."]
    #[doc = ""]
    #[doc = " The provided data is injected into a running EAX computation. Additional"]
    #[doc = " data must be injected _before_ the call to `br_eax_flip()`."]
    #[doc = " Additional data can be injected in several chunks of arbitrary length;"]
    #[doc = " the total amount of additional authenticated data is unlimited."]
    #[doc = ""]
    #[doc = " \\param ctx    EAX context structure."]
    #[doc = " \\param data   pointer to additional authenticated data."]
    #[doc = " \\param len    length of additional authenticated data (in bytes)."]
    pub fn br_eax_aad_inject(ctx: *mut br_eax_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Finish injection of additional authenticated data into EAX."]
    #[doc = ""]
    #[doc = " This function MUST be called before beginning the actual encryption"]
    #[doc = " or decryption (with `br_eax_run()`), even if no additional authenticated"]
    #[doc = " data was injected. No additional authenticated data may be injected"]
    #[doc = " after this function call."]
    #[doc = ""]
    #[doc = " \\param ctx   EAX context structure."]
    pub fn br_eax_flip(ctx: *mut br_eax_context);
}
extern "C" {
    #[doc = " \\brief Encrypt or decrypt some data with EAX."]
    #[doc = ""]
    #[doc = " Data encryption or decryption can be done after `br_eax_flip()`"]
    #[doc = " has been called on the context. If `encrypt` is non-zero, then the"]
    #[doc = " provided data shall be plaintext, and it is encrypted in place."]
    #[doc = " Otherwise, the data shall be ciphertext, and it is decrypted in place."]
    #[doc = ""]
    #[doc = " Data may be provided in several chunks of arbitrary length."]
    #[doc = ""]
    #[doc = " \\param ctx       EAX context structure."]
    #[doc = " \\param encrypt   non-zero for encryption, zero for decryption."]
    #[doc = " \\param data      data to encrypt or decrypt."]
    #[doc = " \\param len       data length (in bytes)."]
    pub fn br_eax_run(
        ctx: *mut br_eax_context,
        encrypt: cty::c_int,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Compute EAX authentication tag."]
    #[doc = ""]
    #[doc = " Compute the EAX authentication tag. The tag is a 16-byte value which"]
    #[doc = " is written in the provided `tag` buffer. This call terminates the"]
    #[doc = " EAX run: no data may be processed with that EAX context afterwards,"]
    #[doc = " until `br_eax_reset()` is called to initiate a new EAX run."]
    #[doc = ""]
    #[doc = " The tag value must normally be sent along with the encrypted data."]
    #[doc = " When decrypting, the tag value must be recomputed and compared with"]
    #[doc = " the received tag: if the two tag values differ, then either the tag"]
    #[doc = " or the encrypted data was altered in transit. As an alternative to"]
    #[doc = " this function, the `br_eax_check_tag()` function can be used to"]
    #[doc = " compute and check the tag value."]
    #[doc = ""]
    #[doc = " \\param ctx   EAX context structure."]
    #[doc = " \\param tag   destination buffer for the tag (16 bytes)."]
    pub fn br_eax_get_tag(ctx: *mut br_eax_context, tag: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Compute and check EAX authentication tag."]
    #[doc = ""]
    #[doc = " This function is an alternative to `br_eax_get_tag()`, normally used"]
    #[doc = " on the receiving end (i.e. when decrypting value). The tag value is"]
    #[doc = " recomputed and compared with the provided tag value. If they match, 1"]
    #[doc = " is returned; on mismatch, 0 is returned. A returned value of 0 means"]
    #[doc = " that the data or the tag was altered in transit, normally leading to"]
    #[doc = " wholesale rejection of the complete message."]
    #[doc = ""]
    #[doc = " \\param ctx   EAX context structure."]
    #[doc = " \\param tag   tag value to compare with (16 bytes)."]
    #[doc = " \\return  1 on success (exact match of tag value), 0 otherwise."]
    pub fn br_eax_check_tag(ctx: *mut br_eax_context, tag: *const cty::c_void) -> u32;
}
extern "C" {
    #[doc = " \\brief Compute EAX authentication tag (with truncation)."]
    #[doc = ""]
    #[doc = " This function is similar to `br_eax_get_tag()`, except that it allows"]
    #[doc = " the tag to be truncated to a smaller length. The intended tag length"]
    #[doc = " is provided as `len` (in bytes); it MUST be no more than 16, but"]
    #[doc = " it may be smaller. Note that decreasing tag length mechanically makes"]
    #[doc = " forgeries easier; NIST SP 800-38D specifies that the tag length shall"]
    #[doc = " lie between 12 and 16 bytes (inclusive), but may be truncated down to"]
    #[doc = " 4 or 8 bytes, for specific applications that can tolerate it. It must"]
    #[doc = " also be noted that successful forgeries leak information on the"]
    #[doc = " authentication key, making subsequent forgeries easier. Therefore,"]
    #[doc = " tag truncation, and in particular truncation to sizes lower than 12"]
    #[doc = " bytes, shall be envisioned only with great care."]
    #[doc = ""]
    #[doc = " The tag is written in the provided `tag` buffer. This call terminates"]
    #[doc = " the EAX run: no data may be processed with that EAX context"]
    #[doc = " afterwards, until `br_eax_reset()` is called to initiate a new EAX"]
    #[doc = " run."]
    #[doc = ""]
    #[doc = " The tag value must normally be sent along with the encrypted data."]
    #[doc = " When decrypting, the tag value must be recomputed and compared with"]
    #[doc = " the received tag: if the two tag values differ, then either the tag"]
    #[doc = " or the encrypted data was altered in transit. As an alternative to"]
    #[doc = " this function, the `br_eax_check_tag_trunc()` function can be used to"]
    #[doc = " compute and check the tag value."]
    #[doc = ""]
    #[doc = " \\param ctx   EAX context structure."]
    #[doc = " \\param tag   destination buffer for the tag."]
    #[doc = " \\param len   tag length (16 bytes or less)."]
    pub fn br_eax_get_tag_trunc(ctx: *mut br_eax_context, tag: *mut cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Compute and check EAX authentication tag (with truncation)."]
    #[doc = ""]
    #[doc = " This function is an alternative to `br_eax_get_tag_trunc()`, normally used"]
    #[doc = " on the receiving end (i.e. when decrypting value). The tag value is"]
    #[doc = " recomputed and compared with the provided tag value. If they match, 1"]
    #[doc = " is returned; on mismatch, 0 is returned. A returned value of 0 means"]
    #[doc = " that the data or the tag was altered in transit, normally leading to"]
    #[doc = " wholesale rejection of the complete message."]
    #[doc = ""]
    #[doc = " Tag length MUST be 16 bytes or less. The normal EAX tag length is 16"]
    #[doc = " bytes. See `br_check_tag_trunc()` for some discussion on the potential"]
    #[doc = " perils of truncating authentication tags."]
    #[doc = ""]
    #[doc = " \\param ctx   EAX context structure."]
    #[doc = " \\param tag   tag value to compare with."]
    #[doc = " \\param len   tag length (in bytes)."]
    #[doc = " \\return  1 on success (exact match of tag value), 0 otherwise."]
    pub fn br_eax_check_tag_trunc(
        ctx: *mut br_eax_context,
        tag: *const cty::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    pub static br_eax_vtable: br_aead_class;
}
#[doc = " \\brief Context structure for CCM."]
#[doc = ""]
#[doc = " CCM is an AEAD mode that combines a block cipher in CTR mode with"]
#[doc = " CBC-MAC using the same block cipher and the same key, to provide"]
#[doc = " authenticated encryption:"]
#[doc = ""]
#[doc = "   - Any block cipher with 16-byte blocks can be used with CCM"]
#[doc = "     (technically, other block sizes are defined as well, but this"]
#[doc = "     is not implemented by these functions; shorter blocks also"]
#[doc = "     imply numerous security issues)."]
#[doc = ""]
#[doc = "   - The authentication tag length, and plaintext length, MUST be"]
#[doc = "     known when starting processing data. Plaintext and ciphertext"]
#[doc = "     can still be provided by chunks, but the total size must match"]
#[doc = "     the value provided upon initialisation."]
#[doc = ""]
#[doc = "   - The nonce length is constrained between 7 and 13 bytes (inclusive)."]
#[doc = "     Furthermore, the plaintext length, when encoded, must fit over"]
#[doc = "     15-nonceLen bytes; thus, if the nonce has length 13 bytes, then"]
#[doc = "     the plaintext length cannot exceed 65535 bytes."]
#[doc = ""]
#[doc = "   - Additional authenticated data length is practically unlimited"]
#[doc = "     (formal limit is at 2^64 bytes)."]
#[doc = ""]
#[doc = "   - The authentication tag has length 4 to 16 bytes (even values only)."]
#[doc = ""]
#[doc = " The CCM initialisation function receives as parameter an"]
#[doc = " _initialised_ block cipher implementation context, with the secret"]
#[doc = " key already set. A pointer to that context will be kept within the"]
#[doc = " CCM context structure. It is up to the caller to allocate and"]
#[doc = " initialise that block cipher context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ccm_context {
    pub bctx: *mut *const br_block_ctrcbc_class,
    pub ctr: [cty::c_uchar; 16usize],
    pub cbcmac: [cty::c_uchar; 16usize],
    pub tagmask: [cty::c_uchar; 16usize],
    pub buf: [cty::c_uchar; 16usize],
    pub ptr: usize,
    pub tag_len: usize,
}
extern "C" {
    #[doc = " \\brief Initialize a CCM context."]
    #[doc = ""]
    #[doc = " A block cipher implementation, with its initialised context"]
    #[doc = " structure, is provided. The block cipher MUST use 16-byte blocks in"]
    #[doc = " CTR + CBC-MAC mode, and its secret key MUST have been already set in"]
    #[doc = " the provided context. The parameters are linked in the CCM context."]
    #[doc = ""]
    #[doc = " After this function has been called, the `br_ccm_reset()` function must"]
    #[doc = " be called, to provide the nonce for CCM computation."]
    #[doc = ""]
    #[doc = " \\param ctx    CCM context structure."]
    #[doc = " \\param bctx   block cipher context (already initialised with secret key)."]
    pub fn br_ccm_init(ctx: *mut br_ccm_context, bctx: *mut *const br_block_ctrcbc_class);
}
extern "C" {
    #[doc = " \\brief Reset a CCM context."]
    #[doc = ""]
    #[doc = " This function resets an already initialised CCM context for a new"]
    #[doc = " computation run. Implementations and keys are conserved. This function"]
    #[doc = " can be called at any time; it cancels any ongoing CCM computation that"]
    #[doc = " uses the provided context structure."]
    #[doc = ""]
    #[doc = " The `aad_len` parameter contains the total length, in bytes, of the"]
    #[doc = " additional authenticated data. It may be zero. That length MUST be"]
    #[doc = " exact."]
    #[doc = ""]
    #[doc = " The `data_len` parameter contains the total length, in bytes, of the"]
    #[doc = " data that will be injected (plaintext or ciphertext). That length MUST"]
    #[doc = " be exact. Moreover, that length MUST be less than 2^(8*(15-nonce_len))."]
    #[doc = ""]
    #[doc = " The nonce length (`nonce_len`), in bytes, must be in the 7..13 range"]
    #[doc = " (inclusive)."]
    #[doc = ""]
    #[doc = " The tag length (`tag_len`), in bytes, must be in the 4..16 range, and"]
    #[doc = " be an even integer. Short tags mechanically allow for higher forgery"]
    #[doc = " probabilities; hence, tag sizes smaller than 12 bytes shall be used only"]
    #[doc = " with care."]
    #[doc = ""]
    #[doc = " It is critical to CCM security that nonce values are not repeated for"]
    #[doc = " the same encryption key. Random generation of nonces is not generally"]
    #[doc = " recommended, due to the relatively small maximum nonce value."]
    #[doc = ""]
    #[doc = " Returned value is 1 on success, 0 on error. An error is reported if"]
    #[doc = " the tag or nonce length is out of range, or if the"]
    #[doc = " plaintext/ciphertext length cannot be encoded with the specified"]
    #[doc = " nonce length."]
    #[doc = ""]
    #[doc = " \\param ctx         CCM context structure."]
    #[doc = " \\param nonce       CCM nonce to use."]
    #[doc = " \\param nonce_len   CCM nonce length (in bytes, 7 to 13)."]
    #[doc = " \\param aad_len     additional authenticated data length (in bytes)."]
    #[doc = " \\param data_len    plaintext/ciphertext length (in bytes)."]
    #[doc = " \\param tag_len     tag length (in bytes)."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_ccm_reset(
        ctx: *mut br_ccm_context,
        nonce: *const cty::c_void,
        nonce_len: usize,
        aad_len: u64,
        data_len: u64,
        tag_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Inject additional authenticated data into CCM."]
    #[doc = ""]
    #[doc = " The provided data is injected into a running CCM computation. Additional"]
    #[doc = " data must be injected _before_ the call to `br_ccm_flip()`."]
    #[doc = " Additional data can be injected in several chunks of arbitrary length,"]
    #[doc = " but the total amount MUST exactly match the value which was provided"]
    #[doc = " to `br_ccm_reset()`."]
    #[doc = ""]
    #[doc = " \\param ctx    CCM context structure."]
    #[doc = " \\param data   pointer to additional authenticated data."]
    #[doc = " \\param len    length of additional authenticated data (in bytes)."]
    pub fn br_ccm_aad_inject(ctx: *mut br_ccm_context, data: *const cty::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Finish injection of additional authenticated data into CCM."]
    #[doc = ""]
    #[doc = " This function MUST be called before beginning the actual encryption"]
    #[doc = " or decryption (with `br_ccm_run()`), even if no additional authenticated"]
    #[doc = " data was injected. No additional authenticated data may be injected"]
    #[doc = " after this function call."]
    #[doc = ""]
    #[doc = " \\param ctx   CCM context structure."]
    pub fn br_ccm_flip(ctx: *mut br_ccm_context);
}
extern "C" {
    #[doc = " \\brief Encrypt or decrypt some data with CCM."]
    #[doc = ""]
    #[doc = " Data encryption or decryption can be done after `br_ccm_flip()`"]
    #[doc = " has been called on the context. If `encrypt` is non-zero, then the"]
    #[doc = " provided data shall be plaintext, and it is encrypted in place."]
    #[doc = " Otherwise, the data shall be ciphertext, and it is decrypted in place."]
    #[doc = ""]
    #[doc = " Data may be provided in several chunks of arbitrary length, provided"]
    #[doc = " that the total length exactly matches the length provided to the"]
    #[doc = " `br_ccm_reset()` call."]
    #[doc = ""]
    #[doc = " \\param ctx       CCM context structure."]
    #[doc = " \\param encrypt   non-zero for encryption, zero for decryption."]
    #[doc = " \\param data      data to encrypt or decrypt."]
    #[doc = " \\param len       data length (in bytes)."]
    pub fn br_ccm_run(
        ctx: *mut br_ccm_context,
        encrypt: cty::c_int,
        data: *mut cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Compute CCM authentication tag."]
    #[doc = ""]
    #[doc = " Compute the CCM authentication tag. This call terminates the CCM"]
    #[doc = " run: all data must have been injected with `br_ccm_run()` (in zero,"]
    #[doc = " one or more successive calls). After this function has been called,"]
    #[doc = " no more data can br processed; a `br_ccm_reset()` call is required"]
    #[doc = " to start a new message."]
    #[doc = ""]
    #[doc = " The tag length was provided upon context initialisation (last call"]
    #[doc = " to `br_ccm_reset()`); it is returned by this function."]
    #[doc = ""]
    #[doc = " The tag value must normally be sent along with the encrypted data."]
    #[doc = " When decrypting, the tag value must be recomputed and compared with"]
    #[doc = " the received tag: if the two tag values differ, then either the tag"]
    #[doc = " or the encrypted data was altered in transit. As an alternative to"]
    #[doc = " this function, the `br_ccm_check_tag()` function can be used to"]
    #[doc = " compute and check the tag value."]
    #[doc = ""]
    #[doc = " \\param ctx   CCM context structure."]
    #[doc = " \\param tag   destination buffer for the tag (up to 16 bytes)."]
    #[doc = " \\return  the tag length (in bytes)."]
    pub fn br_ccm_get_tag(ctx: *mut br_ccm_context, tag: *mut cty::c_void) -> usize;
}
extern "C" {
    #[doc = " \\brief Compute and check CCM authentication tag."]
    #[doc = ""]
    #[doc = " This function is an alternative to `br_ccm_get_tag()`, normally used"]
    #[doc = " on the receiving end (i.e. when decrypting value). The tag value is"]
    #[doc = " recomputed and compared with the provided tag value. If they match, 1"]
    #[doc = " is returned; on mismatch, 0 is returned. A returned value of 0 means"]
    #[doc = " that the data or the tag was altered in transit, normally leading to"]
    #[doc = " wholesale rejection of the complete message."]
    #[doc = ""]
    #[doc = " \\param ctx   CCM context structure."]
    #[doc = " \\param tag   tag value to compare with (up to 16 bytes)."]
    #[doc = " \\return  1 on success (exact match of tag value), 0 otherwise."]
    pub fn br_ccm_check_tag(ctx: *mut br_ccm_context, tag: *const cty::c_void) -> u32;
}
#[doc = " \\brief RSA public key."]
#[doc = ""]
#[doc = " The structure references the modulus and the public exponent. Both"]
#[doc = " integers use unsigned big-endian representation; extra leading bytes"]
#[doc = " of value 0 are allowed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_rsa_public_key {
    #[doc = " \\brief Modulus."]
    pub n: *mut cty::c_uchar,
    #[doc = " \\brief Modulus length (in bytes)."]
    pub nlen: usize,
    #[doc = " \\brief Public exponent."]
    pub e: *mut cty::c_uchar,
    #[doc = " \\brief Public exponent length (in bytes)."]
    pub elen: usize,
}
#[doc = " \\brief RSA private key."]
#[doc = ""]
#[doc = " The structure references the private factors, reduced private"]
#[doc = " exponents, and CRT coefficient. It also contains the bit length of"]
#[doc = " the modulus. The big integers use unsigned big-endian representation;"]
#[doc = " extra leading bytes of value 0 are allowed. However, the modulus bit"]
#[doc = " length (`n_bitlen`) MUST be exact."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_rsa_private_key {
    #[doc = " \\brief Modulus bit length (in bits, exact value)."]
    pub n_bitlen: u32,
    #[doc = " \\brief First prime factor."]
    pub p: *mut cty::c_uchar,
    #[doc = " \\brief First prime factor length (in bytes)."]
    pub plen: usize,
    #[doc = " \\brief Second prime factor."]
    pub q: *mut cty::c_uchar,
    #[doc = " \\brief Second prime factor length (in bytes)."]
    pub qlen: usize,
    #[doc = " \\brief First reduced private exponent."]
    pub dp: *mut cty::c_uchar,
    #[doc = " \\brief First reduced private exponent length (in bytes)."]
    pub dplen: usize,
    #[doc = " \\brief Second reduced private exponent."]
    pub dq: *mut cty::c_uchar,
    #[doc = " \\brief Second reduced private exponent length (in bytes)."]
    pub dqlen: usize,
    #[doc = " \\brief CRT coefficient."]
    pub iq: *mut cty::c_uchar,
    #[doc = " \\brief CRT coefficient length (in bytes)."]
    pub iqlen: usize,
}
#[doc = " \\brief Type for a RSA public key engine."]
#[doc = ""]
#[doc = " The public key engine performs the modular exponentiation of the"]
#[doc = " provided value with the public exponent. The value is modified in"]
#[doc = " place."]
#[doc = ""]
#[doc = " The value length (`xlen`) is verified to have _exactly_ the same"]
#[doc = " length as the modulus (actual modulus length, without extra leading"]
#[doc = " zeros in the modulus representation in memory). If the length does"]
#[doc = " not match, then this function returns 0 and `x[]` is unmodified."]
#[doc = ""]
#[doc = " It `xlen` is correct, then `x[]` is modified. Returned value is 1"]
#[doc = " on success, 0 on error. Error conditions include an oversized `x[]`"]
#[doc = " (the array has the same length as the modulus, but the numerical value"]
#[doc = " is not lower than the modulus) and an invalid modulus (e.g. an even"]
#[doc = " integer). If an error is reported, then the new contents of `x[]` are"]
#[doc = " unspecified."]
#[doc = ""]
#[doc = " \\param x      operand to exponentiate."]
#[doc = " \\param xlen   length of the operand (in bytes)."]
#[doc = " \\param pk     RSA public key."]
#[doc = " \\return  1 on success, 0 on error."]
pub type br_rsa_public = ::core::option::Option<
    unsafe extern "C" fn(x: *mut cty::c_uchar, xlen: usize, pk: *const br_rsa_public_key) -> u32,
>;
#[doc = " \\brief Type for a RSA signature verification engine (PKCS#1 v1.5)."]
#[doc = ""]
#[doc = " Parameters are:"]
#[doc = ""]
#[doc = "   - The signature itself. The provided array is NOT modified."]
#[doc = ""]
#[doc = "   - The encoded OID for the hash function. The provided array must begin"]
#[doc = "     with a single byte that contains the length of the OID value (in"]
#[doc = "     bytes), followed by exactly that many bytes. This parameter may"]
#[doc = "     also be `NULL`, in which case the raw hash value should be used"]
#[doc = "     with the PKCS#1 v1.5 \"type 1\" padding (as used in SSL/TLS up"]
#[doc = "     to TLS-1.1, with a 36-byte hash value)."]
#[doc = ""]
#[doc = "   - The hash output length, in bytes."]
#[doc = ""]
#[doc = "   - The public key."]
#[doc = ""]
#[doc = "   - An output buffer for the hash value. The caller must still compare"]
#[doc = "     it with the hash of the data over which the signature is computed."]
#[doc = ""]
#[doc = " **Constraints:**"]
#[doc = ""]
#[doc = "   - Hash length MUST be no more than 64 bytes."]
#[doc = ""]
#[doc = "   - OID value length MUST be no more than 32 bytes (i.e. `hash_oid[0]`"]
#[doc = "     must have a value in the 0..32 range, inclusive)."]
#[doc = ""]
#[doc = " This function verifies that the signature length (`xlen`) matches the"]
#[doc = " modulus length (this function returns 0 on mismatch). If the modulus"]
#[doc = " size exceeds the maximum supported RSA size, then the function also"]
#[doc = " returns 0."]
#[doc = ""]
#[doc = " Returned value is 1 on success, 0 on error."]
#[doc = ""]
#[doc = " Implementations of this type need not be constant-time."]
#[doc = ""]
#[doc = " \\param x          signature buffer."]
#[doc = " \\param xlen       signature length (in bytes)."]
#[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
#[doc = " \\param hash_len   expected hash value length (in bytes)."]
#[doc = " \\param pk         RSA public key."]
#[doc = " \\param hash_out   output buffer for the hash value."]
#[doc = " \\return  1 on success, 0 on error."]
pub type br_rsa_pkcs1_vrfy = ::core::option::Option<
    unsafe extern "C" fn(
        x: *const cty::c_uchar,
        xlen: usize,
        hash_oid: *const cty::c_uchar,
        hash_len: usize,
        pk: *const br_rsa_public_key,
        hash_out: *mut cty::c_uchar,
    ) -> u32,
>;
#[doc = " \\brief Type for a RSA signature verification engine (PSS)."]
#[doc = ""]
#[doc = " Parameters are:"]
#[doc = ""]
#[doc = "   - The signature itself. The provided array is NOT modified."]
#[doc = ""]
#[doc = "   - The hash function which was used to hash the message."]
#[doc = ""]
#[doc = "   - The hash function to use with MGF1 within the PSS padding. This"]
#[doc = "     is not necessarily the same hash function as the one which was"]
#[doc = "     used to hash the signed message."]
#[doc = ""]
#[doc = "   - The hashed message (as an array of bytes)."]
#[doc = ""]
#[doc = "   - The PSS salt length (in bytes)."]
#[doc = ""]
#[doc = "   - The public key."]
#[doc = ""]
#[doc = " **Constraints:**"]
#[doc = ""]
#[doc = "   - Hash message length MUST be no more than 64 bytes."]
#[doc = ""]
#[doc = " Note that, contrary to PKCS#1 v1.5 signature, the hash value of the"]
#[doc = " signed data cannot be extracted from the signature; it must be"]
#[doc = " provided to the verification function."]
#[doc = ""]
#[doc = " This function verifies that the signature length (`xlen`) matches the"]
#[doc = " modulus length (this function returns 0 on mismatch). If the modulus"]
#[doc = " size exceeds the maximum supported RSA size, then the function also"]
#[doc = " returns 0."]
#[doc = ""]
#[doc = " Returned value is 1 on success, 0 on error."]
#[doc = ""]
#[doc = " Implementations of this type need not be constant-time."]
#[doc = ""]
#[doc = " \\param x          signature buffer."]
#[doc = " \\param xlen       signature length (in bytes)."]
#[doc = " \\param hf_data    hash function applied on the message."]
#[doc = " \\param hf_mgf1    hash function to use with MGF1."]
#[doc = " \\param hash       hash value of the signed message."]
#[doc = " \\param salt_len   PSS salt length (in bytes)."]
#[doc = " \\param pk         RSA public key."]
#[doc = " \\return  1 on success, 0 on error."]
pub type br_rsa_pss_vrfy = ::core::option::Option<
    unsafe extern "C" fn(
        x: *const cty::c_uchar,
        xlen: usize,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash: *const cty::c_void,
        salt_len: usize,
        pk: *const br_rsa_public_key,
    ) -> u32,
>;
#[doc = " \\brief Type for a RSA encryption engine (OAEP)."]
#[doc = ""]
#[doc = " Parameters are:"]
#[doc = ""]
#[doc = "   - A source of random bytes. The source must be already initialized."]
#[doc = ""]
#[doc = "   - A hash function, used internally with the mask generation function"]
#[doc = "     (MGF1)."]
#[doc = ""]
#[doc = "   - A label. The `label` pointer may be `NULL` if `label_len` is zero"]
#[doc = "     (an empty label, which is the default in PKCS#1 v2.2)."]
#[doc = ""]
#[doc = "   - The public key."]
#[doc = ""]
#[doc = "   - The destination buffer. Its maximum length (in bytes) is provided;"]
#[doc = "     if that length is lower than the public key length, then an error"]
#[doc = "     is reported."]
#[doc = ""]
#[doc = "   - The source message."]
#[doc = ""]
#[doc = " The encrypted message output has exactly the same length as the modulus"]
#[doc = " (mathematical length, in bytes, not counting extra leading zeros in the"]
#[doc = " modulus representation in the public key)."]
#[doc = ""]
#[doc = " The source message (`src`, length `src_len`) may overlap with the"]
#[doc = " destination buffer (`dst`, length `dst_max_len`)."]
#[doc = ""]
#[doc = " This function returns the actual encrypted message length, in bytes;"]
#[doc = " on error, zero is returned. An error is reported if the output buffer"]
#[doc = " is not large enough, or the public is invalid, or the public key"]
#[doc = " modulus exceeds the maximum supported RSA size."]
#[doc = ""]
#[doc = " \\param rnd           source of random bytes."]
#[doc = " \\param dig           hash function to use with MGF1."]
#[doc = " \\param label         label value (may be `NULL` if `label_len` is zero)."]
#[doc = " \\param label_len     label length, in bytes."]
#[doc = " \\param pk            RSA public key."]
#[doc = " \\param dst           destination buffer."]
#[doc = " \\param dst_max_len   destination buffer length (maximum encrypted data size)."]
#[doc = " \\param src           message to encrypt."]
#[doc = " \\param src_len       source message length (in bytes)."]
#[doc = " \\return  encrypted message length (in bytes), or 0 on error."]
pub type br_rsa_oaep_encrypt = ::core::option::Option<
    unsafe extern "C" fn(
        rnd: *mut *const br_prng_class,
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        pk: *const br_rsa_public_key,
        dst: *mut cty::c_void,
        dst_max_len: usize,
        src: *const cty::c_void,
        src_len: usize,
    ) -> usize,
>;
#[doc = " \\brief Type for a RSA private key engine."]
#[doc = ""]
#[doc = " The `x[]` buffer is modified in place, and its length is inferred from"]
#[doc = " the modulus length (`x[]` is assumed to have a length of"]
#[doc = " `(sk->n_bitlen+7)/8` bytes)."]
#[doc = ""]
#[doc = " Returned value is 1 on success, 0 on error."]
#[doc = ""]
#[doc = " \\param x    operand to exponentiate."]
#[doc = " \\param sk   RSA private key."]
#[doc = " \\return  1 on success, 0 on error."]
pub type br_rsa_private = ::core::option::Option<
    unsafe extern "C" fn(x: *mut cty::c_uchar, sk: *const br_rsa_private_key) -> u32,
>;
#[doc = " \\brief Type for a RSA signature generation engine (PKCS#1 v1.5)."]
#[doc = ""]
#[doc = " Parameters are:"]
#[doc = ""]
#[doc = "   - The encoded OID for the hash function. The provided array must begin"]
#[doc = "     with a single byte that contains the length of the OID value (in"]
#[doc = "     bytes), followed by exactly that many bytes. This parameter may"]
#[doc = "     also be `NULL`, in which case the raw hash value should be used"]
#[doc = "     with the PKCS#1 v1.5 \"type 1\" padding (as used in SSL/TLS up"]
#[doc = "     to TLS-1.1, with a 36-byte hash value)."]
#[doc = ""]
#[doc = "   - The hash value computes over the data to sign (its length is"]
#[doc = "     expressed in bytes)."]
#[doc = ""]
#[doc = "   - The RSA private key."]
#[doc = ""]
#[doc = "   - The output buffer, that receives the signature."]
#[doc = ""]
#[doc = " Returned value is 1 on success, 0 on error. Error conditions include"]
#[doc = " a too small modulus for the provided hash OID and value, or some"]
#[doc = " invalid key parameters. The signature length is exactly"]
#[doc = " `(sk->n_bitlen+7)/8` bytes."]
#[doc = ""]
#[doc = " This function is expected to be constant-time with regards to the"]
#[doc = " private key bytes (lengths of the modulus and the individual factors"]
#[doc = " may leak, though) and to the hashed data."]
#[doc = ""]
#[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
#[doc = " \\param hash       hash value."]
#[doc = " \\param hash_len   hash value length (in bytes)."]
#[doc = " \\param sk         RSA private key."]
#[doc = " \\param x          output buffer for the signature value."]
#[doc = " \\return  1 on success, 0 on error."]
pub type br_rsa_pkcs1_sign = ::core::option::Option<
    unsafe extern "C" fn(
        hash_oid: *const cty::c_uchar,
        hash: *const cty::c_uchar,
        hash_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32,
>;
#[doc = " \\brief Type for a RSA signature generation engine (PSS)."]
#[doc = ""]
#[doc = " Parameters are:"]
#[doc = ""]
#[doc = "   - An initialized PRNG for salt generation. If the salt length is"]
#[doc = "     zero (`salt_len` parameter), then the PRNG is optional (this is"]
#[doc = "     not the typical case, as the security proof of RSA/PSS is"]
#[doc = "     tighter when a non-empty salt is used)."]
#[doc = ""]
#[doc = "   - The hash function which was used to hash the message."]
#[doc = ""]
#[doc = "   - The hash function to use with MGF1 within the PSS padding. This"]
#[doc = "     is not necessarily the same function as the one used to hash the"]
#[doc = "     message."]
#[doc = ""]
#[doc = "   - The hashed message."]
#[doc = ""]
#[doc = "   - The salt length, in bytes."]
#[doc = ""]
#[doc = "   - The RSA private key."]
#[doc = ""]
#[doc = "   - The output buffer, that receives the signature."]
#[doc = ""]
#[doc = " Returned value is 1 on success, 0 on error. Error conditions include"]
#[doc = " a too small modulus for the provided hash and salt lengths, or some"]
#[doc = " invalid key parameters. The signature length is exactly"]
#[doc = " `(sk->n_bitlen+7)/8` bytes."]
#[doc = ""]
#[doc = " This function is expected to be constant-time with regards to the"]
#[doc = " private key bytes (lengths of the modulus and the individual factors"]
#[doc = " may leak, though) and to the hashed data."]
#[doc = ""]
#[doc = " \\param rng        PRNG for salt generation (`NULL` if `salt_len` is zero)."]
#[doc = " \\param hf_data    hash function used to hash the signed data."]
#[doc = " \\param hf_mgf1    hash function to use with MGF1."]
#[doc = " \\param hash       hashed message."]
#[doc = " \\param salt_len   salt length (in bytes)."]
#[doc = " \\param sk         RSA private key."]
#[doc = " \\param x          output buffer for the signature value."]
#[doc = " \\return  1 on success, 0 on error."]
pub type br_rsa_pss_sign = ::core::option::Option<
    unsafe extern "C" fn(
        rng: *mut *const br_prng_class,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash_value: *const cty::c_uchar,
        salt_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32,
>;
#[doc = " \\brief Type for a RSA decryption engine (OAEP)."]
#[doc = ""]
#[doc = " Parameters are:"]
#[doc = ""]
#[doc = "   - A hash function, used internally with the mask generation function"]
#[doc = "     (MGF1)."]
#[doc = ""]
#[doc = "   - A label. The `label` pointer may be `NULL` if `label_len` is zero"]
#[doc = "     (an empty label, which is the default in PKCS#1 v2.2)."]
#[doc = ""]
#[doc = "   - The private key."]
#[doc = ""]
#[doc = "   - The source and destination buffer. The buffer initially contains"]
#[doc = "     the encrypted message; the buffer contents are altered, and the"]
#[doc = "     decrypted message is written at the start of that buffer"]
#[doc = "     (decrypted message is always shorter than the encrypted message)."]
#[doc = ""]
#[doc = " If decryption fails in any way, then `*len` is unmodified, and the"]
#[doc = " function returns 0. Otherwise, `*len` is set to the decrypted message"]
#[doc = " length, and 1 is returned. The implementation is responsible for"]
#[doc = " checking that the input message length matches the key modulus length,"]
#[doc = " and that the padding is correct."]
#[doc = ""]
#[doc = " Implementations MUST use constant-time check of the validity of the"]
#[doc = " OAEP padding, at least until the leading byte and hash value have"]
#[doc = " been checked. Whether overall decryption worked, and the length of"]
#[doc = " the decrypted message, may leak."]
#[doc = ""]
#[doc = " \\param dig         hash function to use with MGF1."]
#[doc = " \\param label       label value (may be `NULL` if `label_len` is zero)."]
#[doc = " \\param label_len   label length, in bytes."]
#[doc = " \\param sk          RSA private key."]
#[doc = " \\param data        input/output buffer."]
#[doc = " \\param len         encrypted/decrypted message length."]
#[doc = " \\return  1 on success, 0 on error."]
pub type br_rsa_oaep_decrypt = ::core::option::Option<
    unsafe extern "C" fn(
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        sk: *const br_rsa_private_key,
        data: *mut cty::c_void,
        len: *mut usize,
    ) -> u32,
>;
extern "C" {
    #[doc = " \\brief RSA public key engine \"i32\"."]
    #[doc = ""]
    #[doc = " \\see br_rsa_public"]
    #[doc = ""]
    #[doc = " \\param x      operand to exponentiate."]
    #[doc = " \\param xlen   length of the operand (in bytes)."]
    #[doc = " \\param pk     RSA public key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i32_public(
        x: *mut cty::c_uchar,
        xlen: usize,
        pk: *const br_rsa_public_key,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature verification engine \"i32\" (PKCS#1 v1.5 signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pkcs1_vrfy"]
    #[doc = ""]
    #[doc = " \\param x          signature buffer."]
    #[doc = " \\param xlen       signature length (in bytes)."]
    #[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
    #[doc = " \\param hash_len   expected hash value length (in bytes)."]
    #[doc = " \\param pk         RSA public key."]
    #[doc = " \\param hash_out   output buffer for the hash value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i32_pkcs1_vrfy(
        x: *const cty::c_uchar,
        xlen: usize,
        hash_oid: *const cty::c_uchar,
        hash_len: usize,
        pk: *const br_rsa_public_key,
        hash_out: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature verification engine \"i32\" (PSS signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pss_vrfy"]
    #[doc = ""]
    #[doc = " \\param x          signature buffer."]
    #[doc = " \\param xlen       signature length (in bytes)."]
    #[doc = " \\param hf_data    hash function applied on the message."]
    #[doc = " \\param hf_mgf1    hash function to use with MGF1."]
    #[doc = " \\param hash       hash value of the signed message."]
    #[doc = " \\param salt_len   PSS salt length (in bytes)."]
    #[doc = " \\param pk         RSA public key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i32_pss_vrfy(
        x: *const cty::c_uchar,
        xlen: usize,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash: *const cty::c_void,
        salt_len: usize,
        pk: *const br_rsa_public_key,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA private key engine \"i32\"."]
    #[doc = ""]
    #[doc = " \\see br_rsa_private"]
    #[doc = ""]
    #[doc = " \\param x    operand to exponentiate."]
    #[doc = " \\param sk   RSA private key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i32_private(x: *mut cty::c_uchar, sk: *const br_rsa_private_key) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature generation engine \"i32\" (PKCS#1 v1.5 signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pkcs1_sign"]
    #[doc = ""]
    #[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
    #[doc = " \\param hash       hash value."]
    #[doc = " \\param hash_len   hash value length (in bytes)."]
    #[doc = " \\param sk         RSA private key."]
    #[doc = " \\param x          output buffer for the hash value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i32_pkcs1_sign(
        hash_oid: *const cty::c_uchar,
        hash: *const cty::c_uchar,
        hash_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature generation engine \"i32\" (PSS signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pss_sign"]
    #[doc = ""]
    #[doc = " \\param rng        PRNG for salt generation (`NULL` if `salt_len` is zero)."]
    #[doc = " \\param hf_data    hash function used to hash the signed data."]
    #[doc = " \\param hf_mgf1    hash function to use with MGF1."]
    #[doc = " \\param hash       hashed message."]
    #[doc = " \\param salt_len   salt length (in bytes)."]
    #[doc = " \\param sk         RSA private key."]
    #[doc = " \\param x          output buffer for the signature value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i32_pss_sign(
        rng: *mut *const br_prng_class,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash_value: *const cty::c_uchar,
        salt_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA public key engine \"i31\"."]
    #[doc = ""]
    #[doc = " \\see br_rsa_public"]
    #[doc = ""]
    #[doc = " \\param x      operand to exponentiate."]
    #[doc = " \\param xlen   length of the operand (in bytes)."]
    #[doc = " \\param pk     RSA public key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i31_public(
        x: *mut cty::c_uchar,
        xlen: usize,
        pk: *const br_rsa_public_key,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature verification engine \"i31\" (PKCS#1 v1.5 signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pkcs1_vrfy"]
    #[doc = ""]
    #[doc = " \\param x          signature buffer."]
    #[doc = " \\param xlen       signature length (in bytes)."]
    #[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
    #[doc = " \\param hash_len   expected hash value length (in bytes)."]
    #[doc = " \\param pk         RSA public key."]
    #[doc = " \\param hash_out   output buffer for the hash value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i31_pkcs1_vrfy(
        x: *const cty::c_uchar,
        xlen: usize,
        hash_oid: *const cty::c_uchar,
        hash_len: usize,
        pk: *const br_rsa_public_key,
        hash_out: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature verification engine \"i31\" (PSS signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pss_vrfy"]
    #[doc = ""]
    #[doc = " \\param x          signature buffer."]
    #[doc = " \\param xlen       signature length (in bytes)."]
    #[doc = " \\param hf_data    hash function applied on the message."]
    #[doc = " \\param hf_mgf1    hash function to use with MGF1."]
    #[doc = " \\param hash       hash value of the signed message."]
    #[doc = " \\param salt_len   PSS salt length (in bytes)."]
    #[doc = " \\param pk         RSA public key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i31_pss_vrfy(
        x: *const cty::c_uchar,
        xlen: usize,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash: *const cty::c_void,
        salt_len: usize,
        pk: *const br_rsa_public_key,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA private key engine \"i31\"."]
    #[doc = ""]
    #[doc = " \\see br_rsa_private"]
    #[doc = ""]
    #[doc = " \\param x    operand to exponentiate."]
    #[doc = " \\param sk   RSA private key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i31_private(x: *mut cty::c_uchar, sk: *const br_rsa_private_key) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature generation engine \"i31\" (PKCS#1 v1.5 signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pkcs1_sign"]
    #[doc = ""]
    #[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
    #[doc = " \\param hash       hash value."]
    #[doc = " \\param hash_len   hash value length (in bytes)."]
    #[doc = " \\param sk         RSA private key."]
    #[doc = " \\param x          output buffer for the hash value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i31_pkcs1_sign(
        hash_oid: *const cty::c_uchar,
        hash: *const cty::c_uchar,
        hash_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature generation engine \"i31\" (PSS signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pss_sign"]
    #[doc = ""]
    #[doc = " \\param rng        PRNG for salt generation (`NULL` if `salt_len` is zero)."]
    #[doc = " \\param hf_data    hash function used to hash the signed data."]
    #[doc = " \\param hf_mgf1    hash function to use with MGF1."]
    #[doc = " \\param hash       hashed message."]
    #[doc = " \\param salt_len   salt length (in bytes)."]
    #[doc = " \\param sk         RSA private key."]
    #[doc = " \\param x          output buffer for the signature value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i31_pss_sign(
        rng: *mut *const br_prng_class,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash_value: *const cty::c_uchar,
        salt_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA public key engine \"i62\"."]
    #[doc = ""]
    #[doc = " This function is defined only on architecture that offer a 64x64->128"]
    #[doc = " opcode. Use `br_rsa_i62_public_get()` to dynamically obtain a pointer"]
    #[doc = " to that function."]
    #[doc = ""]
    #[doc = " \\see br_rsa_public"]
    #[doc = ""]
    #[doc = " \\param x      operand to exponentiate."]
    #[doc = " \\param xlen   length of the operand (in bytes)."]
    #[doc = " \\param pk     RSA public key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i62_public(
        x: *mut cty::c_uchar,
        xlen: usize,
        pk: *const br_rsa_public_key,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature verification engine \"i62\" (PKCS#1 v1.5 signatures)."]
    #[doc = ""]
    #[doc = " This function is defined only on architecture that offer a 64x64->128"]
    #[doc = " opcode. Use `br_rsa_i62_pkcs1_vrfy_get()` to dynamically obtain a pointer"]
    #[doc = " to that function."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pkcs1_vrfy"]
    #[doc = ""]
    #[doc = " \\param x          signature buffer."]
    #[doc = " \\param xlen       signature length (in bytes)."]
    #[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
    #[doc = " \\param hash_len   expected hash value length (in bytes)."]
    #[doc = " \\param pk         RSA public key."]
    #[doc = " \\param hash_out   output buffer for the hash value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i62_pkcs1_vrfy(
        x: *const cty::c_uchar,
        xlen: usize,
        hash_oid: *const cty::c_uchar,
        hash_len: usize,
        pk: *const br_rsa_public_key,
        hash_out: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature verification engine \"i62\" (PSS signatures)."]
    #[doc = ""]
    #[doc = " This function is defined only on architecture that offer a 64x64->128"]
    #[doc = " opcode. Use `br_rsa_i62_pss_vrfy_get()` to dynamically obtain a pointer"]
    #[doc = " to that function."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pss_vrfy"]
    #[doc = ""]
    #[doc = " \\param x          signature buffer."]
    #[doc = " \\param xlen       signature length (in bytes)."]
    #[doc = " \\param hf_data    hash function applied on the message."]
    #[doc = " \\param hf_mgf1    hash function to use with MGF1."]
    #[doc = " \\param hash       hash value of the signed message."]
    #[doc = " \\param salt_len   PSS salt length (in bytes)."]
    #[doc = " \\param pk         RSA public key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i62_pss_vrfy(
        x: *const cty::c_uchar,
        xlen: usize,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash: *const cty::c_void,
        salt_len: usize,
        pk: *const br_rsa_public_key,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA private key engine \"i62\"."]
    #[doc = ""]
    #[doc = " This function is defined only on architecture that offer a 64x64->128"]
    #[doc = " opcode. Use `br_rsa_i62_private_get()` to dynamically obtain a pointer"]
    #[doc = " to that function."]
    #[doc = ""]
    #[doc = " \\see br_rsa_private"]
    #[doc = ""]
    #[doc = " \\param x    operand to exponentiate."]
    #[doc = " \\param sk   RSA private key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i62_private(x: *mut cty::c_uchar, sk: *const br_rsa_private_key) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature generation engine \"i62\" (PKCS#1 v1.5 signatures)."]
    #[doc = ""]
    #[doc = " This function is defined only on architecture that offer a 64x64->128"]
    #[doc = " opcode. Use `br_rsa_i62_pkcs1_sign_get()` to dynamically obtain a pointer"]
    #[doc = " to that function."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pkcs1_sign"]
    #[doc = ""]
    #[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
    #[doc = " \\param hash       hash value."]
    #[doc = " \\param hash_len   hash value length (in bytes)."]
    #[doc = " \\param sk         RSA private key."]
    #[doc = " \\param x          output buffer for the hash value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i62_pkcs1_sign(
        hash_oid: *const cty::c_uchar,
        hash: *const cty::c_uchar,
        hash_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature generation engine \"i62\" (PSS signatures)."]
    #[doc = ""]
    #[doc = " This function is defined only on architecture that offer a 64x64->128"]
    #[doc = " opcode. Use `br_rsa_i62_pss_sign_get()` to dynamically obtain a pointer"]
    #[doc = " to that function."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pss_sign"]
    #[doc = ""]
    #[doc = " \\param rng        PRNG for salt generation (`NULL` if `salt_len` is zero)."]
    #[doc = " \\param hf_data    hash function used to hash the signed data."]
    #[doc = " \\param hf_mgf1    hash function to use with MGF1."]
    #[doc = " \\param hash       hashed message."]
    #[doc = " \\param salt_len   salt length (in bytes)."]
    #[doc = " \\param sk         RSA private key."]
    #[doc = " \\param x          output buffer for the signature value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i62_pss_sign(
        rng: *mut *const br_prng_class,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash_value: *const cty::c_uchar,
        salt_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief Get the RSA \"i62\" implementation (public key operations),"]
    #[doc = " if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_rsa_i62_public_get() -> br_rsa_public;
}
extern "C" {
    #[doc = " \\brief Get the RSA \"i62\" implementation (PKCS#1 v1.5 signature verification),"]
    #[doc = " if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_rsa_i62_pkcs1_vrfy_get() -> br_rsa_pkcs1_vrfy;
}
extern "C" {
    #[doc = " \\brief Get the RSA \"i62\" implementation (PSS signature verification),"]
    #[doc = " if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_rsa_i62_pss_vrfy_get() -> br_rsa_pss_vrfy;
}
extern "C" {
    #[doc = " \\brief Get the RSA \"i62\" implementation (private key operations),"]
    #[doc = " if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_rsa_i62_private_get() -> br_rsa_private;
}
extern "C" {
    #[doc = " \\brief Get the RSA \"i62\" implementation (PKCS#1 v1.5 signature generation),"]
    #[doc = " if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_rsa_i62_pkcs1_sign_get() -> br_rsa_pkcs1_sign;
}
extern "C" {
    #[doc = " \\brief Get the RSA \"i62\" implementation (PSS signature generation),"]
    #[doc = " if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_rsa_i62_pss_sign_get() -> br_rsa_pss_sign;
}
extern "C" {
    #[doc = " \\brief Get the RSA \"i62\" implementation (OAEP encryption),"]
    #[doc = " if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_rsa_i62_oaep_encrypt_get() -> br_rsa_oaep_encrypt;
}
extern "C" {
    #[doc = " \\brief Get the RSA \"i62\" implementation (OAEP decryption),"]
    #[doc = " if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_rsa_i62_oaep_decrypt_get() -> br_rsa_oaep_decrypt;
}
extern "C" {
    #[doc = " \\brief RSA public key engine \"i15\"."]
    #[doc = ""]
    #[doc = " \\see br_rsa_public"]
    #[doc = ""]
    #[doc = " \\param x      operand to exponentiate."]
    #[doc = " \\param xlen   length of the operand (in bytes)."]
    #[doc = " \\param pk     RSA public key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i15_public(
        x: *mut cty::c_uchar,
        xlen: usize,
        pk: *const br_rsa_public_key,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature verification engine \"i15\" (PKCS#1 v1.5 signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pkcs1_vrfy"]
    #[doc = ""]
    #[doc = " \\param x          signature buffer."]
    #[doc = " \\param xlen       signature length (in bytes)."]
    #[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
    #[doc = " \\param hash_len   expected hash value length (in bytes)."]
    #[doc = " \\param pk         RSA public key."]
    #[doc = " \\param hash_out   output buffer for the hash value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i15_pkcs1_vrfy(
        x: *const cty::c_uchar,
        xlen: usize,
        hash_oid: *const cty::c_uchar,
        hash_len: usize,
        pk: *const br_rsa_public_key,
        hash_out: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature verification engine \"i15\" (PSS signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pss_vrfy"]
    #[doc = ""]
    #[doc = " \\param x          signature buffer."]
    #[doc = " \\param xlen       signature length (in bytes)."]
    #[doc = " \\param hf_data    hash function applied on the message."]
    #[doc = " \\param hf_mgf1    hash function to use with MGF1."]
    #[doc = " \\param hash       hash value of the signed message."]
    #[doc = " \\param salt_len   PSS salt length (in bytes)."]
    #[doc = " \\param pk         RSA public key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i15_pss_vrfy(
        x: *const cty::c_uchar,
        xlen: usize,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash: *const cty::c_void,
        salt_len: usize,
        pk: *const br_rsa_public_key,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA private key engine \"i15\"."]
    #[doc = ""]
    #[doc = " \\see br_rsa_private"]
    #[doc = ""]
    #[doc = " \\param x    operand to exponentiate."]
    #[doc = " \\param sk   RSA private key."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i15_private(x: *mut cty::c_uchar, sk: *const br_rsa_private_key) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature generation engine \"i15\" (PKCS#1 v1.5 signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pkcs1_sign"]
    #[doc = ""]
    #[doc = " \\param hash_oid   encoded hash algorithm OID (or `NULL`)."]
    #[doc = " \\param hash       hash value."]
    #[doc = " \\param hash_len   hash value length (in bytes)."]
    #[doc = " \\param sk         RSA private key."]
    #[doc = " \\param x          output buffer for the hash value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i15_pkcs1_sign(
        hash_oid: *const cty::c_uchar,
        hash: *const cty::c_uchar,
        hash_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA signature generation engine \"i15\" (PSS signatures)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_pss_sign"]
    #[doc = ""]
    #[doc = " \\param rng        PRNG for salt generation (`NULL` if `salt_len` is zero)."]
    #[doc = " \\param hf_data    hash function used to hash the signed data."]
    #[doc = " \\param hf_mgf1    hash function to use with MGF1."]
    #[doc = " \\param hash       hashed message."]
    #[doc = " \\param salt_len   salt length (in bytes)."]
    #[doc = " \\param sk         RSA private key."]
    #[doc = " \\param x          output buffer for the signature value."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i15_pss_sign(
        rng: *mut *const br_prng_class,
        hf_data: *const br_hash_class,
        hf_mgf1: *const br_hash_class,
        hash_value: *const cty::c_uchar,
        salt_len: usize,
        sk: *const br_rsa_private_key,
        x: *mut cty::c_uchar,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (public-key operations)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (public-key operations)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_public_get_default() -> br_rsa_public;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (private-key operations)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (private-key operations)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_private_get_default() -> br_rsa_private;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (PKCS#1 v1.5 signature verification)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (signature verification)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_pkcs1_vrfy_get_default() -> br_rsa_pkcs1_vrfy;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (PSS signature verification)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (signature verification)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_pss_vrfy_get_default() -> br_rsa_pss_vrfy;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (PKCS#1 v1.5 signature generation)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (signature generation)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_pkcs1_sign_get_default() -> br_rsa_pkcs1_sign;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (PSS signature generation)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (signature generation)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_pss_sign_get_default() -> br_rsa_pss_sign;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (OAEP encryption)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (OAEP encryption)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_oaep_encrypt_get_default() -> br_rsa_oaep_encrypt;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (OAEP decryption)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (OAEP decryption)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_oaep_decrypt_get_default() -> br_rsa_oaep_decrypt;
}
extern "C" {
    #[doc = " \\brief RSA decryption helper, for SSL/TLS."]
    #[doc = ""]
    #[doc = " This function performs the RSA decryption for a RSA-based key exchange"]
    #[doc = " in a SSL/TLS server. The provided RSA engine is used. The `data`"]
    #[doc = " parameter points to the value to decrypt, of length `len` bytes. On"]
    #[doc = " success, the 48-byte pre-master secret is copied into `data`, starting"]
    #[doc = " at the first byte of that buffer; on error, the contents of `data`"]
    #[doc = " become indeterminate."]
    #[doc = ""]
    #[doc = " This function first checks that the provided value length (`len`) is"]
    #[doc = " not lower than 59 bytes, and matches the RSA modulus length; if neither"]
    #[doc = " of this property is met, then this function returns 0 and the buffer"]
    #[doc = " is unmodified."]
    #[doc = ""]
    #[doc = " Otherwise, decryption and then padding verification are performed, both"]
    #[doc = " in constant-time. A decryption error, or a bad padding, or an"]
    #[doc = " incorrect decrypted value length are reported with a returned value of"]
    #[doc = " 0; on success, 1 is returned. The caller (SSL server engine) is supposed"]
    #[doc = " to proceed with a random pre-master secret in case of error."]
    #[doc = ""]
    #[doc = " \\param core   RSA private key engine."]
    #[doc = " \\param sk     RSA private key."]
    #[doc = " \\param data   input/output buffer."]
    #[doc = " \\param len    length (in bytes) of the data to decrypt."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_ssl_decrypt(
        core: br_rsa_private,
        sk: *const br_rsa_private_key,
        data: *mut cty::c_uchar,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA encryption (OAEP) with the \"i15\" engine."]
    #[doc = ""]
    #[doc = " \\see br_rsa_oaep_encrypt"]
    #[doc = ""]
    #[doc = " \\param rnd           source of random bytes."]
    #[doc = " \\param dig           hash function to use with MGF1."]
    #[doc = " \\param label         label value (may be `NULL` if `label_len` is zero)."]
    #[doc = " \\param label_len     label length, in bytes."]
    #[doc = " \\param pk            RSA public key."]
    #[doc = " \\param dst           destination buffer."]
    #[doc = " \\param dst_max_len   destination buffer length (maximum encrypted data size)."]
    #[doc = " \\param src           message to encrypt."]
    #[doc = " \\param src_len       source message length (in bytes)."]
    #[doc = " \\return  encrypted message length (in bytes), or 0 on error."]
    pub fn br_rsa_i15_oaep_encrypt(
        rnd: *mut *const br_prng_class,
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        pk: *const br_rsa_public_key,
        dst: *mut cty::c_void,
        dst_max_len: usize,
        src: *const cty::c_void,
        src_len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief RSA decryption (OAEP) with the \"i15\" engine."]
    #[doc = ""]
    #[doc = " \\see br_rsa_oaep_decrypt"]
    #[doc = ""]
    #[doc = " \\param dig         hash function to use with MGF1."]
    #[doc = " \\param label       label value (may be `NULL` if `label_len` is zero)."]
    #[doc = " \\param label_len   label length, in bytes."]
    #[doc = " \\param sk          RSA private key."]
    #[doc = " \\param data        input/output buffer."]
    #[doc = " \\param len         encrypted/decrypted message length."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i15_oaep_decrypt(
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        sk: *const br_rsa_private_key,
        data: *mut cty::c_void,
        len: *mut usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA encryption (OAEP) with the \"i31\" engine."]
    #[doc = ""]
    #[doc = " \\see br_rsa_oaep_encrypt"]
    #[doc = ""]
    #[doc = " \\param rnd           source of random bytes."]
    #[doc = " \\param dig           hash function to use with MGF1."]
    #[doc = " \\param label         label value (may be `NULL` if `label_len` is zero)."]
    #[doc = " \\param label_len     label length, in bytes."]
    #[doc = " \\param pk            RSA public key."]
    #[doc = " \\param dst           destination buffer."]
    #[doc = " \\param dst_max_len   destination buffer length (maximum encrypted data size)."]
    #[doc = " \\param src           message to encrypt."]
    #[doc = " \\param src_len       source message length (in bytes)."]
    #[doc = " \\return  encrypted message length (in bytes), or 0 on error."]
    pub fn br_rsa_i31_oaep_encrypt(
        rnd: *mut *const br_prng_class,
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        pk: *const br_rsa_public_key,
        dst: *mut cty::c_void,
        dst_max_len: usize,
        src: *const cty::c_void,
        src_len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief RSA decryption (OAEP) with the \"i31\" engine."]
    #[doc = ""]
    #[doc = " \\see br_rsa_oaep_decrypt"]
    #[doc = ""]
    #[doc = " \\param dig         hash function to use with MGF1."]
    #[doc = " \\param label       label value (may be `NULL` if `label_len` is zero)."]
    #[doc = " \\param label_len   label length, in bytes."]
    #[doc = " \\param sk          RSA private key."]
    #[doc = " \\param data        input/output buffer."]
    #[doc = " \\param len         encrypted/decrypted message length."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i31_oaep_decrypt(
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        sk: *const br_rsa_private_key,
        data: *mut cty::c_void,
        len: *mut usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA encryption (OAEP) with the \"i32\" engine."]
    #[doc = ""]
    #[doc = " \\see br_rsa_oaep_encrypt"]
    #[doc = ""]
    #[doc = " \\param rnd           source of random bytes."]
    #[doc = " \\param dig           hash function to use with MGF1."]
    #[doc = " \\param label         label value (may be `NULL` if `label_len` is zero)."]
    #[doc = " \\param label_len     label length, in bytes."]
    #[doc = " \\param pk            RSA public key."]
    #[doc = " \\param dst           destination buffer."]
    #[doc = " \\param dst_max_len   destination buffer length (maximum encrypted data size)."]
    #[doc = " \\param src           message to encrypt."]
    #[doc = " \\param src_len       source message length (in bytes)."]
    #[doc = " \\return  encrypted message length (in bytes), or 0 on error."]
    pub fn br_rsa_i32_oaep_encrypt(
        rnd: *mut *const br_prng_class,
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        pk: *const br_rsa_public_key,
        dst: *mut cty::c_void,
        dst_max_len: usize,
        src: *const cty::c_void,
        src_len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief RSA decryption (OAEP) with the \"i32\" engine."]
    #[doc = ""]
    #[doc = " \\see br_rsa_oaep_decrypt"]
    #[doc = ""]
    #[doc = " \\param dig         hash function to use with MGF1."]
    #[doc = " \\param label       label value (may be `NULL` if `label_len` is zero)."]
    #[doc = " \\param label_len   label length, in bytes."]
    #[doc = " \\param sk          RSA private key."]
    #[doc = " \\param data        input/output buffer."]
    #[doc = " \\param len         encrypted/decrypted message length."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i32_oaep_decrypt(
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        sk: *const br_rsa_private_key,
        data: *mut cty::c_void,
        len: *mut usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA encryption (OAEP) with the \"i62\" engine."]
    #[doc = ""]
    #[doc = " This function is defined only on architecture that offer a 64x64->128"]
    #[doc = " opcode. Use `br_rsa_i62_oaep_encrypt_get()` to dynamically obtain a pointer"]
    #[doc = " to that function."]
    #[doc = ""]
    #[doc = " \\see br_rsa_oaep_encrypt"]
    #[doc = ""]
    #[doc = " \\param rnd           source of random bytes."]
    #[doc = " \\param dig           hash function to use with MGF1."]
    #[doc = " \\param label         label value (may be `NULL` if `label_len` is zero)."]
    #[doc = " \\param label_len     label length, in bytes."]
    #[doc = " \\param pk            RSA public key."]
    #[doc = " \\param dst           destination buffer."]
    #[doc = " \\param dst_max_len   destination buffer length (maximum encrypted data size)."]
    #[doc = " \\param src           message to encrypt."]
    #[doc = " \\param src_len       source message length (in bytes)."]
    #[doc = " \\return  encrypted message length (in bytes), or 0 on error."]
    pub fn br_rsa_i62_oaep_encrypt(
        rnd: *mut *const br_prng_class,
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        pk: *const br_rsa_public_key,
        dst: *mut cty::c_void,
        dst_max_len: usize,
        src: *const cty::c_void,
        src_len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief RSA decryption (OAEP) with the \"i62\" engine."]
    #[doc = ""]
    #[doc = " This function is defined only on architecture that offer a 64x64->128"]
    #[doc = " opcode. Use `br_rsa_i62_oaep_decrypt_get()` to dynamically obtain a pointer"]
    #[doc = " to that function."]
    #[doc = ""]
    #[doc = " \\see br_rsa_oaep_decrypt"]
    #[doc = ""]
    #[doc = " \\param dig         hash function to use with MGF1."]
    #[doc = " \\param label       label value (may be `NULL` if `label_len` is zero)."]
    #[doc = " \\param label_len   label length, in bytes."]
    #[doc = " \\param sk          RSA private key."]
    #[doc = " \\param data        input/output buffer."]
    #[doc = " \\param len         encrypted/decrypted message length."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_rsa_i62_oaep_decrypt(
        dig: *const br_hash_class,
        label: *const cty::c_void,
        label_len: usize,
        sk: *const br_rsa_private_key,
        data: *mut cty::c_void,
        len: *mut usize,
    ) -> u32;
}
#[doc = " \\brief Type for RSA key pair generator implementation."]
#[doc = ""]
#[doc = " This function generates a new RSA key pair whose modulus has bit"]
#[doc = " length `size` bits. The private key elements are written in the"]
#[doc = " `kbuf_priv` buffer, and pointer values and length fields to these"]
#[doc = " elements are populated in the provided private key structure `sk`."]
#[doc = " Similarly, the public key elements are written in `kbuf_pub`, with"]
#[doc = " pointers and lengths set in `pk`."]
#[doc = ""]
#[doc = " If `pk` is `NULL`, then `kbuf_pub` may be `NULL`, and only the"]
#[doc = " private key is set."]
#[doc = ""]
#[doc = " If `pubexp` is not zero, then its value will be used as public"]
#[doc = " exponent. Valid RSA public exponent values are odd integers"]
#[doc = " greater than 1. If `pubexp` is zero, then the public exponent will"]
#[doc = " have value 3."]
#[doc = ""]
#[doc = " The provided PRNG (`rng_ctx`) must have already been initialized"]
#[doc = " and seeded."]
#[doc = ""]
#[doc = " Returned value is 1 on success, 0 on error. An error is reported"]
#[doc = " if the requested range is outside of the supported key sizes, or"]
#[doc = " if an invalid non-zero public exponent value is provided. Supported"]
#[doc = " range starts at 512 bits, and up to an implementation-defined"]
#[doc = " maximum (by default 4096 bits). Note that key sizes up to 768 bits"]
#[doc = " have been broken in practice, and sizes lower than 2048 bits are"]
#[doc = " usually considered to be weak and should not be used."]
#[doc = ""]
#[doc = " \\param rng_ctx     source PRNG context (already initialized)"]
#[doc = " \\param sk          RSA private key structure (destination)"]
#[doc = " \\param kbuf_priv   buffer for private key elements"]
#[doc = " \\param pk          RSA public key structure (destination), or `NULL`"]
#[doc = " \\param kbuf_pub    buffer for public key elements, or `NULL`"]
#[doc = " \\param size        target RSA modulus size (in bits)"]
#[doc = " \\param pubexp      public exponent to use, or zero"]
#[doc = " \\return  1 on success, 0 on error (invalid parameters)"]
pub type br_rsa_keygen = ::core::option::Option<
    unsafe extern "C" fn(
        rng_ctx: *mut *const br_prng_class,
        sk: *mut br_rsa_private_key,
        kbuf_priv: *mut cty::c_void,
        pk: *mut br_rsa_public_key,
        kbuf_pub: *mut cty::c_void,
        size: cty::c_uint,
        pubexp: u32,
    ) -> u32,
>;
extern "C" {
    #[doc = " \\brief RSA key pair generation with the \"i15\" engine."]
    #[doc = ""]
    #[doc = " \\see br_rsa_keygen"]
    #[doc = ""]
    #[doc = " \\param rng_ctx     source PRNG context (already initialized)"]
    #[doc = " \\param sk          RSA private key structure (destination)"]
    #[doc = " \\param kbuf_priv   buffer for private key elements"]
    #[doc = " \\param pk          RSA public key structure (destination), or `NULL`"]
    #[doc = " \\param kbuf_pub    buffer for public key elements, or `NULL`"]
    #[doc = " \\param size        target RSA modulus size (in bits)"]
    #[doc = " \\param pubexp      public exponent to use, or zero"]
    #[doc = " \\return  1 on success, 0 on error (invalid parameters)"]
    pub fn br_rsa_i15_keygen(
        rng_ctx: *mut *const br_prng_class,
        sk: *mut br_rsa_private_key,
        kbuf_priv: *mut cty::c_void,
        pk: *mut br_rsa_public_key,
        kbuf_pub: *mut cty::c_void,
        size: cty::c_uint,
        pubexp: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA key pair generation with the \"i31\" engine."]
    #[doc = ""]
    #[doc = " \\see br_rsa_keygen"]
    #[doc = ""]
    #[doc = " \\param rng_ctx     source PRNG context (already initialized)"]
    #[doc = " \\param sk          RSA private key structure (destination)"]
    #[doc = " \\param kbuf_priv   buffer for private key elements"]
    #[doc = " \\param pk          RSA public key structure (destination), or `NULL`"]
    #[doc = " \\param kbuf_pub    buffer for public key elements, or `NULL`"]
    #[doc = " \\param size        target RSA modulus size (in bits)"]
    #[doc = " \\param pubexp      public exponent to use, or zero"]
    #[doc = " \\return  1 on success, 0 on error (invalid parameters)"]
    pub fn br_rsa_i31_keygen(
        rng_ctx: *mut *const br_prng_class,
        sk: *mut br_rsa_private_key,
        kbuf_priv: *mut cty::c_void,
        pk: *mut br_rsa_public_key,
        kbuf_pub: *mut cty::c_void,
        size: cty::c_uint,
        pubexp: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief RSA key pair generation with the \"i62\" engine."]
    #[doc = ""]
    #[doc = " This function is defined only on architecture that offer a 64x64->128"]
    #[doc = " opcode. Use `br_rsa_i62_keygen_get()` to dynamically obtain a pointer"]
    #[doc = " to that function."]
    #[doc = ""]
    #[doc = " \\see br_rsa_keygen"]
    #[doc = ""]
    #[doc = " \\param rng_ctx     source PRNG context (already initialized)"]
    #[doc = " \\param sk          RSA private key structure (destination)"]
    #[doc = " \\param kbuf_priv   buffer for private key elements"]
    #[doc = " \\param pk          RSA public key structure (destination), or `NULL`"]
    #[doc = " \\param kbuf_pub    buffer for public key elements, or `NULL`"]
    #[doc = " \\param size        target RSA modulus size (in bits)"]
    #[doc = " \\param pubexp      public exponent to use, or zero"]
    #[doc = " \\return  1 on success, 0 on error (invalid parameters)"]
    pub fn br_rsa_i62_keygen(
        rng_ctx: *mut *const br_prng_class,
        sk: *mut br_rsa_private_key,
        kbuf_priv: *mut cty::c_void,
        pk: *mut br_rsa_public_key,
        kbuf_pub: *mut cty::c_void,
        size: cty::c_uint,
        pubexp: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief Get the RSA \"i62\" implementation (key pair generation),"]
    #[doc = " if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_rsa_i62_keygen_get() -> br_rsa_keygen;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (key pair generation)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (key pair generation)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_keygen_get_default() -> br_rsa_keygen;
}
#[doc = " \\brief Type for a modulus computing function."]
#[doc = ""]
#[doc = " Such a function computes the public modulus from the private key. The"]
#[doc = " encoded modulus (unsigned big-endian) is written on `n`, and the size"]
#[doc = " (in bytes) is returned. If `n` is `NULL`, then the size is returned but"]
#[doc = " the modulus itself is not computed."]
#[doc = ""]
#[doc = " If the key size exceeds an internal limit, 0 is returned."]
#[doc = ""]
#[doc = " \\param n    destination buffer (or `NULL`)."]
#[doc = " \\param sk   RSA private key."]
#[doc = " \\return  the modulus length (in bytes), or 0."]
pub type br_rsa_compute_modulus = ::core::option::Option<
    unsafe extern "C" fn(n: *mut cty::c_void, sk: *const br_rsa_private_key) -> usize,
>;
extern "C" {
    #[doc = " \\brief Recompute RSA modulus (\"i15\" engine)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_compute_modulus"]
    #[doc = ""]
    #[doc = " \\param n    destination buffer (or `NULL`)."]
    #[doc = " \\param sk   RSA private key."]
    #[doc = " \\return  the modulus length (in bytes), or 0."]
    pub fn br_rsa_i15_compute_modulus(n: *mut cty::c_void, sk: *const br_rsa_private_key) -> usize;
}
extern "C" {
    #[doc = " \\brief Recompute RSA modulus (\"i31\" engine)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_compute_modulus"]
    #[doc = ""]
    #[doc = " \\param n    destination buffer (or `NULL`)."]
    #[doc = " \\param sk   RSA private key."]
    #[doc = " \\return  the modulus length (in bytes), or 0."]
    pub fn br_rsa_i31_compute_modulus(n: *mut cty::c_void, sk: *const br_rsa_private_key) -> usize;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (recompute modulus)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (recompute modulus)"]
    #[doc = " on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_compute_modulus_get_default() -> br_rsa_compute_modulus;
}
#[doc = " \\brief Type for a public exponent computing function."]
#[doc = ""]
#[doc = " Such a function recomputes the public exponent from the private key."]
#[doc = " 0 is returned if any of the following occurs:"]
#[doc = ""]
#[doc = "   - Either `p` or `q` is not equal to 3 modulo 4."]
#[doc = ""]
#[doc = "   - The public exponent does not fit on 32 bits."]
#[doc = ""]
#[doc = "   - An internal limit is exceeded."]
#[doc = ""]
#[doc = "   - The private key is invalid in some way."]
#[doc = ""]
#[doc = " For all private keys produced by the key generator functions"]
#[doc = " (`br_rsa_keygen` type), this function succeeds and returns the true"]
#[doc = " public exponent. The public exponent is always an odd integer greater"]
#[doc = " than 1."]
#[doc = ""]
#[doc = " \\return  the public exponent, or 0."]
pub type br_rsa_compute_pubexp =
    ::core::option::Option<unsafe extern "C" fn(sk: *const br_rsa_private_key) -> u32>;
extern "C" {
    #[doc = " \\brief Recompute RSA public exponent (\"i15\" engine)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_compute_pubexp"]
    #[doc = ""]
    #[doc = " \\return  the public exponent, or 0."]
    pub fn br_rsa_i15_compute_pubexp(sk: *const br_rsa_private_key) -> u32;
}
extern "C" {
    #[doc = " \\brief Recompute RSA public exponent (\"i31\" engine)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_compute_pubexp"]
    #[doc = ""]
    #[doc = " \\return  the public exponent, or 0."]
    pub fn br_rsa_i31_compute_pubexp(sk: *const br_rsa_private_key) -> u32;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (recompute public exponent)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (recompute public"]
    #[doc = " exponent) on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_compute_pubexp_get_default() -> br_rsa_compute_pubexp;
}
#[doc = " \\brief Type for a private exponent computing function."]
#[doc = ""]
#[doc = " An RSA private key (`br_rsa_private_key`) contains two reduced"]
#[doc = " private exponents, which are sufficient to perform private key"]
#[doc = " operations. However, standard encoding formats for RSA private keys"]
#[doc = " require also a copy of the complete private exponent (non-reduced),"]
#[doc = " which this function recomputes."]
#[doc = ""]
#[doc = " This function suceeds if all the following conditions hold:"]
#[doc = ""]
#[doc = "   - Both private factors `p` and `q` are equal to 3 modulo 4."]
#[doc = ""]
#[doc = "   - The provided public exponent `pubexp` is correct, and, in particular,"]
#[doc = "     is odd, relatively prime to `p-1` and `q-1`, and greater than 1."]
#[doc = ""]
#[doc = "   - No internal storage limit is exceeded."]
#[doc = ""]
#[doc = " For all private keys produced by the key generator functions"]
#[doc = " (`br_rsa_keygen` type), this function succeeds. Note that the API"]
#[doc = " restricts the public exponent to a maximum size of 32 bits."]
#[doc = ""]
#[doc = " The encoded private exponent is written in `d` (unsigned big-endian"]
#[doc = " convention), and the length (in bytes) is returned. If `d` is `NULL`,"]
#[doc = " then the exponent is not written anywhere, but the length is still"]
#[doc = " returned. On error, 0 is returned."]
#[doc = ""]
#[doc = " Not all error conditions are detected when `d` is `NULL`; therefore, the"]
#[doc = " returned value shall be checked also when actually producing the value."]
#[doc = ""]
#[doc = " \\param d        destination buffer (or `NULL`)."]
#[doc = " \\param sk       RSA private key."]
#[doc = " \\param pubexp   the public exponent."]
#[doc = " \\return  the private exponent length (in bytes), or 0."]
pub type br_rsa_compute_privexp = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cty::c_void, sk: *const br_rsa_private_key, pubexp: u32) -> usize,
>;
extern "C" {
    #[doc = " \\brief Recompute RSA private exponent (\"i15\" engine)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_compute_privexp"]
    #[doc = ""]
    #[doc = " \\param d        destination buffer (or `NULL`)."]
    #[doc = " \\param sk       RSA private key."]
    #[doc = " \\param pubexp   the public exponent."]
    #[doc = " \\return  the private exponent length (in bytes), or 0."]
    pub fn br_rsa_i15_compute_privexp(
        d: *mut cty::c_void,
        sk: *const br_rsa_private_key,
        pubexp: u32,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Recompute RSA private exponent (\"i31\" engine)."]
    #[doc = ""]
    #[doc = " \\see br_rsa_compute_privexp"]
    #[doc = ""]
    #[doc = " \\param d        destination buffer (or `NULL`)."]
    #[doc = " \\param sk       RSA private key."]
    #[doc = " \\param pubexp   the public exponent."]
    #[doc = " \\return  the private exponent length (in bytes), or 0."]
    pub fn br_rsa_i31_compute_privexp(
        d: *mut cty::c_void,
        sk: *const br_rsa_private_key,
        pubexp: u32,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Get \"default\" RSA implementation (recompute private exponent)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of RSA (recompute private"]
    #[doc = " exponent) on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_rsa_compute_privexp_get_default() -> br_rsa_compute_privexp;
}
#[doc = " \\brief Structure for an EC public key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ec_public_key {
    #[doc = " \\brief Identifier for the curve used by this key."]
    pub curve: cty::c_int,
    #[doc = " \\brief Public curve point (uncompressed format)."]
    pub q: *mut cty::c_uchar,
    #[doc = " \\brief Length of public curve point (in bytes)."]
    pub qlen: usize,
}
#[doc = " \\brief Structure for an EC private key."]
#[doc = ""]
#[doc = " The private key is an integer modulo the curve subgroup order. The"]
#[doc = " encoding below tolerates extra leading zeros. In general, it is"]
#[doc = " recommended that the private key has the same length as the curve"]
#[doc = " subgroup order."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ec_private_key {
    #[doc = " \\brief Identifier for the curve used by this key."]
    pub curve: cty::c_int,
    #[doc = " \\brief Private key (integer, unsigned big-endian encoding)."]
    pub x: *mut cty::c_uchar,
    #[doc = " \\brief Private key length (in bytes)."]
    pub xlen: usize,
}
#[doc = " \\brief Type for an EC implementation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ec_impl {
    #[doc = " \\brief Supported curves."]
    #[doc = ""]
    #[doc = " This word is a bitfield: bit `x` is set if the curve of ID `x`"]
    #[doc = " is supported. E.g. an implementation supporting both NIST P-256"]
    #[doc = " (secp256r1, ID 23) and NIST P-384 (secp384r1, ID 24) will have"]
    #[doc = " value `0x01800000` in this field."]
    pub supported_curves: u32,
    #[doc = " \\brief Get the conventional generator."]
    #[doc = ""]
    #[doc = " This function returns the conventional generator (encoded"]
    #[doc = " curve point) for the specified curve. This function MUST NOT"]
    #[doc = " be called if the curve is not supported."]
    #[doc = ""]
    #[doc = " \\param curve   curve identifier."]
    #[doc = " \\param len     receiver for the encoded generator length (in bytes)."]
    #[doc = " \\return  the encoded generator."]
    pub generator: ::core::option::Option<
        unsafe extern "C" fn(curve: cty::c_int, len: *mut usize) -> *const cty::c_uchar,
    >,
    #[doc = " \\brief Get the subgroup order."]
    #[doc = ""]
    #[doc = " This function returns the order of the subgroup generated by"]
    #[doc = " the conventional generator, for the specified curve. Unsigned"]
    #[doc = " big-endian encoding is used. This function MUST NOT be called"]
    #[doc = " if the curve is not supported."]
    #[doc = ""]
    #[doc = " \\param curve   curve identifier."]
    #[doc = " \\param len     receiver for the encoded order length (in bytes)."]
    #[doc = " \\return  the encoded order."]
    pub order: ::core::option::Option<
        unsafe extern "C" fn(curve: cty::c_int, len: *mut usize) -> *const cty::c_uchar,
    >,
    #[doc = " \\brief Get the offset and length for the X coordinate."]
    #[doc = ""]
    #[doc = " This function returns the offset and length (in bytes) of"]
    #[doc = " the X coordinate in an encoded non-zero point."]
    #[doc = ""]
    #[doc = " \\param curve   curve identifier."]
    #[doc = " \\param len     receiver for the X coordinate length (in bytes)."]
    #[doc = " \\return  the offset for the X coordinate (in bytes)."]
    pub xoff:
        ::core::option::Option<unsafe extern "C" fn(curve: cty::c_int, len: *mut usize) -> usize>,
    #[doc = " \\brief Multiply a curve point by an integer."]
    #[doc = ""]
    #[doc = " The source point is provided in array `G` (of size `Glen` bytes);"]
    #[doc = " the multiplication result is written over it. The multiplier"]
    #[doc = " `x` (of size `xlen` bytes) uses unsigned big-endian encoding."]
    #[doc = ""]
    #[doc = " Rules:"]
    #[doc = ""]
    #[doc = "   - The specified curve MUST be supported."]
    #[doc = ""]
    #[doc = "   - The source point must be a valid point on the relevant curve"]
    #[doc = "     subgroup (and not the \"point at infinity\" either). If this is"]
    #[doc = "     not the case, then this function returns an error (0)."]
    #[doc = ""]
    #[doc = "   - The multiplier integer MUST be non-zero and less than the"]
    #[doc = "     curve subgroup order. If this property does not hold, then"]
    #[doc = "     the result is indeterminate and an error code is not"]
    #[doc = "     guaranteed."]
    #[doc = ""]
    #[doc = " Returned value is 1 on success, 0 on error. On error, the"]
    #[doc = " contents of `G` are indeterminate."]
    #[doc = ""]
    #[doc = " \\param G       point to multiply."]
    #[doc = " \\param Glen    length of the encoded point (in bytes)."]
    #[doc = " \\param x       multiplier (unsigned big-endian)."]
    #[doc = " \\param xlen    multiplier length (in bytes)."]
    #[doc = " \\param curve   curve identifier."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub mul: ::core::option::Option<
        unsafe extern "C" fn(
            G: *mut cty::c_uchar,
            Glen: usize,
            x: *const cty::c_uchar,
            xlen: usize,
            curve: cty::c_int,
        ) -> u32,
    >,
    #[doc = " \\brief Multiply the generator by an integer."]
    #[doc = ""]
    #[doc = " The multiplier MUST be non-zero and less than the curve"]
    #[doc = " subgroup order. Results are indeterminate if this property"]
    #[doc = " does not hold."]
    #[doc = ""]
    #[doc = " \\param R       output buffer for the point."]
    #[doc = " \\param x       multiplier (unsigned big-endian)."]
    #[doc = " \\param xlen    multiplier length (in bytes)."]
    #[doc = " \\param curve   curve identifier."]
    #[doc = " \\return  encoded result point length (in bytes)."]
    pub mulgen: ::core::option::Option<
        unsafe extern "C" fn(
            R: *mut cty::c_uchar,
            x: *const cty::c_uchar,
            xlen: usize,
            curve: cty::c_int,
        ) -> usize,
    >,
    #[doc = " \\brief Multiply two points by two integers and add the"]
    #[doc = " results."]
    #[doc = ""]
    #[doc = " The point `x*A + y*B` is computed and written back in the `A`"]
    #[doc = " array."]
    #[doc = ""]
    #[doc = " Rules:"]
    #[doc = ""]
    #[doc = "   - The specified curve MUST be supported."]
    #[doc = ""]
    #[doc = "   - The source points (`A` and `B`)  must be valid points on"]
    #[doc = "     the relevant curve subgroup (and not the \"point at"]
    #[doc = "     infinity\" either). If this is not the case, then this"]
    #[doc = "     function returns an error (0)."]
    #[doc = ""]
    #[doc = "   - If the `B` pointer is `NULL`, then the conventional"]
    #[doc = "     subgroup generator is used. With some implementations,"]
    #[doc = "     this may be faster than providing a pointer to the"]
    #[doc = "     generator."]
    #[doc = ""]
    #[doc = "   - The multiplier integers (`x` and `y`) MUST be non-zero"]
    #[doc = "     and less than the curve subgroup order. If either integer"]
    #[doc = "     is zero, then an error is reported, but if one of them is"]
    #[doc = "     not lower than the subgroup order, then the result is"]
    #[doc = "     indeterminate and an error code is not guaranteed."]
    #[doc = ""]
    #[doc = "   - If the final result is the point at infinity, then an"]
    #[doc = "     error is returned."]
    #[doc = ""]
    #[doc = " Returned value is 1 on success, 0 on error. On error, the"]
    #[doc = " contents of `A` are indeterminate."]
    #[doc = ""]
    #[doc = " \\param A       first point to multiply."]
    #[doc = " \\param B       second point to multiply (`NULL` for the generator)."]
    #[doc = " \\param len     common length of the encoded points (in bytes)."]
    #[doc = " \\param x       multiplier for `A` (unsigned big-endian)."]
    #[doc = " \\param xlen    length of multiplier for `A` (in bytes)."]
    #[doc = " \\param y       multiplier for `A` (unsigned big-endian)."]
    #[doc = " \\param ylen    length of multiplier for `A` (in bytes)."]
    #[doc = " \\param curve   curve identifier."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub muladd: ::core::option::Option<
        unsafe extern "C" fn(
            A: *mut cty::c_uchar,
            B: *const cty::c_uchar,
            len: usize,
            x: *const cty::c_uchar,
            xlen: usize,
            y: *const cty::c_uchar,
            ylen: usize,
            curve: cty::c_int,
        ) -> u32,
    >,
}
extern "C" {
    pub static br_ec_prime_i31: br_ec_impl;
}
extern "C" {
    pub static br_ec_prime_i15: br_ec_impl;
}
extern "C" {
    pub static br_ec_p256_m15: br_ec_impl;
}
extern "C" {
    pub static br_ec_p256_m31: br_ec_impl;
}
extern "C" {
    pub static br_ec_p256_m62: br_ec_impl;
}
extern "C" {
    #[doc = " \\brief Get the \"m62\" implementation of P-256, if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_ec_p256_m62_get() -> *const br_ec_impl;
}
extern "C" {
    pub static br_ec_p256_m64: br_ec_impl;
}
extern "C" {
    #[doc = " \\brief Get the \"m64\" implementation of P-256, if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_ec_p256_m64_get() -> *const br_ec_impl;
}
extern "C" {
    pub static br_ec_c25519_i15: br_ec_impl;
}
extern "C" {
    pub static br_ec_c25519_i31: br_ec_impl;
}
extern "C" {
    pub static br_ec_c25519_m15: br_ec_impl;
}
extern "C" {
    pub static br_ec_c25519_m31: br_ec_impl;
}
extern "C" {
    pub static br_ec_c25519_m62: br_ec_impl;
}
extern "C" {
    #[doc = " \\brief Get the \"m62\" implementation of Curve25519, if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_ec_c25519_m62_get() -> *const br_ec_impl;
}
extern "C" {
    pub static br_ec_c25519_m64: br_ec_impl;
}
extern "C" {
    #[doc = " \\brief Get the \"m64\" implementation of Curve25519, if available."]
    #[doc = ""]
    #[doc = " \\return  the implementation, or 0."]
    pub fn br_ec_c25519_m64_get() -> *const br_ec_impl;
}
extern "C" {
    pub static br_ec_all_m15: br_ec_impl;
}
extern "C" {
    pub static br_ec_all_m31: br_ec_impl;
}
extern "C" {
    #[doc = " \\brief Get the \"default\" EC implementation for the current system."]
    #[doc = ""]
    #[doc = " This returns a pointer to the preferred implementation on the"]
    #[doc = " current system."]
    #[doc = ""]
    #[doc = " \\return  the default EC implementation."]
    pub fn br_ec_get_default() -> *const br_ec_impl;
}
extern "C" {
    #[doc = " \\brief Convert a signature from \"raw\" to \"asn1\"."]
    #[doc = ""]
    #[doc = " Conversion is done \"in place\" and the new length is returned."]
    #[doc = " Conversion may enlarge the signature, but by no more than 9 bytes at"]
    #[doc = " most. On error, 0 is returned (error conditions include an odd raw"]
    #[doc = " signature length, or an oversized integer)."]
    #[doc = ""]
    #[doc = " \\param sig       signature to convert."]
    #[doc = " \\param sig_len   signature length (in bytes)."]
    #[doc = " \\return  the new signature length, or 0 on error."]
    pub fn br_ecdsa_raw_to_asn1(sig: *mut cty::c_void, sig_len: usize) -> usize;
}
extern "C" {
    #[doc = " \\brief Convert a signature from \"asn1\" to \"raw\"."]
    #[doc = ""]
    #[doc = " Conversion is done \"in place\" and the new length is returned."]
    #[doc = " Conversion may enlarge the signature, but the new signature length"]
    #[doc = " will be less than twice the source length at most. On error, 0 is"]
    #[doc = " returned (error conditions include an invalid ASN.1 structure or an"]
    #[doc = " oversized integer)."]
    #[doc = ""]
    #[doc = " \\param sig       signature to convert."]
    #[doc = " \\param sig_len   signature length (in bytes)."]
    #[doc = " \\return  the new signature length, or 0 on error."]
    pub fn br_ecdsa_asn1_to_raw(sig: *mut cty::c_void, sig_len: usize) -> usize;
}
#[doc = " \\brief Type for an ECDSA signer function."]
#[doc = ""]
#[doc = " A pointer to the EC implementation is provided. The hash value is"]
#[doc = " assumed to have the length inferred from the designated hash function"]
#[doc = " class."]
#[doc = ""]
#[doc = " Signature is written in the buffer pointed to by `sig`, and the length"]
#[doc = " (in bytes) is returned. On error, nothing is written in the buffer,"]
#[doc = " and 0 is returned. This function returns 0 if the specified curve is"]
#[doc = " not supported by the provided EC implementation."]
#[doc = ""]
#[doc = " The signature format is either \"raw\" or \"asn1\", depending on the"]
#[doc = " implementation; maximum length is predictable from the implemented"]
#[doc = " curve:"]
#[doc = ""]
#[doc = " | curve      | raw | asn1 |"]
#[doc = " | :--------- | --: | ---: |"]
#[doc = " | NIST P-256 |  64 |   72 |"]
#[doc = " | NIST P-384 |  96 |  104 |"]
#[doc = " | NIST P-521 | 132 |  139 |"]
#[doc = ""]
#[doc = " \\param impl         EC implementation to use."]
#[doc = " \\param hf           hash function used to process the data."]
#[doc = " \\param hash_value   signed data (hashed)."]
#[doc = " \\param sk           EC private key."]
#[doc = " \\param sig          destination buffer."]
#[doc = " \\return  the signature length (in bytes), or 0 on error."]
pub type br_ecdsa_sign = ::core::option::Option<
    unsafe extern "C" fn(
        impl_: *const br_ec_impl,
        hf: *const br_hash_class,
        hash_value: *const cty::c_void,
        sk: *const br_ec_private_key,
        sig: *mut cty::c_void,
    ) -> usize,
>;
#[doc = " \\brief Type for an ECDSA signature verification function."]
#[doc = ""]
#[doc = " A pointer to the EC implementation is provided. The hashed value,"]
#[doc = " computed over the purportedly signed data, is also provided with"]
#[doc = " its length."]
#[doc = ""]
#[doc = " The signature format is either \"raw\" or \"asn1\", depending on the"]
#[doc = " implementation."]
#[doc = ""]
#[doc = " Returned value is 1 on success (valid signature), 0 on error. This"]
#[doc = " function returns 0 if the specified curve is not supported by the"]
#[doc = " provided EC implementation."]
#[doc = ""]
#[doc = " \\param impl       EC implementation to use."]
#[doc = " \\param hash       signed data (hashed)."]
#[doc = " \\param hash_len   hash value length (in bytes)."]
#[doc = " \\param pk         EC public key."]
#[doc = " \\param sig        signature."]
#[doc = " \\param sig_len    signature length (in bytes)."]
#[doc = " \\return  1 on success, 0 on error."]
pub type br_ecdsa_vrfy = ::core::option::Option<
    unsafe extern "C" fn(
        impl_: *const br_ec_impl,
        hash: *const cty::c_void,
        hash_len: usize,
        pk: *const br_ec_public_key,
        sig: *const cty::c_void,
        sig_len: usize,
    ) -> u32,
>;
extern "C" {
    #[doc = " \\brief ECDSA signature generator, \"i31\" implementation, \"asn1\" format."]
    #[doc = ""]
    #[doc = " \\see br_ecdsa_sign()"]
    #[doc = ""]
    #[doc = " \\param impl         EC implementation to use."]
    #[doc = " \\param hf           hash function used to process the data."]
    #[doc = " \\param hash_value   signed data (hashed)."]
    #[doc = " \\param sk           EC private key."]
    #[doc = " \\param sig          destination buffer."]
    #[doc = " \\return  the signature length (in bytes), or 0 on error."]
    pub fn br_ecdsa_i31_sign_asn1(
        impl_: *const br_ec_impl,
        hf: *const br_hash_class,
        hash_value: *const cty::c_void,
        sk: *const br_ec_private_key,
        sig: *mut cty::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief ECDSA signature generator, \"i31\" implementation, \"raw\" format."]
    #[doc = ""]
    #[doc = " \\see br_ecdsa_sign()"]
    #[doc = ""]
    #[doc = " \\param impl         EC implementation to use."]
    #[doc = " \\param hf           hash function used to process the data."]
    #[doc = " \\param hash_value   signed data (hashed)."]
    #[doc = " \\param sk           EC private key."]
    #[doc = " \\param sig          destination buffer."]
    #[doc = " \\return  the signature length (in bytes), or 0 on error."]
    pub fn br_ecdsa_i31_sign_raw(
        impl_: *const br_ec_impl,
        hf: *const br_hash_class,
        hash_value: *const cty::c_void,
        sk: *const br_ec_private_key,
        sig: *mut cty::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief ECDSA signature verifier, \"i31\" implementation, \"asn1\" format."]
    #[doc = ""]
    #[doc = " \\see br_ecdsa_vrfy()"]
    #[doc = ""]
    #[doc = " \\param impl       EC implementation to use."]
    #[doc = " \\param hash       signed data (hashed)."]
    #[doc = " \\param hash_len   hash value length (in bytes)."]
    #[doc = " \\param pk         EC public key."]
    #[doc = " \\param sig        signature."]
    #[doc = " \\param sig_len    signature length (in bytes)."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_ecdsa_i31_vrfy_asn1(
        impl_: *const br_ec_impl,
        hash: *const cty::c_void,
        hash_len: usize,
        pk: *const br_ec_public_key,
        sig: *const cty::c_void,
        sig_len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief ECDSA signature verifier, \"i31\" implementation, \"raw\" format."]
    #[doc = ""]
    #[doc = " \\see br_ecdsa_vrfy()"]
    #[doc = ""]
    #[doc = " \\param impl       EC implementation to use."]
    #[doc = " \\param hash       signed data (hashed)."]
    #[doc = " \\param hash_len   hash value length (in bytes)."]
    #[doc = " \\param pk         EC public key."]
    #[doc = " \\param sig        signature."]
    #[doc = " \\param sig_len    signature length (in bytes)."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_ecdsa_i31_vrfy_raw(
        impl_: *const br_ec_impl,
        hash: *const cty::c_void,
        hash_len: usize,
        pk: *const br_ec_public_key,
        sig: *const cty::c_void,
        sig_len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief ECDSA signature generator, \"i15\" implementation, \"asn1\" format."]
    #[doc = ""]
    #[doc = " \\see br_ecdsa_sign()"]
    #[doc = ""]
    #[doc = " \\param impl         EC implementation to use."]
    #[doc = " \\param hf           hash function used to process the data."]
    #[doc = " \\param hash_value   signed data (hashed)."]
    #[doc = " \\param sk           EC private key."]
    #[doc = " \\param sig          destination buffer."]
    #[doc = " \\return  the signature length (in bytes), or 0 on error."]
    pub fn br_ecdsa_i15_sign_asn1(
        impl_: *const br_ec_impl,
        hf: *const br_hash_class,
        hash_value: *const cty::c_void,
        sk: *const br_ec_private_key,
        sig: *mut cty::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief ECDSA signature generator, \"i15\" implementation, \"raw\" format."]
    #[doc = ""]
    #[doc = " \\see br_ecdsa_sign()"]
    #[doc = ""]
    #[doc = " \\param impl         EC implementation to use."]
    #[doc = " \\param hf           hash function used to process the data."]
    #[doc = " \\param hash_value   signed data (hashed)."]
    #[doc = " \\param sk           EC private key."]
    #[doc = " \\param sig          destination buffer."]
    #[doc = " \\return  the signature length (in bytes), or 0 on error."]
    pub fn br_ecdsa_i15_sign_raw(
        impl_: *const br_ec_impl,
        hf: *const br_hash_class,
        hash_value: *const cty::c_void,
        sk: *const br_ec_private_key,
        sig: *mut cty::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief ECDSA signature verifier, \"i15\" implementation, \"asn1\" format."]
    #[doc = ""]
    #[doc = " \\see br_ecdsa_vrfy()"]
    #[doc = ""]
    #[doc = " \\param impl       EC implementation to use."]
    #[doc = " \\param hash       signed data (hashed)."]
    #[doc = " \\param hash_len   hash value length (in bytes)."]
    #[doc = " \\param pk         EC public key."]
    #[doc = " \\param sig        signature."]
    #[doc = " \\param sig_len    signature length (in bytes)."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_ecdsa_i15_vrfy_asn1(
        impl_: *const br_ec_impl,
        hash: *const cty::c_void,
        hash_len: usize,
        pk: *const br_ec_public_key,
        sig: *const cty::c_void,
        sig_len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief ECDSA signature verifier, \"i15\" implementation, \"raw\" format."]
    #[doc = ""]
    #[doc = " \\see br_ecdsa_vrfy()"]
    #[doc = ""]
    #[doc = " \\param impl       EC implementation to use."]
    #[doc = " \\param hash       signed data (hashed)."]
    #[doc = " \\param hash_len   hash value length (in bytes)."]
    #[doc = " \\param pk         EC public key."]
    #[doc = " \\param sig        signature."]
    #[doc = " \\param sig_len    signature length (in bytes)."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_ecdsa_i15_vrfy_raw(
        impl_: *const br_ec_impl,
        hash: *const cty::c_void,
        hash_len: usize,
        pk: *const br_ec_public_key,
        sig: *const cty::c_void,
        sig_len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief Get \"default\" ECDSA implementation (signer, asn1 format)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of ECDSA signature generation"]
    #[doc = " (\"asn1\" output format) on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_ecdsa_sign_asn1_get_default() -> br_ecdsa_sign;
}
extern "C" {
    #[doc = " \\brief Get \"default\" ECDSA implementation (signer, raw format)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of ECDSA signature generation"]
    #[doc = " (\"raw\" output format) on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_ecdsa_sign_raw_get_default() -> br_ecdsa_sign;
}
extern "C" {
    #[doc = " \\brief Get \"default\" ECDSA implementation (verifier, asn1 format)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of ECDSA signature verification"]
    #[doc = " (\"asn1\" output format) on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_ecdsa_vrfy_asn1_get_default() -> br_ecdsa_vrfy;
}
extern "C" {
    #[doc = " \\brief Get \"default\" ECDSA implementation (verifier, raw format)."]
    #[doc = ""]
    #[doc = " This returns the preferred implementation of ECDSA signature verification"]
    #[doc = " (\"raw\" output format) on the current system."]
    #[doc = ""]
    #[doc = " \\return  the default implementation."]
    pub fn br_ecdsa_vrfy_raw_get_default() -> br_ecdsa_vrfy;
}
extern "C" {
    #[doc = " \\brief Generate a new EC private key."]
    #[doc = ""]
    #[doc = " If the specified `curve` is not supported by the elliptic curve"]
    #[doc = " implementation (`impl`), then this function returns zero."]
    #[doc = ""]
    #[doc = " The `sk` structure fields are set to the new private key data. In"]
    #[doc = " particular, `sk.x` is made to point to the provided key buffer (`kbuf`),"]
    #[doc = " in which the actual private key data is written. That buffer is assumed"]
    #[doc = " to be large enough. The `BR_EC_KBUF_PRIV_MAX_SIZE` defines the maximum"]
    #[doc = " size for all supported curves."]
    #[doc = ""]
    #[doc = " The number of bytes used in `kbuf` is returned. If `kbuf` is `NULL`, then"]
    #[doc = " the private key is not actually generated, and `sk` may also be `NULL`;"]
    #[doc = " the minimum length for `kbuf` is still computed and returned."]
    #[doc = ""]
    #[doc = " If `sk` is `NULL` but `kbuf` is not `NULL`, then the private key is"]
    #[doc = " still generated and stored in `kbuf`."]
    #[doc = ""]
    #[doc = " \\param rng_ctx   source PRNG context (already initialized)."]
    #[doc = " \\param impl      the elliptic curve implementation."]
    #[doc = " \\param sk        the private key structure to fill, or `NULL`."]
    #[doc = " \\param kbuf      the key element buffer, or `NULL`."]
    #[doc = " \\param curve     the curve identifier."]
    #[doc = " \\return  the key data length (in bytes), or zero."]
    pub fn br_ec_keygen(
        rng_ctx: *mut *const br_prng_class,
        impl_: *const br_ec_impl,
        sk: *mut br_ec_private_key,
        kbuf: *mut cty::c_void,
        curve: cty::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Compute EC public key from EC private key."]
    #[doc = ""]
    #[doc = " This function uses the provided elliptic curve implementation (`impl`)"]
    #[doc = " to compute the public key corresponding to the private key held in `sk`."]
    #[doc = " The public key point is written into `kbuf`, which is then linked from"]
    #[doc = " the `*pk` structure. The size of the public key point, i.e. the number"]
    #[doc = " of bytes used in `kbuf`, is returned."]
    #[doc = ""]
    #[doc = " If `kbuf` is `NULL`, then the public key point is NOT computed, and"]
    #[doc = " the public key structure `*pk` is unmodified (`pk` may be `NULL` in"]
    #[doc = " that case). The size of the public key point is still returned."]
    #[doc = ""]
    #[doc = " If `pk` is `NULL` but `kbuf` is not `NULL`, then the public key"]
    #[doc = " point is computed and stored in `kbuf`, and its size is returned."]
    #[doc = ""]
    #[doc = " If the curve used by the private key is not supported by the curve"]
    #[doc = " implementation, then this function returns zero."]
    #[doc = ""]
    #[doc = " The private key MUST be valid. An off-range private key value is not"]
    #[doc = " necessarily detected, and leads to unpredictable results."]
    #[doc = ""]
    #[doc = " \\param impl   the elliptic curve implementation."]
    #[doc = " \\param pk     the public key structure to fill (or `NULL`)."]
    #[doc = " \\param kbuf   the public key point buffer (or `NULL`)."]
    #[doc = " \\param sk     the source private key."]
    #[doc = " \\return  the public key point length (in bytes), or zero."]
    pub fn br_ec_compute_pub(
        impl_: *const br_ec_impl,
        pk: *mut br_ec_public_key,
        kbuf: *mut cty::c_void,
        sk: *const br_ec_private_key,
    ) -> usize;
}
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: cty::c_int,
    pub tm_min: cty::c_int,
    pub tm_hour: cty::c_int,
    pub tm_mday: cty::c_int,
    pub tm_mon: cty::c_int,
    pub tm_year: cty::c_int,
    pub tm_wday: cty::c_int,
    pub tm_yday: cty::c_int,
    pub tm_isdst: cty::c_int,
    pub tm_gmtoff: cty::c_long,
    pub tm_zone: *const cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut cty::c_char,
        __maxsize: usize,
        __format: *const cty::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut cty::c_char,
        __maxsize: usize,
        __format: *const cty::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut cty::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: cty::c_int;
}
extern "C" {
    pub static mut __timezone: cty::c_long;
}
extern "C" {
    pub static mut tzname: [*mut cty::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: cty::c_int;
}
extern "C" {
    pub static mut timezone: cty::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> cty::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: cty::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> cty::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: cty::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> cty::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn set_time_callback(get_time: ::core::option::Option<unsafe extern "C" fn() -> time_t>);
}
#[doc = " \\brief Aggregate structure for public keys."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_x509_pkey {
    #[doc = " \\brief Key type: `BR_KEYTYPE_RSA` or `BR_KEYTYPE_EC`"]
    pub key_type: cty::c_uchar,
    pub key: br_x509_pkey__bindgen_ty_1,
}
#[doc = " \\brief Actual public key."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_x509_pkey__bindgen_ty_1 {
    #[doc = " \\brief RSA public key."]
    pub rsa: br_rsa_public_key,
    #[doc = " \\brief EC public key."]
    pub ec: br_ec_public_key,
    _bindgen_union_align: [u32; 4usize],
}
#[doc = " \\brief Distinguished Name (X.500) structure."]
#[doc = ""]
#[doc = " The DN is DER-encoded."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_x500_name {
    #[doc = " \\brief Encoded DN data."]
    pub data: *mut cty::c_uchar,
    #[doc = " \\brief Encoded DN length (in bytes)."]
    pub len: usize,
}
#[doc = " \\brief Trust anchor structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_x509_trust_anchor {
    #[doc = " \\brief Encoded DN (X.500 name)."]
    pub dn: br_x500_name,
    #[doc = " \\brief Anchor flags (e.g. `BR_X509_TA_CA`)."]
    pub flags: cty::c_uint,
    #[doc = " \\brief Anchor public key."]
    pub pkey: br_x509_pkey,
}
#[doc = " \\brief Class type for an X.509 engine."]
#[doc = ""]
#[doc = " A certificate chain validation uses a caller-allocated context, which"]
#[doc = " contains the running state for that validation. Methods are called"]
#[doc = " in due order:"]
#[doc = ""]
#[doc = "   - `start_chain()` is called at the start of the validation."]
#[doc = "   - Certificates are processed one by one, in SSL order (end-entity"]
#[doc = "     comes first). For each certificate, the following methods are"]
#[doc = "     called:"]
#[doc = ""]
#[doc = "       - `start_cert()` at the beginning of the certificate."]
#[doc = "       - `append()` is called zero, one or more times, to provide"]
#[doc = "         the certificate (possibly in chunks)."]
#[doc = "       - `end_cert()` at the end of the certificate."]
#[doc = ""]
#[doc = "   - `end_chain()` is called when the last certificate in the chain"]
#[doc = "     was processed."]
#[doc = "   - `get_pkey()` is called after chain processing, if the chain"]
#[doc = "     validation was successful."]
#[doc = ""]
#[doc = " A context structure may be reused; the `start_chain()` method shall"]
#[doc = " ensure (re)initialisation."]
pub type br_x509_class = br_x509_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_x509_class_ {
    #[doc = " \\brief X.509 context size, in bytes."]
    pub context_size: usize,
    #[doc = " \\brief Start a new chain."]
    #[doc = ""]
    #[doc = " This method shall set the vtable (first field) of the context"]
    #[doc = " structure."]
    #[doc = ""]
    #[doc = " The `server_name`, if not `NULL`, will be considered as a"]
    #[doc = " fully qualified domain name, to be matched against the `dNSName`"]
    #[doc = " elements of the end-entity certificate's SAN extension (if there"]
    #[doc = " is no SAN, then the Common Name from the subjectDN will be used)."]
    #[doc = " If `server_name` is `NULL` then no such matching is performed."]
    #[doc = ""]
    #[doc = " \\param ctx           validation context."]
    #[doc = " \\param server_name   server name to match (or `NULL`)."]
    pub start_chain: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut *const br_x509_class, server_name: *const cty::c_char),
    >,
    #[doc = " \\brief Start a new certificate."]
    #[doc = ""]
    #[doc = " \\param ctx      validation context."]
    #[doc = " \\param length   new certificate length (in bytes)."]
    pub start_cert:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut *const br_x509_class, length: u32)>,
    #[doc = " \\brief Receive some bytes for the current certificate."]
    #[doc = ""]
    #[doc = " This function may be called several times in succession for"]
    #[doc = " a given certificate. The caller guarantees that for each"]
    #[doc = " call, `len` is not zero, and the sum of all chunk lengths"]
    #[doc = " for a certificate matches the total certificate length which"]
    #[doc = " was provided in the previous `start_cert()` call."]
    #[doc = ""]
    #[doc = " If the new certificate is empty (no byte at all) then this"]
    #[doc = " function won't be called at all."]
    #[doc = ""]
    #[doc = " \\param ctx   validation context."]
    #[doc = " \\param buf   certificate data chunk."]
    #[doc = " \\param len   certificate data chunk length (in bytes)."]
    pub append: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut *const br_x509_class, buf: *const cty::c_uchar, len: usize),
    >,
    #[doc = " \\brief Finish the current certificate."]
    #[doc = ""]
    #[doc = " This function is called when the end of the current certificate"]
    #[doc = " is reached."]
    #[doc = ""]
    #[doc = " \\param ctx   validation context."]
    pub end_cert: ::core::option::Option<unsafe extern "C" fn(ctx: *mut *const br_x509_class)>,
    #[doc = " \\brief Finish the chain."]
    #[doc = ""]
    #[doc = " This function is called at the end of the chain. It shall"]
    #[doc = " return either 0 if the validation was successful, or a"]
    #[doc = " non-zero error code. The `BR_ERR_X509_*` constants are"]
    #[doc = " error codes, though other values may be possible."]
    #[doc = ""]
    #[doc = " \\param ctx   validation context."]
    #[doc = " \\return  0 on success, or a non-zero error code."]
    pub end_chain:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut *const br_x509_class) -> cty::c_uint>,
    #[doc = " \\brief Get the resulting end-entity public key."]
    #[doc = ""]
    #[doc = " The decoded public key is returned. The returned pointer"]
    #[doc = " may be valid only as long as the context structure is"]
    #[doc = " unmodified, i.e. it may cease to be valid if the context"]
    #[doc = " is released or reused."]
    #[doc = ""]
    #[doc = " This function _may_ return `NULL` if the validation failed."]
    #[doc = " However, returning a public key does not mean that the"]
    #[doc = " validation was wholly successful; some engines may return"]
    #[doc = " a decoded public key even if the chain did not end on a"]
    #[doc = " trusted anchor."]
    #[doc = ""]
    #[doc = " If validation succeeded and `usage` is not `NULL`, then"]
    #[doc = " `*usage` is filled with a combination of `BR_KEYTYPE_SIGN`"]
    #[doc = " and/or `BR_KEYTYPE_KEYX` that specifies the validated key"]
    #[doc = " usage types. It is the caller's responsibility to check"]
    #[doc = " that value against the intended use of the public key."]
    #[doc = ""]
    #[doc = " \\param ctx   validation context."]
    #[doc = " \\return  the end-entity public key, or `NULL`."]
    pub get_pkey: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_x509_class,
            usages: *mut cty::c_uint,
        ) -> *const br_x509_pkey,
    >,
}
#[doc = " \\brief The \"known key\" X.509 engine structure."]
#[doc = ""]
#[doc = " The structure contents are opaque (they shall not be accessed directly),"]
#[doc = " except for the first field (the vtable)."]
#[doc = ""]
#[doc = " The \"known key\" engine returns an externally configured public key,"]
#[doc = " and totally ignores the certificate contents."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_x509_knownkey_context {
    #[doc = " \\brief Reference to the context vtable."]
    pub vtable: *const br_x509_class,
    pub pkey: br_x509_pkey,
    pub usages: cty::c_uint,
}
extern "C" {
    pub static br_x509_knownkey_vtable: br_x509_class;
}
extern "C" {
    #[doc = " \\brief Initialize a \"known key\" X.509 engine with a known RSA public key."]
    #[doc = ""]
    #[doc = " The `usages` parameter indicates the allowed key usages for that key"]
    #[doc = " (`BR_KEYTYPE_KEYX` and/or `BR_KEYTYPE_SIGN`)."]
    #[doc = ""]
    #[doc = " The provided pointers are linked in, not copied, so they must remain"]
    #[doc = " valid while the public key may be in usage."]
    #[doc = ""]
    #[doc = " \\param ctx      context to initialise."]
    #[doc = " \\param pk       known public key."]
    #[doc = " \\param usages   allowed key usages."]
    pub fn br_x509_knownkey_init_rsa(
        ctx: *mut br_x509_knownkey_context,
        pk: *const br_rsa_public_key,
        usages: cty::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief Initialize a \"known key\" X.509 engine with a known EC public key."]
    #[doc = ""]
    #[doc = " The `usages` parameter indicates the allowed key usages for that key"]
    #[doc = " (`BR_KEYTYPE_KEYX` and/or `BR_KEYTYPE_SIGN`)."]
    #[doc = ""]
    #[doc = " The provided pointers are linked in, not copied, so they must remain"]
    #[doc = " valid while the public key may be in usage."]
    #[doc = ""]
    #[doc = " \\param ctx      context to initialise."]
    #[doc = " \\param pk       known public key."]
    #[doc = " \\param usages   allowed key usages."]
    pub fn br_x509_knownkey_init_ec(
        ctx: *mut br_x509_knownkey_context,
        pk: *const br_ec_public_key,
        usages: cty::c_uint,
    );
}
#[doc = " \\brief Type for receiving a name element."]
#[doc = ""]
#[doc = " An array of such structures can be provided to the X.509 decoding"]
#[doc = " engines. If the specified elements are found in the certificate"]
#[doc = " subject DN or the SAN extension, then the name contents are copied"]
#[doc = " as zero-terminated strings into the buffer."]
#[doc = ""]
#[doc = " The decoder converts TeletexString and BMPString to UTF8String, and"]
#[doc = " ensures that the resulting string is zero-terminated. If the string"]
#[doc = " does not fit in the provided buffer, then the copy is aborted and an"]
#[doc = " error is reported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_name_element {
    #[doc = " \\brief Element OID."]
    #[doc = ""]
    #[doc = " For X.500 name elements (to be extracted from the subject DN),"]
    #[doc = " this is the encoded OID for the requested name element; the"]
    #[doc = " first byte shall contain the length of the DER-encoded OID"]
    #[doc = " value, followed by the OID value (for instance, OID 2.5.4.3,"]
    #[doc = " for id-at-commonName, will be `03 55 04 03`). This is"]
    #[doc = " equivalent to full DER encoding with the length but without"]
    #[doc = " the tag."]
    #[doc = ""]
    #[doc = " For SAN name elements, the first byte (`oid[0]`) has value 0,"]
    #[doc = " followed by another byte that matches the expected GeneralName"]
    #[doc = " tag. Allowed second byte values are then:"]
    #[doc = ""]
    #[doc = "   - 1: `rfc822Name`"]
    #[doc = ""]
    #[doc = "   - 2: `dNSName`"]
    #[doc = ""]
    #[doc = "   - 6: `uniformResourceIdentifier`"]
    #[doc = ""]
    #[doc = "   - 0: `otherName`"]
    #[doc = ""]
    #[doc = " If first and second byte are 0, then this is a SAN element of"]
    #[doc = " type `otherName`; the `oid[]` array should then contain, right"]
    #[doc = " after the two bytes of value 0, an encoded OID (with the same"]
    #[doc = " conventions as for X.500 name elements). If a match is found"]
    #[doc = " for that OID, then the corresponding name element will be"]
    #[doc = " extracted, as long as it is a supported string type."]
    pub oid: *const cty::c_uchar,
    #[doc = " \\brief Destination buffer."]
    pub buf: *mut cty::c_char,
    #[doc = " \\brief Length (in bytes) of the destination buffer."]
    #[doc = ""]
    #[doc = " The buffer MUST NOT be smaller than 1 byte."]
    pub len: usize,
    #[doc = " \\brief Decoding status."]
    #[doc = ""]
    #[doc = " Status is 0 if the name element was not found, 1 if it was"]
    #[doc = " found and decoded, or -1 on error. Error conditions include"]
    #[doc = " an unrecognised encoding, an invalid encoding, or a string"]
    #[doc = " too large for the destination buffer."]
    pub status: cty::c_int,
}
#[doc = " \\brief The \"minimal\" X.509 engine structure."]
#[doc = ""]
#[doc = " The structure contents are opaque (they shall not be accessed directly),"]
#[doc = " except for the first field (the vtable)."]
#[doc = ""]
#[doc = " The \"minimal\" engine performs a rudimentary but serviceable X.509 path"]
#[doc = " validation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_x509_minimal_context {
    pub vtable: *const br_x509_class,
    pub pkey: br_x509_pkey,
    pub cpu: br_x509_minimal_context__bindgen_ty_1,
    pub dp_stack: [u32; 32usize],
    pub rp_stack: [u32; 32usize],
    pub err: cty::c_int,
    pub server_name: *const cty::c_char,
    pub key_usages: cty::c_uchar,
    pub days: u32,
    pub seconds: u32,
    pub cert_length: u32,
    pub num_certs: u32,
    pub hbuf: *const cty::c_uchar,
    pub hlen: usize,
    pub pad: [cty::c_uchar; 256usize],
    pub ee_pkey_data: [cty::c_uchar; 520usize],
    pub pkey_data: [cty::c_uchar; 520usize],
    pub cert_signer_key_type: cty::c_uchar,
    pub cert_sig_hash_oid: u16,
    pub cert_sig_hash_len: cty::c_uchar,
    pub cert_sig: [cty::c_uchar; 512usize],
    pub cert_sig_len: u16,
    pub min_rsa_size: i16,
    pub trust_anchors: *const br_x509_trust_anchor,
    pub trust_anchors_num: usize,
    pub do_mhash: cty::c_uchar,
    pub __bindgen_padding_0: [u32; 0usize],
    pub mhash: br_multihash_context,
    pub tbs_hash: [cty::c_uchar; 64usize],
    pub do_dn_hash: cty::c_uchar,
    pub dn_hash_impl: *const br_hash_class,
    pub dn_hash: br_hash_compat_context,
    pub current_dn_hash: [cty::c_uchar; 64usize],
    pub next_dn_hash: [cty::c_uchar; 64usize],
    pub saved_dn_hash: [cty::c_uchar; 64usize],
    pub name_elts: *mut br_name_element,
    pub num_name_elts: usize,
    pub irsa: br_rsa_pkcs1_vrfy,
    pub iecdsa: br_ecdsa_vrfy,
    pub iec: *const br_ec_impl,
    pub __bindgen_padding_1: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_x509_minimal_context__bindgen_ty_1 {
    pub dp: *mut u32,
    pub rp: *mut u32,
    pub ip: *const cty::c_uchar,
}
extern "C" {
    pub static br_x509_minimal_vtable: br_x509_class;
}
extern "C" {
    #[doc = " \\brief Initialise a \"minimal\" X.509 engine."]
    #[doc = ""]
    #[doc = " The `dn_hash_impl` parameter shall be a hash function internally used"]
    #[doc = " to match X.500 names (subject/issuer DN, and anchor names). Any standard"]
    #[doc = " hash function may be used, but a collision-resistant hash function is"]
    #[doc = " advised."]
    #[doc = ""]
    #[doc = " After initialization, some implementations for signature verification"]
    #[doc = " (hash functions and signature algorithms) MUST be added."]
    #[doc = ""]
    #[doc = " \\param ctx                 context to initialise."]
    #[doc = " \\param dn_hash_impl        hash function for DN comparisons."]
    #[doc = " \\param trust_anchors       trust anchors."]
    #[doc = " \\param trust_anchors_num   number of trust anchors."]
    pub fn br_x509_minimal_init(
        ctx: *mut br_x509_minimal_context,
        dn_hash_impl: *const br_hash_class,
        trust_anchors: *const br_x509_trust_anchor,
        trust_anchors_num: usize,
    );
}
extern "C" {
    #[doc = " \\brief Initialise a \"minimal\" X.509 engine with default algorithms."]
    #[doc = ""]
    #[doc = " This function performs the same job as `br_x509_minimal_init()`, but"]
    #[doc = " also sets implementations for RSA, ECDSA, and the standard hash"]
    #[doc = " functions."]
    #[doc = ""]
    #[doc = " \\param ctx                 context to initialise."]
    #[doc = " \\param trust_anchors       trust anchors."]
    #[doc = " \\param trust_anchors_num   number of trust anchors."]
    pub fn br_x509_minimal_init_full(
        ctx: *mut br_x509_minimal_context,
        trust_anchors: *const br_x509_trust_anchor,
        trust_anchors_num: usize,
    );
}
#[doc = " \\brief X.509 decoder context."]
#[doc = ""]
#[doc = " This structure is _not_ for X.509 validation, but for extracting"]
#[doc = " names and public keys from encoded certificates. Intended usage is"]
#[doc = " to use (self-signed) certificates as trust anchors."]
#[doc = ""]
#[doc = " Contents are opaque and shall not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_x509_decoder_context {
    pub pkey: br_x509_pkey,
    pub cpu: br_x509_decoder_context__bindgen_ty_1,
    pub dp_stack: [u32; 32usize],
    pub rp_stack: [u32; 32usize],
    pub err: cty::c_int,
    pub pad: [cty::c_uchar; 256usize],
    pub decoded: cty::c_uchar,
    pub notbefore_days: u32,
    pub notbefore_seconds: u32,
    pub notafter_days: u32,
    pub notafter_seconds: u32,
    pub isCA: cty::c_uchar,
    pub copy_dn: cty::c_uchar,
    pub append_dn_ctx: *mut cty::c_void,
    pub append_dn: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cty::c_void, buf: *const cty::c_void, len: usize),
    >,
    pub hbuf: *const cty::c_uchar,
    pub hlen: usize,
    pub pkey_data: [cty::c_uchar; 520usize],
    pub signer_key_type: cty::c_uchar,
    pub signer_hash_id: cty::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_x509_decoder_context__bindgen_ty_1 {
    pub dp: *mut u32,
    pub rp: *mut u32,
    pub ip: *const cty::c_uchar,
}
extern "C" {
    #[doc = " \\brief Initialise an X.509 decoder context for processing a new"]
    #[doc = " certificate."]
    #[doc = ""]
    #[doc = " The `append_dn()` callback (with opaque context `append_dn_ctx`)"]
    #[doc = " will be invoked to receive, chunk by chunk, the certificate's"]
    #[doc = " subject DN. If `append_dn` is `0` then the subject DN will be"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " \\param ctx             X.509 decoder context to initialise."]
    #[doc = " \\param append_dn       DN receiver callback (or `0`)."]
    #[doc = " \\param append_dn_ctx   context for the DN receiver callback."]
    pub fn br_x509_decoder_init(
        ctx: *mut br_x509_decoder_context,
        append_dn: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut cty::c_void, buf: *const cty::c_void, len: usize),
        >,
        append_dn_ctx: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Push some certificate bytes into a decoder context."]
    #[doc = ""]
    #[doc = " If `len` is non-zero, then that many bytes are pushed, from address"]
    #[doc = " `data`, into the provided decoder context."]
    #[doc = ""]
    #[doc = " \\param ctx    X.509 decoder context."]
    #[doc = " \\param data   certificate data chunk."]
    #[doc = " \\param len    certificate data chunk length (in bytes)."]
    pub fn br_x509_decoder_push(
        ctx: *mut br_x509_decoder_context,
        data: *const cty::c_void,
        len: usize,
    );
}
#[doc = " \\brief Type for an X.509 certificate (DER-encoded)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_x509_certificate {
    #[doc = " \\brief The DER-encoded certificate data."]
    pub data: *mut cty::c_uchar,
    #[doc = " \\brief The DER-encoded certificate length (in bytes)."]
    pub data_len: usize,
}
#[doc = " \\brief Private key decoder context."]
#[doc = ""]
#[doc = " The private key decoder recognises RSA and EC private keys, either in"]
#[doc = " their raw, DER-encoded format, or wrapped in an unencrypted PKCS#8"]
#[doc = " archive (again DER-encoded)."]
#[doc = ""]
#[doc = " Structure contents are opaque and shall not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_skey_decoder_context {
    pub key: br_skey_decoder_context__bindgen_ty_1,
    pub cpu: br_skey_decoder_context__bindgen_ty_2,
    pub dp_stack: [u32; 32usize],
    pub rp_stack: [u32; 32usize],
    pub err: cty::c_int,
    pub hbuf: *const cty::c_uchar,
    pub hlen: usize,
    pub pad: [cty::c_uchar; 256usize],
    pub key_type: cty::c_uchar,
    pub key_data: [cty::c_uchar; 1536usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_skey_decoder_context__bindgen_ty_1 {
    pub rsa: br_rsa_private_key,
    pub ec: br_ec_private_key,
    _bindgen_union_align: [u32; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_skey_decoder_context__bindgen_ty_2 {
    pub dp: *mut u32,
    pub rp: *mut u32,
    pub ip: *const cty::c_uchar,
}
extern "C" {
    #[doc = " \\brief Initialise a private key decoder context."]
    #[doc = ""]
    #[doc = " \\param ctx   key decoder context to initialise."]
    pub fn br_skey_decoder_init(ctx: *mut br_skey_decoder_context);
}
extern "C" {
    #[doc = " \\brief Push some data bytes into a private key decoder context."]
    #[doc = ""]
    #[doc = " If `len` is non-zero, then that many data bytes, starting at address"]
    #[doc = " `data`, are pushed into the decoder."]
    #[doc = ""]
    #[doc = " \\param ctx    key decoder context."]
    #[doc = " \\param data   private key data chunk."]
    #[doc = " \\param len    private key data chunk length (in bytes)."]
    pub fn br_skey_decoder_push(
        ctx: *mut br_skey_decoder_context,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Encode an RSA private key (raw DER format)."]
    #[doc = ""]
    #[doc = " This function encodes the provided key into the \"raw\" format specified"]
    #[doc = " in PKCS#1 (RFC 8017, Appendix C, type `RSAPrivateKey`), with DER"]
    #[doc = " encoding rules."]
    #[doc = ""]
    #[doc = " The key elements are:"]
    #[doc = ""]
    #[doc = "  - `sk`: the private key (`p`, `q`, `dp`, `dq` and `iq`)"]
    #[doc = ""]
    #[doc = "  - `pk`: the public key (`n` and `e`)"]
    #[doc = ""]
    #[doc = "  - `d` (size: `dlen` bytes): the private exponent"]
    #[doc = ""]
    #[doc = " The public key elements, and the private exponent `d`, can be"]
    #[doc = " recomputed from the private key (see `br_rsa_compute_modulus()`,"]
    #[doc = " `br_rsa_compute_pubexp()` and `br_rsa_compute_privexp()`)."]
    #[doc = ""]
    #[doc = " If `dest` is not `NULL`, then the encoded key is written at that"]
    #[doc = " address, and the encoded length (in bytes) is returned. If `dest` is"]
    #[doc = " `NULL`, then nothing is written, but the encoded length is still"]
    #[doc = " computed and returned."]
    #[doc = ""]
    #[doc = " \\param dest   the destination buffer (or `NULL`)."]
    #[doc = " \\param sk     the RSA private key."]
    #[doc = " \\param pk     the RSA public key."]
    #[doc = " \\param d      the RSA private exponent."]
    #[doc = " \\param dlen   the RSA private exponent length (in bytes)."]
    #[doc = " \\return  the encoded key length (in bytes)."]
    pub fn br_encode_rsa_raw_der(
        dest: *mut cty::c_void,
        sk: *const br_rsa_private_key,
        pk: *const br_rsa_public_key,
        d: *const cty::c_void,
        dlen: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Encode an RSA private key (PKCS#8 DER format)."]
    #[doc = ""]
    #[doc = " This function encodes the provided key into the PKCS#8 format"]
    #[doc = " (RFC 5958, type `OneAsymmetricKey`). It wraps around the \"raw DER\""]
    #[doc = " format for the RSA key, as implemented by `br_encode_rsa_raw_der()`."]
    #[doc = ""]
    #[doc = " The key elements are:"]
    #[doc = ""]
    #[doc = "  - `sk`: the private key (`p`, `q`, `dp`, `dq` and `iq`)"]
    #[doc = ""]
    #[doc = "  - `pk`: the public key (`n` and `e`)"]
    #[doc = ""]
    #[doc = "  - `d` (size: `dlen` bytes): the private exponent"]
    #[doc = ""]
    #[doc = " The public key elements, and the private exponent `d`, can be"]
    #[doc = " recomputed from the private key (see `br_rsa_compute_modulus()`,"]
    #[doc = " `br_rsa_compute_pubexp()` and `br_rsa_compute_privexp()`)."]
    #[doc = ""]
    #[doc = " If `dest` is not `NULL`, then the encoded key is written at that"]
    #[doc = " address, and the encoded length (in bytes) is returned. If `dest` is"]
    #[doc = " `NULL`, then nothing is written, but the encoded length is still"]
    #[doc = " computed and returned."]
    #[doc = ""]
    #[doc = " \\param dest   the destination buffer (or `NULL`)."]
    #[doc = " \\param sk     the RSA private key."]
    #[doc = " \\param pk     the RSA public key."]
    #[doc = " \\param d      the RSA private exponent."]
    #[doc = " \\param dlen   the RSA private exponent length (in bytes)."]
    #[doc = " \\return  the encoded key length (in bytes)."]
    pub fn br_encode_rsa_pkcs8_der(
        dest: *mut cty::c_void,
        sk: *const br_rsa_private_key,
        pk: *const br_rsa_public_key,
        d: *const cty::c_void,
        dlen: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Encode an EC private key (raw DER format)."]
    #[doc = ""]
    #[doc = " This function encodes the provided key into the \"raw\" format specified"]
    #[doc = " in RFC 5915 (type `ECPrivateKey`), with DER encoding rules."]
    #[doc = ""]
    #[doc = " The private key is provided in `sk`, the public key being `pk`. If"]
    #[doc = " `pk` is `NULL`, then the encoded key will not include the public key"]
    #[doc = " in its `publicKey` field (which is nominally optional)."]
    #[doc = ""]
    #[doc = " If `dest` is not `NULL`, then the encoded key is written at that"]
    #[doc = " address, and the encoded length (in bytes) is returned. If `dest` is"]
    #[doc = " `NULL`, then nothing is written, but the encoded length is still"]
    #[doc = " computed and returned."]
    #[doc = ""]
    #[doc = " If the key cannot be encoded (e.g. because there is no known OBJECT"]
    #[doc = " IDENTIFIER for the used curve), then 0 is returned."]
    #[doc = ""]
    #[doc = " \\param dest   the destination buffer (or `NULL`)."]
    #[doc = " \\param sk     the EC private key."]
    #[doc = " \\param pk     the EC public key (or `NULL`)."]
    #[doc = " \\return  the encoded key length (in bytes), or 0."]
    pub fn br_encode_ec_raw_der(
        dest: *mut cty::c_void,
        sk: *const br_ec_private_key,
        pk: *const br_ec_public_key,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Encode an EC private key (PKCS#8 DER format)."]
    #[doc = ""]
    #[doc = " This function encodes the provided key into the PKCS#8 format"]
    #[doc = " (RFC 5958, type `OneAsymmetricKey`). The curve is identified"]
    #[doc = " by an OID provided as parameters to the `privateKeyAlgorithm`"]
    #[doc = " field. The private key value (contents of the `privateKey` field)"]
    #[doc = " contains the DER encoding of the `ECPrivateKey` type defined in"]
    #[doc = " RFC 5915, without the `parameters` field (since they would be"]
    #[doc = " redundant with the information in `privateKeyAlgorithm`)."]
    #[doc = ""]
    #[doc = " The private key is provided in `sk`, the public key being `pk`. If"]
    #[doc = " `pk` is not `NULL`, then the encoded public key is included in the"]
    #[doc = " `publicKey` field of the private key value (but not in the `publicKey`"]
    #[doc = " field of the PKCS#8 `OneAsymmetricKey` wrapper)."]
    #[doc = ""]
    #[doc = " If `dest` is not `NULL`, then the encoded key is written at that"]
    #[doc = " address, and the encoded length (in bytes) is returned. If `dest` is"]
    #[doc = " `NULL`, then nothing is written, but the encoded length is still"]
    #[doc = " computed and returned."]
    #[doc = ""]
    #[doc = " If the key cannot be encoded (e.g. because there is no known OBJECT"]
    #[doc = " IDENTIFIER for the used curve), then 0 is returned."]
    #[doc = ""]
    #[doc = " \\param dest   the destination buffer (or `NULL`)."]
    #[doc = " \\param sk     the EC private key."]
    #[doc = " \\param pk     the EC public key (or `NULL`)."]
    #[doc = " \\return  the encoded key length (in bytes), or 0."]
    pub fn br_encode_ec_pkcs8_der(
        dest: *mut cty::c_void,
        sk: *const br_ec_private_key,
        pk: *const br_ec_public_key,
    ) -> usize;
}
#[doc = " \\brief Decryption engine for SSL."]
#[doc = ""]
#[doc = " When processing incoming records, the SSL engine will use a decryption"]
#[doc = " engine that uses a specific context structure, and has a set of"]
#[doc = " methods (a vtable) that follows this template."]
#[doc = ""]
#[doc = " The decryption engine is responsible for applying decryption, verifying"]
#[doc = " MAC, and keeping track of the record sequence number."]
pub type br_sslrec_in_class = br_sslrec_in_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_in_class_ {
    #[doc = " \\brief Context size (in bytes)."]
    pub context_size: usize,
    #[doc = " \\brief Test validity of the incoming record length."]
    #[doc = ""]
    #[doc = " This function returns 1 if the announced length for an"]
    #[doc = " incoming record is valid, 0 otherwise,"]
    #[doc = ""]
    #[doc = " \\param ctx          decryption engine context."]
    #[doc = " \\param record_len   incoming record length."]
    #[doc = " \\return  1 of a valid length, 0 otherwise."]
    pub check_length: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_sslrec_in_class,
            record_len: usize,
        ) -> cty::c_int,
    >,
    #[doc = " \\brief Decrypt the incoming record."]
    #[doc = ""]
    #[doc = " This function may assume that the record length is valid"]
    #[doc = " (it has been previously tested with `check_length()`)."]
    #[doc = " Decryption is done in place; `*len` is updated with the"]
    #[doc = " cleartext length, and the address of the first plaintext"]
    #[doc = " byte is returned. If the record is correct but empty, then"]
    #[doc = " `*len` is set to 0 and a non-`NULL` pointer is returned."]
    #[doc = ""]
    #[doc = " On decryption/MAC error, `NULL` is returned."]
    #[doc = ""]
    #[doc = " \\param ctx           decryption engine context."]
    #[doc = " \\param record_type   record type (23 for application data, etc)."]
    #[doc = " \\param version       record version."]
    #[doc = " \\param payload       address of encrypted payload."]
    #[doc = " \\param len           pointer to payload length (updated)."]
    #[doc = " \\return  pointer to plaintext, or `NULL` on error."]
    pub decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_in_class,
            record_type: cty::c_int,
            version: cty::c_uint,
            payload: *mut cty::c_void,
            len: *mut usize,
        ) -> *mut cty::c_uchar,
    >,
}
#[doc = " \\brief Encryption engine for SSL."]
#[doc = ""]
#[doc = " When building outgoing records, the SSL engine will use an encryption"]
#[doc = " engine that uses a specific context structure, and has a set of"]
#[doc = " methods (a vtable) that follows this template."]
#[doc = ""]
#[doc = " The encryption engine is responsible for applying encryption and MAC,"]
#[doc = " and keeping track of the record sequence number."]
pub type br_sslrec_out_class = br_sslrec_out_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_out_class_ {
    #[doc = " \\brief Context size (in bytes)."]
    pub context_size: usize,
    #[doc = " \\brief Compute maximum plaintext sizes and offsets."]
    #[doc = ""]
    #[doc = " When this function is called, the `*start` and `*end`"]
    #[doc = " values contain offsets designating the free area in the"]
    #[doc = " outgoing buffer for plaintext data; that free area is"]
    #[doc = " preceded by a 5-byte space which will receive the record"]
    #[doc = " header."]
    #[doc = ""]
    #[doc = " The `max_plaintext()` function is responsible for adjusting"]
    #[doc = " both `*start` and `*end` to make room for any record-specific"]
    #[doc = " header, MAC, padding, and possible split."]
    #[doc = ""]
    #[doc = " \\param ctx     encryption engine context."]
    #[doc = " \\param start   pointer to start of plaintext offset (updated)."]
    #[doc = " \\param end     pointer to start of plaintext offset (updated)."]
    pub max_plaintext: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const *const br_sslrec_out_class,
            start: *mut usize,
            end: *mut usize,
        ),
    >,
    #[doc = " \\brief Perform record encryption."]
    #[doc = ""]
    #[doc = " This function encrypts the record. The plaintext address and"]
    #[doc = " length are provided. Returned value is the start of the"]
    #[doc = " encrypted record (or sequence of records, if a split was"]
    #[doc = " performed), _including_ the 5-byte header, and `*len` is"]
    #[doc = " adjusted to the total size of the record(s), there again"]
    #[doc = " including the header(s)."]
    #[doc = ""]
    #[doc = " \\param ctx           decryption engine context."]
    #[doc = " \\param record_type   record type (23 for application data, etc)."]
    #[doc = " \\param version       record version."]
    #[doc = " \\param plaintext     address of plaintext."]
    #[doc = " \\param len           pointer to plaintext length (updated)."]
    #[doc = " \\return  pointer to start of built record."]
    pub encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_out_class,
            record_type: cty::c_int,
            version: cty::c_uint,
            plaintext: *mut cty::c_void,
            len: *mut usize,
        ) -> *mut cty::c_uchar,
    >,
}
#[doc = " \\brief Context for a no-encryption engine."]
#[doc = ""]
#[doc = " The no-encryption engine processes outgoing records during the initial"]
#[doc = " handshake, before encryption is applied."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_out_clear_context {
    #[doc = " \\brief No-encryption engine vtable."]
    pub vtable: *const br_sslrec_out_class,
}
extern "C" {
    pub static br_sslrec_out_clear_vtable: br_sslrec_out_class;
}
#[doc = " \\brief Record decryption engine class, for CBC mode."]
#[doc = ""]
#[doc = " This class type extends the decryption engine class with an"]
#[doc = " initialisation method that receives the parameters needed"]
#[doc = " for CBC processing: block cipher implementation, block cipher key,"]
#[doc = " HMAC parameters (hash function, key, MAC length), and IV. If the"]
#[doc = " IV is `NULL`, then a per-record IV will be used (TLS 1.1+)."]
pub type br_sslrec_in_cbc_class = br_sslrec_in_cbc_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_in_cbc_class_ {
    #[doc = " \\brief Superclass, as first vtable field."]
    pub inner: br_sslrec_in_class,
    #[doc = " \\brief Engine initialisation method."]
    #[doc = ""]
    #[doc = " This method sets the vtable field in the context."]
    #[doc = ""]
    #[doc = " \\param ctx           context to initialise."]
    #[doc = " \\param bc_impl       block cipher implementation (CBC decryption)."]
    #[doc = " \\param bc_key        block cipher key."]
    #[doc = " \\param bc_key_len    block cipher key length (in bytes)."]
    #[doc = " \\param dig_impl      hash function for HMAC."]
    #[doc = " \\param mac_key       HMAC key."]
    #[doc = " \\param mac_key_len   HMAC key length (in bytes)."]
    #[doc = " \\param mac_out_len   HMAC output length (in bytes)."]
    #[doc = " \\param iv            initial IV (or `NULL`)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_in_cbc_class,
            bc_impl: *const br_block_cbcdec_class,
            bc_key: *const cty::c_void,
            bc_key_len: usize,
            dig_impl: *const br_hash_class,
            mac_key: *const cty::c_void,
            mac_key_len: usize,
            mac_out_len: usize,
            iv: *const cty::c_void,
        ),
    >,
}
#[doc = " \\brief Record encryption engine class, for CBC mode."]
#[doc = ""]
#[doc = " This class type extends the encryption engine class with an"]
#[doc = " initialisation method that receives the parameters needed"]
#[doc = " for CBC processing: block cipher implementation, block cipher key,"]
#[doc = " HMAC parameters (hash function, key, MAC length), and IV. If the"]
#[doc = " IV is `NULL`, then a per-record IV will be used (TLS 1.1+)."]
pub type br_sslrec_out_cbc_class = br_sslrec_out_cbc_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_out_cbc_class_ {
    #[doc = " \\brief Superclass, as first vtable field."]
    pub inner: br_sslrec_out_class,
    #[doc = " \\brief Engine initialisation method."]
    #[doc = ""]
    #[doc = " This method sets the vtable field in the context."]
    #[doc = ""]
    #[doc = " \\param ctx           context to initialise."]
    #[doc = " \\param bc_impl       block cipher implementation (CBC encryption)."]
    #[doc = " \\param bc_key        block cipher key."]
    #[doc = " \\param bc_key_len    block cipher key length (in bytes)."]
    #[doc = " \\param dig_impl      hash function for HMAC."]
    #[doc = " \\param mac_key       HMAC key."]
    #[doc = " \\param mac_key_len   HMAC key length (in bytes)."]
    #[doc = " \\param mac_out_len   HMAC output length (in bytes)."]
    #[doc = " \\param iv            initial IV (or `NULL`)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_out_cbc_class,
            bc_impl: *const br_block_cbcenc_class,
            bc_key: *const cty::c_void,
            bc_key_len: usize,
            dig_impl: *const br_hash_class,
            mac_key: *const cty::c_void,
            mac_key_len: usize,
            mac_out_len: usize,
            iv: *const cty::c_void,
        ),
    >,
}
#[doc = " \\brief Context structure for decrypting incoming records with"]
#[doc = " CBC + HMAC."]
#[doc = ""]
#[doc = " The first field points to the vtable. The other fields are opaque"]
#[doc = " and shall not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_sslrec_in_cbc_context {
    #[doc = " \\brief Pointer to vtable."]
    pub vtable: *const br_sslrec_in_cbc_class,
    pub __bindgen_padding_0: u32,
    pub seq: u64,
    pub bc: br_sslrec_in_cbc_context__bindgen_ty_1,
    pub mac: br_hmac_key_context,
    pub mac_len: usize,
    pub iv: [cty::c_uchar; 16usize],
    pub explicit_IV: cty::c_int,
    pub __bindgen_padding_1: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_sslrec_in_cbc_context__bindgen_ty_1 {
    pub vtable: *const br_block_cbcdec_class,
    pub aes: br_aes_gen_cbcdec_keys,
    pub des: br_des_gen_cbcdec_keys,
    _bindgen_union_align: [u64; 49usize],
}
extern "C" {
    pub static br_sslrec_in_cbc_vtable: br_sslrec_in_cbc_class;
}
#[doc = " \\brief Context structure for encrypting outgoing records with"]
#[doc = " CBC + HMAC."]
#[doc = ""]
#[doc = " The first field points to the vtable. The other fields are opaque"]
#[doc = " and shall not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_sslrec_out_cbc_context {
    #[doc = " \\brief Pointer to vtable."]
    pub vtable: *const br_sslrec_out_cbc_class,
    pub __bindgen_padding_0: u32,
    pub seq: u64,
    pub bc: br_sslrec_out_cbc_context__bindgen_ty_1,
    pub mac: br_hmac_key_context,
    pub mac_len: usize,
    pub iv: [cty::c_uchar; 16usize],
    pub explicit_IV: cty::c_int,
    pub __bindgen_padding_1: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_sslrec_out_cbc_context__bindgen_ty_1 {
    pub vtable: *const br_block_cbcenc_class,
    pub aes: br_aes_gen_cbcenc_keys,
    pub des: br_des_gen_cbcenc_keys,
    _bindgen_union_align: [u64; 49usize],
}
extern "C" {
    pub static br_sslrec_out_cbc_vtable: br_sslrec_out_cbc_class;
}
#[doc = " \\brief Record decryption engine class, for GCM mode."]
#[doc = ""]
#[doc = " This class type extends the decryption engine class with an"]
#[doc = " initialisation method that receives the parameters needed"]
#[doc = " for GCM processing: block cipher implementation, block cipher key,"]
#[doc = " GHASH implementation, and 4-byte IV."]
pub type br_sslrec_in_gcm_class = br_sslrec_in_gcm_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_in_gcm_class_ {
    #[doc = " \\brief Superclass, as first vtable field."]
    pub inner: br_sslrec_in_class,
    #[doc = " \\brief Engine initialisation method."]
    #[doc = ""]
    #[doc = " This method sets the vtable field in the context."]
    #[doc = ""]
    #[doc = " \\param ctx           context to initialise."]
    #[doc = " \\param bc_impl       block cipher implementation (CTR)."]
    #[doc = " \\param key           block cipher key."]
    #[doc = " \\param key_len       block cipher key length (in bytes)."]
    #[doc = " \\param gh_impl       GHASH implementation."]
    #[doc = " \\param iv            static IV (4 bytes)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_in_gcm_class,
            bc_impl: *const br_block_ctr_class,
            key: *const cty::c_void,
            key_len: usize,
            gh_impl: br_ghash,
            iv: *const cty::c_void,
        ),
    >,
}
#[doc = " \\brief Record encryption engine class, for GCM mode."]
#[doc = ""]
#[doc = " This class type extends the encryption engine class with an"]
#[doc = " initialisation method that receives the parameters needed"]
#[doc = " for GCM processing: block cipher implementation, block cipher key,"]
#[doc = " GHASH implementation, and 4-byte IV."]
pub type br_sslrec_out_gcm_class = br_sslrec_out_gcm_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_out_gcm_class_ {
    #[doc = " \\brief Superclass, as first vtable field."]
    pub inner: br_sslrec_out_class,
    #[doc = " \\brief Engine initialisation method."]
    #[doc = ""]
    #[doc = " This method sets the vtable field in the context."]
    #[doc = ""]
    #[doc = " \\param ctx           context to initialise."]
    #[doc = " \\param bc_impl       block cipher implementation (CTR)."]
    #[doc = " \\param key           block cipher key."]
    #[doc = " \\param key_len       block cipher key length (in bytes)."]
    #[doc = " \\param gh_impl       GHASH implementation."]
    #[doc = " \\param iv            static IV (4 bytes)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_out_gcm_class,
            bc_impl: *const br_block_ctr_class,
            key: *const cty::c_void,
            key_len: usize,
            gh_impl: br_ghash,
            iv: *const cty::c_void,
        ),
    >,
}
#[doc = " \\brief Context structure for processing records with GCM."]
#[doc = ""]
#[doc = " The same context structure is used for encrypting and decrypting."]
#[doc = ""]
#[doc = " The first field points to the vtable. The other fields are opaque"]
#[doc = " and shall not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_sslrec_gcm_context {
    pub vtable: br_sslrec_gcm_context__bindgen_ty_1,
    pub __bindgen_padding_0: u32,
    pub seq: u64,
    pub bc: br_sslrec_gcm_context__bindgen_ty_2,
    pub gh: br_ghash,
    pub iv: [cty::c_uchar; 4usize],
    pub h: [cty::c_uchar; 16usize],
}
#[doc = " \\brief Pointer to vtable."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_sslrec_gcm_context__bindgen_ty_1 {
    pub gen: *const cty::c_void,
    pub in_: *const br_sslrec_in_gcm_class,
    pub out: *const br_sslrec_out_gcm_class,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_sslrec_gcm_context__bindgen_ty_2 {
    pub vtable: *const br_block_ctr_class,
    pub aes: br_aes_gen_ctr_keys,
    _bindgen_union_align: [u64; 32usize],
}
extern "C" {
    pub static br_sslrec_in_gcm_vtable: br_sslrec_in_gcm_class;
}
extern "C" {
    pub static br_sslrec_out_gcm_vtable: br_sslrec_out_gcm_class;
}
#[doc = " \\brief Record decryption engine class, for ChaCha20+Poly1305."]
#[doc = ""]
#[doc = " This class type extends the decryption engine class with an"]
#[doc = " initialisation method that receives the parameters needed"]
#[doc = " for ChaCha20+Poly1305 processing: ChaCha20 implementation,"]
#[doc = " Poly1305 implementation, key, and 12-byte IV."]
pub type br_sslrec_in_chapol_class = br_sslrec_in_chapol_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_in_chapol_class_ {
    #[doc = " \\brief Superclass, as first vtable field."]
    pub inner: br_sslrec_in_class,
    #[doc = " \\brief Engine initialisation method."]
    #[doc = ""]
    #[doc = " This method sets the vtable field in the context."]
    #[doc = ""]
    #[doc = " \\param ctx           context to initialise."]
    #[doc = " \\param ichacha       ChaCha20 implementation."]
    #[doc = " \\param ipoly         Poly1305 implementation."]
    #[doc = " \\param key           secret key (32 bytes)."]
    #[doc = " \\param iv            static IV (12 bytes)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_in_chapol_class,
            ichacha: br_chacha20_run,
            ipoly: br_poly1305_run,
            key: *const cty::c_void,
            iv: *const cty::c_void,
        ),
    >,
}
#[doc = " \\brief Record encryption engine class, for ChaCha20+Poly1305."]
#[doc = ""]
#[doc = " This class type extends the encryption engine class with an"]
#[doc = " initialisation method that receives the parameters needed"]
#[doc = " for ChaCha20+Poly1305 processing: ChaCha20 implementation,"]
#[doc = " Poly1305 implementation, key, and 12-byte IV."]
pub type br_sslrec_out_chapol_class = br_sslrec_out_chapol_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_out_chapol_class_ {
    #[doc = " \\brief Superclass, as first vtable field."]
    pub inner: br_sslrec_out_class,
    #[doc = " \\brief Engine initialisation method."]
    #[doc = ""]
    #[doc = " This method sets the vtable field in the context."]
    #[doc = ""]
    #[doc = " \\param ctx           context to initialise."]
    #[doc = " \\param ichacha       ChaCha20 implementation."]
    #[doc = " \\param ipoly         Poly1305 implementation."]
    #[doc = " \\param key           secret key (32 bytes)."]
    #[doc = " \\param iv            static IV (12 bytes)."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_out_chapol_class,
            ichacha: br_chacha20_run,
            ipoly: br_poly1305_run,
            key: *const cty::c_void,
            iv: *const cty::c_void,
        ),
    >,
}
#[doc = " \\brief Context structure for processing records with ChaCha20+Poly1305."]
#[doc = ""]
#[doc = " The same context structure is used for encrypting and decrypting."]
#[doc = ""]
#[doc = " The first field points to the vtable. The other fields are opaque"]
#[doc = " and shall not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_sslrec_chapol_context {
    pub vtable: br_sslrec_chapol_context__bindgen_ty_1,
    pub __bindgen_padding_0: u32,
    pub seq: u64,
    pub key: [cty::c_uchar; 32usize],
    pub iv: [cty::c_uchar; 12usize],
    pub ichacha: br_chacha20_run,
    pub ipoly: br_poly1305_run,
    pub __bindgen_padding_1: u32,
}
#[doc = " \\brief Pointer to vtable."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_sslrec_chapol_context__bindgen_ty_1 {
    pub gen: *const cty::c_void,
    pub in_: *const br_sslrec_in_chapol_class,
    pub out: *const br_sslrec_out_chapol_class,
    _bindgen_union_align: u32,
}
extern "C" {
    pub static br_sslrec_in_chapol_vtable: br_sslrec_in_chapol_class;
}
extern "C" {
    pub static br_sslrec_out_chapol_vtable: br_sslrec_out_chapol_class;
}
#[doc = " \\brief Record decryption engine class, for CCM mode."]
#[doc = ""]
#[doc = " This class type extends the decryption engine class with an"]
#[doc = " initialisation method that receives the parameters needed"]
#[doc = " for CCM processing: block cipher implementation, block cipher key,"]
#[doc = " and 4-byte IV."]
pub type br_sslrec_in_ccm_class = br_sslrec_in_ccm_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_in_ccm_class_ {
    #[doc = " \\brief Superclass, as first vtable field."]
    pub inner: br_sslrec_in_class,
    #[doc = " \\brief Engine initialisation method."]
    #[doc = ""]
    #[doc = " This method sets the vtable field in the context."]
    #[doc = ""]
    #[doc = " \\param ctx           context to initialise."]
    #[doc = " \\param bc_impl       block cipher implementation (CTR+CBC)."]
    #[doc = " \\param key           block cipher key."]
    #[doc = " \\param key_len       block cipher key length (in bytes)."]
    #[doc = " \\param iv            static IV (4 bytes)."]
    #[doc = " \\param tag_len       tag length (in bytes)"]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_in_ccm_class,
            bc_impl: *const br_block_ctrcbc_class,
            key: *const cty::c_void,
            key_len: usize,
            iv: *const cty::c_void,
            tag_len: usize,
        ),
    >,
}
#[doc = " \\brief Record encryption engine class, for CCM mode."]
#[doc = ""]
#[doc = " This class type extends the encryption engine class with an"]
#[doc = " initialisation method that receives the parameters needed"]
#[doc = " for CCM processing: block cipher implementation, block cipher key,"]
#[doc = " and 4-byte IV."]
pub type br_sslrec_out_ccm_class = br_sslrec_out_ccm_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslrec_out_ccm_class_ {
    #[doc = " \\brief Superclass, as first vtable field."]
    pub inner: br_sslrec_out_class,
    #[doc = " \\brief Engine initialisation method."]
    #[doc = ""]
    #[doc = " This method sets the vtable field in the context."]
    #[doc = ""]
    #[doc = " \\param ctx           context to initialise."]
    #[doc = " \\param bc_impl       block cipher implementation (CTR+CBC)."]
    #[doc = " \\param key           block cipher key."]
    #[doc = " \\param key_len       block cipher key length (in bytes)."]
    #[doc = " \\param iv            static IV (4 bytes)."]
    #[doc = " \\param tag_len       tag length (in bytes)"]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_sslrec_out_ccm_class,
            bc_impl: *const br_block_ctrcbc_class,
            key: *const cty::c_void,
            key_len: usize,
            iv: *const cty::c_void,
            tag_len: usize,
        ),
    >,
}
#[doc = " \\brief Context structure for processing records with CCM."]
#[doc = ""]
#[doc = " The same context structure is used for encrypting and decrypting."]
#[doc = ""]
#[doc = " The first field points to the vtable. The other fields are opaque"]
#[doc = " and shall not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_sslrec_ccm_context {
    pub vtable: br_sslrec_ccm_context__bindgen_ty_1,
    pub __bindgen_padding_0: u32,
    pub seq: u64,
    pub bc: br_sslrec_ccm_context__bindgen_ty_2,
    pub iv: [cty::c_uchar; 4usize],
    pub tag_len: usize,
}
#[doc = " \\brief Pointer to vtable."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_sslrec_ccm_context__bindgen_ty_1 {
    pub gen: *const cty::c_void,
    pub in_: *const br_sslrec_in_ccm_class,
    pub out: *const br_sslrec_out_ccm_class,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_sslrec_ccm_context__bindgen_ty_2 {
    pub vtable: *const br_block_ctrcbc_class,
    pub aes: br_aes_gen_ctrcbc_keys,
    _bindgen_union_align: [u64; 32usize],
}
extern "C" {
    pub static br_sslrec_in_ccm_vtable: br_sslrec_in_ccm_class;
}
extern "C" {
    pub static br_sslrec_out_ccm_vtable: br_sslrec_out_ccm_class;
}
#[doc = " \\brief Type for session parameters, to be saved for session resumption."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_ssl_session_parameters {
    #[doc = " \\brief Session ID buffer."]
    pub session_id: [cty::c_uchar; 32usize],
    #[doc = " \\brief Session ID length (in bytes, at most 32)."]
    pub session_id_len: cty::c_uchar,
    #[doc = " \\brief Protocol version."]
    pub version: u16,
    #[doc = " \\brief Cipher suite."]
    pub cipher_suite: u16,
    #[doc = " \\brief Master secret."]
    pub master_secret: [cty::c_uchar; 48usize],
}
#[doc = " \\brief Context structure for SSL engine."]
#[doc = ""]
#[doc = " This strucuture is common to the client and server; both the client"]
#[doc = " context (`br_ssl_client_context`) and the server context"]
#[doc = " (`br_ssl_server_context`) include a `br_ssl_engine_context` as their"]
#[doc = " first field."]
#[doc = ""]
#[doc = " The engine context manages records, including alerts, closures, and"]
#[doc = " transitions to new encryption/MAC algorithms. Processing of handshake"]
#[doc = " records is delegated to externally provided code. This structure"]
#[doc = " should not be used directly."]
#[doc = ""]
#[doc = " Structure contents are opaque and shall not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_ssl_engine_context {
    pub err: cty::c_int,
    pub ibuf: *mut cty::c_uchar,
    pub obuf: *mut cty::c_uchar,
    pub ibuf_len: usize,
    pub obuf_len: usize,
    pub max_frag_len: u16,
    pub log_max_frag_len: cty::c_uchar,
    pub peer_log_max_frag_len: cty::c_uchar,
    pub ixa: usize,
    pub ixb: usize,
    pub ixc: usize,
    pub oxa: usize,
    pub oxb: usize,
    pub oxc: usize,
    pub iomode: cty::c_uchar,
    pub incrypt: cty::c_uchar,
    pub shutdown_recv: cty::c_uchar,
    pub record_type_in: cty::c_uchar,
    pub record_type_out: cty::c_uchar,
    pub version_in: u16,
    pub version_out: u16,
    pub __bindgen_padding_0: u32,
    pub in_: br_ssl_engine_context__bindgen_ty_1,
    pub out: br_ssl_engine_context__bindgen_ty_2,
    pub application_data: cty::c_uchar,
    pub rng: br_hmac_drbg_context,
    pub rng_init_done: cty::c_int,
    pub rng_os_rand_done: cty::c_int,
    pub version_min: u16,
    pub version_max: u16,
    pub suites_buf: [u16; 48usize],
    pub suites_num: cty::c_uchar,
    pub server_name: [cty::c_char; 256usize],
    pub client_random: [cty::c_uchar; 32usize],
    pub server_random: [cty::c_uchar; 32usize],
    pub session: br_ssl_session_parameters,
    pub ecdhe_curve: cty::c_uchar,
    pub ecdhe_point: [cty::c_uchar; 133usize],
    pub ecdhe_point_len: cty::c_uchar,
    pub reneg: cty::c_uchar,
    pub saved_finished: [cty::c_uchar; 24usize],
    pub flags: u32,
    pub cpu: br_ssl_engine_context__bindgen_ty_3,
    pub dp_stack: [u32; 32usize],
    pub rp_stack: [u32; 32usize],
    pub pad: [cty::c_uchar; 512usize],
    pub hbuf_in: *mut cty::c_uchar,
    pub hbuf_out: *mut cty::c_uchar,
    pub saved_hbuf_out: *mut cty::c_uchar,
    pub hlen_in: usize,
    pub hlen_out: usize,
    pub hsrun: ::core::option::Option<unsafe extern "C" fn(ctx: *mut cty::c_void)>,
    pub action: cty::c_uchar,
    pub alert: cty::c_uchar,
    pub close_received: cty::c_uchar,
    pub __bindgen_padding_1: u32,
    pub mhash: br_multihash_context,
    pub x509ctx: *mut *const br_x509_class,
    pub chain: *const br_x509_certificate,
    pub chain_len: usize,
    pub cert_cur: *const cty::c_uchar,
    pub cert_len: usize,
    pub protocol_names: *mut *const cty::c_char,
    pub protocol_names_num: u16,
    pub selected_protocol: u16,
    pub prf10: br_tls_prf_impl,
    pub prf_sha256: br_tls_prf_impl,
    pub prf_sha384: br_tls_prf_impl,
    pub iaes_cbcenc: *const br_block_cbcenc_class,
    pub iaes_cbcdec: *const br_block_cbcdec_class,
    pub iaes_ctr: *const br_block_ctr_class,
    pub iaes_ctrcbc: *const br_block_ctrcbc_class,
    pub ides_cbcenc: *const br_block_cbcenc_class,
    pub ides_cbcdec: *const br_block_cbcdec_class,
    pub ighash: br_ghash,
    pub ichacha: br_chacha20_run,
    pub ipoly: br_poly1305_run,
    pub icbc_in: *const br_sslrec_in_cbc_class,
    pub icbc_out: *const br_sslrec_out_cbc_class,
    pub igcm_in: *const br_sslrec_in_gcm_class,
    pub igcm_out: *const br_sslrec_out_gcm_class,
    pub ichapol_in: *const br_sslrec_in_chapol_class,
    pub ichapol_out: *const br_sslrec_out_chapol_class,
    pub iccm_in: *const br_sslrec_in_ccm_class,
    pub iccm_out: *const br_sslrec_out_ccm_class,
    pub iec: *const br_ec_impl,
    pub irsavrfy: br_rsa_pkcs1_vrfy,
    pub iecdsa: br_ecdsa_vrfy,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_ssl_engine_context__bindgen_ty_1 {
    pub vtable: *const br_sslrec_in_class,
    pub cbc: br_sslrec_in_cbc_context,
    pub gcm: br_sslrec_gcm_context,
    pub chapol: br_sslrec_chapol_context,
    pub ccm: br_sslrec_ccm_context,
    _bindgen_union_align: [u64; 71usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_ssl_engine_context__bindgen_ty_2 {
    pub vtable: *const br_sslrec_out_class,
    pub clear: br_sslrec_out_clear_context,
    pub cbc: br_sslrec_out_cbc_context,
    pub gcm: br_sslrec_gcm_context,
    pub chapol: br_sslrec_chapol_context,
    pub ccm: br_sslrec_ccm_context,
    _bindgen_union_align: [u64; 71usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_engine_context__bindgen_ty_3 {
    pub dp: *mut u32,
    pub rp: *mut u32,
    pub ip: *const cty::c_uchar,
}
extern "C" {
    #[doc = " \\brief Set the list of cipher suites advertised by this context."]
    #[doc = ""]
    #[doc = " The provided array is copied into the context. It is the caller"]
    #[doc = " responsibility to ensure that all provided suites will be supported"]
    #[doc = " by the context. The engine context has enough room to receive _all_"]
    #[doc = " suites supported by the implementation. The provided array MUST NOT"]
    #[doc = " contain duplicates."]
    #[doc = ""]
    #[doc = " If the engine is for a client, the \"signaling\" pseudo-cipher suite"]
    #[doc = " `TLS_FALLBACK_SCSV` can be added at the end of the list, if the"]
    #[doc = " calling application is performing a voluntary downgrade (voluntary"]
    #[doc = " downgrades are not recommended, but if such a downgrade is done, then"]
    #[doc = " adding the fallback pseudo-suite is a good idea)."]
    #[doc = ""]
    #[doc = " \\param cc           SSL engine context."]
    #[doc = " \\param suites       cipher suites."]
    #[doc = " \\param suites_num   number of cipher suites."]
    pub fn br_ssl_engine_set_suites(
        cc: *mut br_ssl_engine_context,
        suites: *const u16,
        suites_num: usize,
    );
}
extern "C" {
    #[doc = " \\brief Set the \"default\" AES/CBC implementations."]
    #[doc = ""]
    #[doc = " This function configures in the engine the AES implementations that"]
    #[doc = " should provide best runtime performance on the local system, while"]
    #[doc = " still being safe (in particular, constant-time). It also sets the"]
    #[doc = " handlers for CBC records."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    pub fn br_ssl_engine_set_default_aes_cbc(cc: *mut br_ssl_engine_context);
}
extern "C" {
    #[doc = " \\brief Set the \"default\" implementations for AES/GCM (AES/CTR + GHASH)."]
    #[doc = ""]
    #[doc = " This function configures in the engine the AES/CTR and GHASH"]
    #[doc = " implementation that should provide best runtime performance on the local"]
    #[doc = " system, while still being safe (in particular, constant-time). It also"]
    #[doc = " sets the handlers for GCM records."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    pub fn br_ssl_engine_set_default_aes_gcm(cc: *mut br_ssl_engine_context);
}
extern "C" {
    #[doc = " \\brief Set the \"default\" DES/CBC implementations."]
    #[doc = ""]
    #[doc = " This function configures in the engine the DES implementations that"]
    #[doc = " should provide best runtime performance on the local system, while"]
    #[doc = " still being safe (in particular, constant-time). It also sets the"]
    #[doc = " handlers for CBC records."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    pub fn br_ssl_engine_set_default_des_cbc(cc: *mut br_ssl_engine_context);
}
extern "C" {
    #[doc = " \\brief Set the \"default\" ChaCha20 and Poly1305 implementations."]
    #[doc = ""]
    #[doc = " This function configures in the engine the ChaCha20 and Poly1305"]
    #[doc = " implementations that should provide best runtime performance on the"]
    #[doc = " local system, while still being safe (in particular, constant-time)."]
    #[doc = " It also sets the handlers for ChaCha20+Poly1305 records."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    pub fn br_ssl_engine_set_default_chapol(cc: *mut br_ssl_engine_context);
}
extern "C" {
    #[doc = " \\brief Set the \"default\" implementations for AES/CCM."]
    #[doc = ""]
    #[doc = " This function configures in the engine the AES/CTR+CBC"]
    #[doc = " implementation that should provide best runtime performance on the local"]
    #[doc = " system, while still being safe (in particular, constant-time). It also"]
    #[doc = " sets the handlers for CCM records."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    pub fn br_ssl_engine_set_default_aes_ccm(cc: *mut br_ssl_engine_context);
}
extern "C" {
    #[doc = " \\brief Set the \"default\" EC implementation."]
    #[doc = ""]
    #[doc = " This function sets the elliptic curve implementation for ECDH and"]
    #[doc = " ECDHE cipher suites, and for ECDSA support. It selects the fastest"]
    #[doc = " implementation on the current system."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    pub fn br_ssl_engine_set_default_ec(cc: *mut br_ssl_engine_context);
}
extern "C" {
    #[doc = " \\brief Set the \"default\" RSA implementation (signature verification)."]
    #[doc = ""]
    #[doc = " This function sets the RSA implementation (signature verification)"]
    #[doc = " to the fastest implementation available on the current platform."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    pub fn br_ssl_engine_set_default_rsavrfy(cc: *mut br_ssl_engine_context);
}
extern "C" {
    #[doc = " \\brief Set the \"default\" ECDSA implementation (signature verification)."]
    #[doc = ""]
    #[doc = " This function sets the ECDSA implementation (signature verification)"]
    #[doc = " to the fastest implementation available on the current platform. This"]
    #[doc = " call also sets the elliptic curve implementation itself, there again"]
    #[doc = " to the fastest EC implementation available."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    pub fn br_ssl_engine_set_default_ecdsa(cc: *mut br_ssl_engine_context);
}
extern "C" {
    #[doc = " \\brief Set the I/O buffer for the SSL engine."]
    #[doc = ""]
    #[doc = " Once this call has been made, `br_ssl_client_reset()` or"]
    #[doc = " `br_ssl_server_reset()` MUST be called before using the context."]
    #[doc = ""]
    #[doc = " The provided buffer will be used as long as the engine context is"]
    #[doc = " used. The caller is responsible for keeping it available."]
    #[doc = ""]
    #[doc = " If `bidi` is 0, then the engine will operate in half-duplex mode"]
    #[doc = " (it won't be able to send data while there is unprocessed incoming"]
    #[doc = " data in the buffer, and it won't be able to receive data while there"]
    #[doc = " is unsent data in the buffer). The optimal buffer size in half-duplex"]
    #[doc = " mode is `BR_SSL_BUFSIZE_MONO`; if the buffer is larger, then extra"]
    #[doc = " bytes are ignored. If the buffer is smaller, then this limits the"]
    #[doc = " capacity of the engine to support all allowed record sizes."]
    #[doc = ""]
    #[doc = " If `bidi` is 1, then the engine will split the buffer into two"]
    #[doc = " parts, for separate handling of outgoing and incoming data. This"]
    #[doc = " enables full-duplex processing, but requires more RAM. The optimal"]
    #[doc = " buffer size in full-duplex mode is `BR_SSL_BUFSIZE_BIDI`; if the"]
    #[doc = " buffer is larger, then extra bytes are ignored. If the buffer is"]
    #[doc = " smaller, then the split will favour the incoming part, so that"]
    #[doc = " interoperability is maximised."]
    #[doc = ""]
    #[doc = " \\param cc          SSL engine context"]
    #[doc = " \\param iobuf       I/O buffer."]
    #[doc = " \\param iobuf_len   I/O buffer length (in bytes)."]
    #[doc = " \\param bidi        non-zero for full-duplex mode."]
    pub fn br_ssl_engine_set_buffer(
        cc: *mut br_ssl_engine_context,
        iobuf: *mut cty::c_void,
        iobuf_len: usize,
        bidi: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Set the I/O buffers for the SSL engine."]
    #[doc = ""]
    #[doc = " Once this call has been made, `br_ssl_client_reset()` or"]
    #[doc = " `br_ssl_server_reset()` MUST be called before using the context."]
    #[doc = ""]
    #[doc = " This function is similar to `br_ssl_engine_set_buffer()`, except"]
    #[doc = " that it enforces full-duplex mode, and the two I/O buffers are"]
    #[doc = " provided as separate chunks."]
    #[doc = ""]
    #[doc = " The macros `BR_SSL_BUFSIZE_INPUT` and `BR_SSL_BUFSIZE_OUTPUT`"]
    #[doc = " evaluate to the optimal (maximum) sizes for the input and output"]
    #[doc = " buffer, respectively."]
    #[doc = ""]
    #[doc = " \\param cc         SSL engine context"]
    #[doc = " \\param ibuf       input buffer."]
    #[doc = " \\param ibuf_len   input buffer length (in bytes)."]
    #[doc = " \\param obuf       output buffer."]
    #[doc = " \\param obuf_len   output buffer length (in bytes)."]
    pub fn br_ssl_engine_set_buffers_bidi(
        cc: *mut br_ssl_engine_context,
        ibuf: *mut cty::c_void,
        ibuf_len: usize,
        obuf: *mut cty::c_void,
        obuf_len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Inject some \"initial entropy\" in the context."]
    #[doc = ""]
    #[doc = " This entropy will be added to what can be obtained from the"]
    #[doc = " underlying operating system, if that OS is supported."]
    #[doc = ""]
    #[doc = " This function may be called several times; all injected entropy chunks"]
    #[doc = " are cumulatively mixed."]
    #[doc = ""]
    #[doc = " If entropy gathering from the OS is supported and compiled in, then this"]
    #[doc = " step is optional. Otherwise, it is mandatory to inject randomness, and"]
    #[doc = " the caller MUST take care to push (as one or several successive calls)"]
    #[doc = " enough entropy to achieve cryptographic resistance (at least 80 bits,"]
    #[doc = " preferably 128 or more). The engine will report an error if no entropy"]
    #[doc = " was provided and none can be obtained from the OS."]
    #[doc = ""]
    #[doc = " Take care that this function cannot assess the cryptographic quality of"]
    #[doc = " the provided bytes."]
    #[doc = ""]
    #[doc = " In all generality, \"entropy\" must here be considered to mean \"that"]
    #[doc = " which the attacker cannot predict\". If your OS/architecture does not"]
    #[doc = " have a suitable source of randomness, then you can make do with the"]
    #[doc = " combination of a large enough secret value (possibly a copy of an"]
    #[doc = " asymmetric private key that you also store on the system) AND a"]
    #[doc = " non-repeating value (e.g. current time, provided that the local clock"]
    #[doc = " cannot be reset or altered by the attacker)."]
    #[doc = ""]
    #[doc = " \\param cc     SSL engine context."]
    #[doc = " \\param data   extra entropy to inject."]
    #[doc = " \\param len    length of the extra data (in bytes)."]
    pub fn br_ssl_engine_inject_entropy(
        cc: *mut br_ssl_engine_context,
        data: *const cty::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Get the current engine state."]
    #[doc = ""]
    #[doc = " An SSL engine (client or server) has, at any time, a state which is"]
    #[doc = " the combination of zero, one or more of these flags:"]
    #[doc = ""]
    #[doc = "   - `BR_SSL_CLOSED`"]
    #[doc = ""]
    #[doc = "     Engine is finished, no more I/O (until next reset)."]
    #[doc = ""]
    #[doc = "   - `BR_SSL_SENDREC`"]
    #[doc = ""]
    #[doc = "     Engine has some bytes to send to the peer."]
    #[doc = ""]
    #[doc = "   - `BR_SSL_RECVREC`"]
    #[doc = ""]
    #[doc = "     Engine expects some bytes from the peer."]
    #[doc = ""]
    #[doc = "   - `BR_SSL_SENDAPP`"]
    #[doc = ""]
    #[doc = "     Engine may receive application data to send (or flush)."]
    #[doc = ""]
    #[doc = "   - `BR_SSL_RECVAPP`"]
    #[doc = ""]
    #[doc = "     Engine has obtained some application data from the peer,"]
    #[doc = "     that should be read by the caller."]
    #[doc = ""]
    #[doc = " If no flag at all is set (state value is 0), then the engine is not"]
    #[doc = " fully initialised yet."]
    #[doc = ""]
    #[doc = " The `BR_SSL_CLOSED` flag is exclusive; when it is set, no other flag"]
    #[doc = " is set. To distinguish between a normal closure and an error, use"]
    #[doc = " `br_ssl_engine_last_error()`."]
    #[doc = ""]
    #[doc = " Generally speaking, `BR_SSL_SENDREC` and `BR_SSL_SENDAPP` are mutually"]
    #[doc = " exclusive: the input buffer, at any point, either accumulates"]
    #[doc = " plaintext data, or contains an assembled record that is being sent."]
    #[doc = " Similarly, `BR_SSL_RECVREC` and `BR_SSL_RECVAPP` are mutually exclusive."]
    #[doc = " This may change in a future library version."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    #[doc = " \\return  the current engine state."]
    pub fn br_ssl_engine_current_state(cc: *const br_ssl_engine_context) -> cty::c_uint;
}
extern "C" {
    #[doc = " \\brief Get buffer for application data to send."]
    #[doc = ""]
    #[doc = " If the engine is ready to accept application data to send to the"]
    #[doc = " peer, then this call returns a pointer to the buffer where such"]
    #[doc = " data shall be written, and its length is written in `*len`."]
    #[doc = " Otherwise, `*len` is set to 0 and `NULL` is returned."]
    #[doc = ""]
    #[doc = " \\param cc    SSL engine context."]
    #[doc = " \\param len   receives the application data output buffer length, or 0."]
    #[doc = " \\return  the application data output buffer, or `NULL`."]
    pub fn br_ssl_engine_sendapp_buf(
        cc: *const br_ssl_engine_context,
        len: *mut usize,
    ) -> *mut cty::c_uchar;
}
extern "C" {
    #[doc = " \\brief Inform the engine of some new application data."]
    #[doc = ""]
    #[doc = " After writing `len` bytes in the buffer returned by"]
    #[doc = " `br_ssl_engine_sendapp_buf()`, the application shall call this"]
    #[doc = " function to trigger any relevant processing. The `len` parameter"]
    #[doc = " MUST NOT be 0, and MUST NOT exceed the value obtained in the"]
    #[doc = " `br_ssl_engine_sendapp_buf()` call."]
    #[doc = ""]
    #[doc = " \\param cc    SSL engine context."]
    #[doc = " \\param len   number of bytes pushed (not zero)."]
    pub fn br_ssl_engine_sendapp_ack(cc: *mut br_ssl_engine_context, len: usize);
}
extern "C" {
    #[doc = " \\brief Get buffer for received application data."]
    #[doc = ""]
    #[doc = " If the engine has received application data from the peer, then this"]
    #[doc = " call returns a pointer to the buffer from where such data shall be"]
    #[doc = " read, and its length is written in `*len`. Otherwise, `*len` is set"]
    #[doc = " to 0 and `NULL` is returned."]
    #[doc = ""]
    #[doc = " \\param cc    SSL engine context."]
    #[doc = " \\param len   receives the application data input buffer length, or 0."]
    #[doc = " \\return  the application data input buffer, or `NULL`."]
    pub fn br_ssl_engine_recvapp_buf(
        cc: *const br_ssl_engine_context,
        len: *mut usize,
    ) -> *mut cty::c_uchar;
}
extern "C" {
    #[doc = " \\brief Acknowledge some received application data."]
    #[doc = ""]
    #[doc = " After reading `len` bytes from the buffer returned by"]
    #[doc = " `br_ssl_engine_recvapp_buf()`, the application shall call this"]
    #[doc = " function to trigger any relevant processing. The `len` parameter"]
    #[doc = " MUST NOT be 0, and MUST NOT exceed the value obtained in the"]
    #[doc = " `br_ssl_engine_recvapp_buf()` call."]
    #[doc = ""]
    #[doc = " \\param cc    SSL engine context."]
    #[doc = " \\param len   number of bytes read (not zero)."]
    pub fn br_ssl_engine_recvapp_ack(cc: *mut br_ssl_engine_context, len: usize);
}
extern "C" {
    #[doc = " \\brief Get buffer for record data to send."]
    #[doc = ""]
    #[doc = " If the engine has prepared some records to send to the peer, then this"]
    #[doc = " call returns a pointer to the buffer from where such data shall be"]
    #[doc = " read, and its length is written in `*len`. Otherwise, `*len` is set"]
    #[doc = " to 0 and `NULL` is returned."]
    #[doc = ""]
    #[doc = " \\param cc    SSL engine context."]
    #[doc = " \\param len   receives the record data output buffer length, or 0."]
    #[doc = " \\return  the record data output buffer, or `NULL`."]
    pub fn br_ssl_engine_sendrec_buf(
        cc: *const br_ssl_engine_context,
        len: *mut usize,
    ) -> *mut cty::c_uchar;
}
extern "C" {
    #[doc = " \\brief Acknowledge some sent record data."]
    #[doc = ""]
    #[doc = " After reading `len` bytes from the buffer returned by"]
    #[doc = " `br_ssl_engine_sendrec_buf()`, the application shall call this"]
    #[doc = " function to trigger any relevant processing. The `len` parameter"]
    #[doc = " MUST NOT be 0, and MUST NOT exceed the value obtained in the"]
    #[doc = " `br_ssl_engine_sendrec_buf()` call."]
    #[doc = ""]
    #[doc = " \\param cc    SSL engine context."]
    #[doc = " \\param len   number of bytes read (not zero)."]
    pub fn br_ssl_engine_sendrec_ack(cc: *mut br_ssl_engine_context, len: usize);
}
extern "C" {
    #[doc = " \\brief Get buffer for incoming records."]
    #[doc = ""]
    #[doc = " If the engine is ready to accept records from the peer, then this"]
    #[doc = " call returns a pointer to the buffer where such data shall be"]
    #[doc = " written, and its length is written in `*len`. Otherwise, `*len` is"]
    #[doc = " set to 0 and `NULL` is returned."]
    #[doc = ""]
    #[doc = " \\param cc    SSL engine context."]
    #[doc = " \\param len   receives the record data input buffer length, or 0."]
    #[doc = " \\return  the record data input buffer, or `NULL`."]
    pub fn br_ssl_engine_recvrec_buf(
        cc: *const br_ssl_engine_context,
        len: *mut usize,
    ) -> *mut cty::c_uchar;
}
extern "C" {
    #[doc = " \\brief Inform the engine of some new record data."]
    #[doc = ""]
    #[doc = " After writing `len` bytes in the buffer returned by"]
    #[doc = " `br_ssl_engine_recvrec_buf()`, the application shall call this"]
    #[doc = " function to trigger any relevant processing. The `len` parameter"]
    #[doc = " MUST NOT be 0, and MUST NOT exceed the value obtained in the"]
    #[doc = " `br_ssl_engine_recvrec_buf()` call."]
    #[doc = ""]
    #[doc = " \\param cc    SSL engine context."]
    #[doc = " \\param len   number of bytes pushed (not zero)."]
    pub fn br_ssl_engine_recvrec_ack(cc: *mut br_ssl_engine_context, len: usize);
}
extern "C" {
    #[doc = " \\brief Flush buffered application data."]
    #[doc = ""]
    #[doc = " If some application data has been buffered in the engine, then wrap"]
    #[doc = " it into a record and mark it for sending. If no application data has"]
    #[doc = " been buffered but the engine would be ready to accept some, AND the"]
    #[doc = " `force` parameter is non-zero, then an empty record is assembled and"]
    #[doc = " marked for sending. In all other cases, this function does nothing."]
    #[doc = ""]
    #[doc = " Empty records are technically legal, but not all existing SSL/TLS"]
    #[doc = " implementations support them. Empty records can be useful as a"]
    #[doc = " transparent \"keep-alive\" mechanism to maintain some low-level"]
    #[doc = " network activity."]
    #[doc = ""]
    #[doc = " \\param cc      SSL engine context."]
    #[doc = " \\param force   non-zero to force sending an empty record."]
    pub fn br_ssl_engine_flush(cc: *mut br_ssl_engine_context, force: cty::c_int);
}
extern "C" {
    #[doc = " \\brief Initiate a closure."]
    #[doc = ""]
    #[doc = " If, at that point, the context is open and in ready state, then a"]
    #[doc = " `close_notify` alert is assembled and marked for sending; this"]
    #[doc = " triggers the closure protocol. Otherwise, no such alert is assembled."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    pub fn br_ssl_engine_close(cc: *mut br_ssl_engine_context);
}
extern "C" {
    #[doc = " \\brief Initiate a renegotiation."]
    #[doc = ""]
    #[doc = " If the engine is failed or closed, or if the peer is known not to"]
    #[doc = " support secure renegotiation (RFC 5746), or if renegotiations have"]
    #[doc = " been disabled with the `BR_OPT_NO_RENEGOTIATION` flag, or if there"]
    #[doc = " is buffered incoming application data, then this function returns 0"]
    #[doc = " and nothing else happens."]
    #[doc = ""]
    #[doc = " Otherwise, this function returns 1, and a renegotiation attempt is"]
    #[doc = " triggered (if a handshake is already ongoing at that point, then"]
    #[doc = " no new handshake is triggered)."]
    #[doc = ""]
    #[doc = " \\param cc   SSL engine context."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_ssl_engine_renegotiate(cc: *mut br_ssl_engine_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Export key material from a connected SSL engine (RFC 5705)."]
    #[doc = ""]
    #[doc = " This calls compute a secret key of arbitrary length from the master"]
    #[doc = " secret of a connected SSL engine. If the provided context is not"]
    #[doc = " currently in \"application data\" state (initial handshake is not"]
    #[doc = " finished, another handshake is ongoing, or the connection failed or"]
    #[doc = " was closed), then this function returns 0. Otherwise, a secret key of"]
    #[doc = " length `len` bytes is computed and written in the buffer pointed to"]
    #[doc = " by `dst`, and 1 is returned."]
    #[doc = ""]
    #[doc = " The computed key follows the specification described in RFC 5705."]
    #[doc = " That RFC includes two key computations, with and without a \"context"]
    #[doc = " value\". If `context` is `NULL`, then the variant without context is"]
    #[doc = " used; otherwise, the `context_len` bytes located at the address"]
    #[doc = " pointed to by `context` are used in the computation. Note that it"]
    #[doc = " is possible to have a \"with context\" key with a context length of"]
    #[doc = " zero bytes, by setting `context` to a non-`NULL` value but"]
    #[doc = " `context_len` to 0."]
    #[doc = ""]
    #[doc = " When context bytes are used, the context length MUST NOT exceed"]
    #[doc = " 65535 bytes."]
    #[doc = ""]
    #[doc = " \\param cc            SSL engine context."]
    #[doc = " \\param dst           destination buffer for exported key."]
    #[doc = " \\param len           exported key length (in bytes)."]
    #[doc = " \\param label         disambiguation label."]
    #[doc = " \\param context       context value (or `NULL`)."]
    #[doc = " \\param context_len   context length (in bytes)."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_ssl_key_export(
        cc: *mut br_ssl_engine_context,
        dst: *mut cty::c_void,
        len: usize,
        label: *const cty::c_char,
        context: *const cty::c_void,
        context_len: usize,
    ) -> cty::c_int;
}
pub type br_ssl_client_context = br_ssl_client_context_;
#[doc = " \\brief Type for the client certificate, if requested by the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_client_certificate {
    #[doc = " \\brief Authentication type."]
    #[doc = ""]
    #[doc = " This is either `BR_AUTH_RSA` (RSA signature), `BR_AUTH_ECDSA`"]
    #[doc = " (ECDSA signature), or `BR_AUTH_ECDH` (static ECDH key exchange)."]
    pub auth_type: cty::c_int,
    #[doc = " \\brief Hash function for computing the CertificateVerify."]
    #[doc = ""]
    #[doc = " This is the symbolic identifier for the hash function that"]
    #[doc = " will be used to produce the hash of handshake messages, to"]
    #[doc = " be signed into the CertificateVerify. For full static ECDH"]
    #[doc = " (client and server certificates are both EC in the same"]
    #[doc = " curve, and static ECDH is used), this value is set to -1."]
    #[doc = ""]
    #[doc = " Take care that with TLS 1.0 and 1.1, that value MUST match"]
    #[doc = " the protocol requirements: value must be 0 (MD5+SHA-1) for"]
    #[doc = " a RSA signature, or 2 (SHA-1) for an ECDSA signature. Only"]
    #[doc = " TLS 1.2 allows for other hash functions."]
    pub hash_id: cty::c_int,
    #[doc = " \\brief Certificate chain to send to the server."]
    #[doc = ""]
    #[doc = " This is an array of `br_x509_certificate` objects, each"]
    #[doc = " normally containing a DER-encoded certificate. The client"]
    #[doc = " code does not try to decode these elements. If there is no"]
    #[doc = " chain to send to the server, then this pointer shall be"]
    #[doc = " set to `NULL`."]
    pub chain: *const br_x509_certificate,
    #[doc = " \\brief Certificate chain length (number of certificates)."]
    #[doc = ""]
    #[doc = " If there is no chain to send to the server, then this value"]
    #[doc = " shall be set to 0."]
    pub chain_len: usize,
}
#[doc = " \\brief Class type for a certificate handler (client side)."]
#[doc = ""]
#[doc = " A certificate handler selects a client certificate chain to send to"]
#[doc = " the server, upon explicit request from that server. It receives"]
#[doc = " the list of trust anchor DN from the server, and supported types"]
#[doc = " of certificates and signatures, and returns the chain to use. It"]
#[doc = " is also invoked to perform the corresponding private key operation"]
#[doc = " (a signature, or an ECDH computation)."]
#[doc = ""]
#[doc = " The SSL client engine will first push the trust anchor DN with"]
#[doc = " `start_name_list()`, `start_name()`, `append_name()`, `end_name()`"]
#[doc = " and `end_name_list()`. Then it will call `choose()`, to select the"]
#[doc = " actual chain (and signature/hash algorithms). Finally, it will call"]
#[doc = " either `do_sign()` or `do_keyx()`, depending on the algorithm choices."]
pub type br_ssl_client_certificate_class = br_ssl_client_certificate_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_client_certificate_class_ {
    #[doc = " \\brief Context size (in bytes)."]
    pub context_size: usize,
    #[doc = " \\brief Begin reception of a list of trust anchor names. This"]
    #[doc = " is called while parsing the incoming CertificateRequest."]
    #[doc = ""]
    #[doc = " \\param pctx   certificate handler context."]
    pub start_name_list: ::core::option::Option<
        unsafe extern "C" fn(pctx: *mut *const br_ssl_client_certificate_class),
    >,
    #[doc = " \\brief Begin reception of a new trust anchor name."]
    #[doc = ""]
    #[doc = " The total encoded name length is provided; it is less than"]
    #[doc = " 65535 bytes."]
    #[doc = ""]
    #[doc = " \\param pctx   certificate handler context."]
    #[doc = " \\param len    encoded name length (in bytes)."]
    pub start_name: ::core::option::Option<
        unsafe extern "C" fn(pctx: *mut *const br_ssl_client_certificate_class, len: usize),
    >,
    #[doc = " \\brief Receive some more bytes for the current trust anchor name."]
    #[doc = ""]
    #[doc = " The provided reference (`data`) points to a transient buffer"]
    #[doc = " they may be reused as soon as this function returns. The chunk"]
    #[doc = " length (`len`) is never zero."]
    #[doc = ""]
    #[doc = " \\param pctx   certificate handler context."]
    #[doc = " \\param data   anchor name chunk."]
    #[doc = " \\param len    anchor name chunk length (in bytes)."]
    pub append_name: ::core::option::Option<
        unsafe extern "C" fn(
            pctx: *mut *const br_ssl_client_certificate_class,
            data: *const cty::c_uchar,
            len: usize,
        ),
    >,
    #[doc = " \\brief End current trust anchor name."]
    #[doc = ""]
    #[doc = " This function is called when all the encoded anchor name data"]
    #[doc = " has been provided."]
    #[doc = ""]
    #[doc = " \\param pctx   certificate handler context."]
    pub end_name: ::core::option::Option<
        unsafe extern "C" fn(pctx: *mut *const br_ssl_client_certificate_class),
    >,
    #[doc = " \\brief End list of trust anchor names."]
    #[doc = ""]
    #[doc = " This function is called when all the anchor names in the"]
    #[doc = " CertificateRequest message have been obtained."]
    #[doc = ""]
    #[doc = " \\param pctx   certificate handler context."]
    pub end_name_list: ::core::option::Option<
        unsafe extern "C" fn(pctx: *mut *const br_ssl_client_certificate_class),
    >,
    #[doc = " \\brief Select client certificate and algorithms."]
    #[doc = ""]
    #[doc = " This callback function shall fill the provided `choices`"]
    #[doc = " structure with the selected algorithms and certificate chain."]
    #[doc = " The `hash_id`, `chain` and `chain_len` fields must be set. If"]
    #[doc = " the client cannot or does not wish to send a certificate,"]
    #[doc = " then it shall set `chain` to `NULL` and `chain_len` to 0."]
    #[doc = ""]
    #[doc = " The `auth_types` parameter describes the authentication types,"]
    #[doc = " signature algorithms and hash functions that are supported by"]
    #[doc = " both the client context and the server, and compatible with"]
    #[doc = " the current protocol version. This is a bit field with the"]
    #[doc = " following contents:"]
    #[doc = ""]
    #[doc = "   - If RSA signatures with hash function x are supported, then"]
    #[doc = "     bit x is set."]
    #[doc = ""]
    #[doc = "   - If ECDSA signatures with hash function x are supported,"]
    #[doc = "     then bit 8+x is set."]
    #[doc = ""]
    #[doc = "   - If static ECDH is supported, with a RSA-signed certificate,"]
    #[doc = "     then bit 16 is set."]
    #[doc = ""]
    #[doc = "   - If static ECDH is supported, with an ECDSA-signed certificate,"]
    #[doc = "     then bit 17 is set."]
    #[doc = ""]
    #[doc = " Notes:"]
    #[doc = ""]
    #[doc = "   - When using TLS 1.0 or 1.1, the hash function for RSA"]
    #[doc = "     signatures is always the special MD5+SHA-1 (id 0), and the"]
    #[doc = "     hash function for ECDSA signatures is always SHA-1 (id 2)."]
    #[doc = ""]
    #[doc = "   - When using TLS 1.2, the list of hash functions is trimmed"]
    #[doc = "     down to include only hash functions that the client context"]
    #[doc = "     can support. The actual server list can be obtained with"]
    #[doc = "     `br_ssl_client_get_server_hashes()`; that list may be used"]
    #[doc = "     to select the certificate chain to send to the server."]
    #[doc = ""]
    #[doc = " \\param pctx         certificate handler context."]
    #[doc = " \\param cc           SSL client context."]
    #[doc = " \\param auth_types   supported authentication types and algorithms."]
    #[doc = " \\param choices      destination structure for the policy choices."]
    pub choose: ::core::option::Option<
        unsafe extern "C" fn(
            pctx: *mut *const br_ssl_client_certificate_class,
            cc: *const br_ssl_client_context,
            auth_types: u32,
            choices: *mut br_ssl_client_certificate,
        ),
    >,
    #[doc = " \\brief Perform key exchange (client part)."]
    #[doc = ""]
    #[doc = " This callback is invoked in case of a full static ECDH key"]
    #[doc = " exchange:"]
    #[doc = ""]
    #[doc = "   - the cipher suite uses `ECDH_RSA` or `ECDH_ECDSA`;"]
    #[doc = ""]
    #[doc = "   - the server requests a client certificate;"]
    #[doc = ""]
    #[doc = "   - the client has, and sends, a client certificate that"]
    #[doc = "     uses an EC key in the same curve as the server's key,"]
    #[doc = "     and chooses static ECDH (the `hash_id` field in the choice"]
    #[doc = "     structure was set to -1)."]
    #[doc = ""]
    #[doc = " In that situation, this callback is invoked to compute the"]
    #[doc = " client-side ECDH: the provided `data` (of length `*len` bytes)"]
    #[doc = " is the server's public key point (as decoded from its"]
    #[doc = " certificate), and the client shall multiply that point with"]
    #[doc = " its own private key, and write back the X coordinate of the"]
    #[doc = " resulting point in the same buffer, starting at offset 0."]
    #[doc = " The `*len` value shall be modified to designate the actual"]
    #[doc = " length of the X coordinate."]
    #[doc = ""]
    #[doc = " The callback must uphold the following:"]
    #[doc = ""]
    #[doc = "   - If the input array does not have the proper length for"]
    #[doc = "     an encoded curve point, then an error (0) shall be reported."]
    #[doc = ""]
    #[doc = "   - If the input array has the proper length, then processing"]
    #[doc = "     MUST be constant-time, even if the data is not a valid"]
    #[doc = "     encoded point."]
    #[doc = ""]
    #[doc = "   - This callback MUST check that the input point is valid."]
    #[doc = ""]
    #[doc = " Returned value is 1 on success, 0 on error."]
    #[doc = ""]
    #[doc = " \\param pctx   certificate handler context."]
    #[doc = " \\param data   server public key point."]
    #[doc = " \\param len    public key point length / X coordinate length."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub do_keyx: ::core::option::Option<
        unsafe extern "C" fn(
            pctx: *mut *const br_ssl_client_certificate_class,
            data: *mut cty::c_uchar,
            len: *mut usize,
        ) -> u32,
    >,
    #[doc = " \\brief Perform a signature (client authentication)."]
    #[doc = ""]
    #[doc = " This callback is invoked when a client certificate was sent,"]
    #[doc = " and static ECDH is not used. It shall compute a signature,"]
    #[doc = " using the client's private key, over the provided hash value"]
    #[doc = " (which is the hash of all previous handshake messages)."]
    #[doc = ""]
    #[doc = " On input, the hash value to sign is in `data`, of size"]
    #[doc = " `hv_len`; the involved hash function is identified by"]
    #[doc = " `hash_id`. The signature shall be computed and written"]
    #[doc = " back into `data`; the total size of that buffer is `len`"]
    #[doc = " bytes."]
    #[doc = ""]
    #[doc = " This callback shall verify that the signature length does not"]
    #[doc = " exceed `len` bytes, and abstain from writing the signature if"]
    #[doc = " it does not fit."]
    #[doc = ""]
    #[doc = " For RSA signatures, the `hash_id` may be 0, in which case"]
    #[doc = " this is the special header-less signature specified in TLS 1.0"]
    #[doc = " and 1.1, with a 36-byte hash value. Otherwise, normal PKCS#1"]
    #[doc = " v1.5 signatures shall be computed."]
    #[doc = ""]
    #[doc = " For ECDSA signatures, the signature value shall use the ASN.1"]
    #[doc = " based encoding."]
    #[doc = ""]
    #[doc = " Returned value is the signature length (in bytes), or 0 on error."]
    #[doc = ""]
    #[doc = " \\param pctx      certificate handler context."]
    #[doc = " \\param hash_id   hash function identifier."]
    #[doc = " \\param hv_len    hash value length (in bytes)."]
    #[doc = " \\param data      input/output buffer (hash value, then signature)."]
    #[doc = " \\param len       total buffer length (in bytes)."]
    #[doc = " \\return  signature length (in bytes) on success, or 0 on error."]
    pub do_sign: ::core::option::Option<
        unsafe extern "C" fn(
            pctx: *mut *const br_ssl_client_certificate_class,
            hash_id: cty::c_int,
            hv_len: usize,
            data: *mut cty::c_uchar,
            len: usize,
        ) -> usize,
    >,
}
#[doc = " \\brief A single-chain RSA client certificate handler."]
#[doc = ""]
#[doc = " This handler uses a single certificate chain, with a RSA"]
#[doc = " signature. The list of trust anchor DN is ignored."]
#[doc = ""]
#[doc = " Apart from the first field (vtable pointer), its contents are"]
#[doc = " opaque and shall not be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_client_certificate_rsa_context {
    #[doc = " \\brief Pointer to vtable."]
    pub vtable: *const br_ssl_client_certificate_class,
    pub chain: *const br_x509_certificate,
    pub chain_len: usize,
    pub sk: *const br_rsa_private_key,
    pub irsasign: br_rsa_pkcs1_sign,
}
#[doc = " \\brief A single-chain EC client certificate handler."]
#[doc = ""]
#[doc = " This handler uses a single certificate chain, with a RSA"]
#[doc = " signature. The list of trust anchor DN is ignored."]
#[doc = ""]
#[doc = " This handler may support both static ECDH, and ECDSA signatures"]
#[doc = " (either usage may be selectively disabled)."]
#[doc = ""]
#[doc = " Apart from the first field (vtable pointer), its contents are"]
#[doc = " opaque and shall not be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_client_certificate_ec_context {
    #[doc = " \\brief Pointer to vtable."]
    pub vtable: *const br_ssl_client_certificate_class,
    pub chain: *const br_x509_certificate,
    pub chain_len: usize,
    pub sk: *const br_ec_private_key,
    pub allowed_usages: cty::c_uint,
    pub issuer_key_type: cty::c_uint,
    pub mhash: *const br_multihash_context,
    pub iec: *const br_ec_impl,
    pub iecdsa: br_ecdsa_sign,
}
#[doc = " \\brief Context structure for a SSL client."]
#[doc = ""]
#[doc = " The first field (called `eng`) is the SSL engine; all functions that"]
#[doc = " work on a `br_ssl_engine_context` structure shall take as parameter"]
#[doc = " a pointer to that field. The other structure fields are opaque and"]
#[doc = " must not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_ssl_client_context_ {
    #[doc = " \\brief The encapsulated engine context."]
    pub eng: br_ssl_engine_context,
    pub min_clienthello_len: u16,
    pub hashes: u32,
    pub server_curve: cty::c_int,
    pub client_auth_vtable: *mut *const br_ssl_client_certificate_class,
    pub auth_type: cty::c_uchar,
    pub hash_id: cty::c_uchar,
    pub client_auth: br_ssl_client_context___bindgen_ty_1,
    pub irsapub: br_rsa_public,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_ssl_client_context___bindgen_ty_1 {
    pub vtable: *const br_ssl_client_certificate_class,
    pub single_rsa: br_ssl_client_certificate_rsa_context,
    pub single_ec: br_ssl_client_certificate_ec_context,
    _bindgen_union_align: [u32; 9usize],
}
extern "C" {
    #[doc = " \\brief SSL client profile: full."]
    #[doc = ""]
    #[doc = " This function initialises the provided SSL client context with"]
    #[doc = " all supported algorithms and cipher suites. It also initialises"]
    #[doc = " a companion X.509 validation engine with all supported algorithms,"]
    #[doc = " and the provided trust anchors; the X.509 engine will be used by"]
    #[doc = " the client context to validate the server's certificate."]
    #[doc = ""]
    #[doc = " \\param cc                  client context to initialise."]
    #[doc = " \\param xc                  X.509 validation context to initialise."]
    #[doc = " \\param trust_anchors       trust anchors to use."]
    #[doc = " \\param trust_anchors_num   number of trust anchors."]
    pub fn br_ssl_client_init_full(
        cc: *mut br_ssl_client_context,
        xc: *mut br_x509_minimal_context,
        trust_anchors: *const br_x509_trust_anchor,
        trust_anchors_num: usize,
    );
}
extern "C" {
    #[doc = " \\brief Clear the complete contents of a SSL client context."]
    #[doc = ""]
    #[doc = " Everything is cleared, including the reference to the configured buffer,"]
    #[doc = " implementations, cipher suites and state. This is a preparatory step"]
    #[doc = " to assembling a custom profile."]
    #[doc = ""]
    #[doc = " \\param cc   client context to clear."]
    pub fn br_ssl_client_zero(cc: *mut br_ssl_client_context);
}
extern "C" {
    #[doc = " \\brief Set the \"default\" RSA implementation for public-key operations."]
    #[doc = ""]
    #[doc = " This sets the RSA implementation in the client context (for encrypting"]
    #[doc = " the pre-master secret, in `TLS_RSA_*` cipher suites) to the fastest"]
    #[doc = " available on the current platform."]
    #[doc = ""]
    #[doc = " \\param cc   client context."]
    pub fn br_ssl_client_set_default_rsapub(cc: *mut br_ssl_client_context);
}
extern "C" {
    #[doc = " \\brief Prepare or reset a client context for a new connection."]
    #[doc = ""]
    #[doc = " The `server_name` parameter is used to fill the SNI extension; the"]
    #[doc = " X.509 \"minimal\" engine will also match that name against the server"]
    #[doc = " names included in the server's certificate. If the parameter is"]
    #[doc = " `NULL` then no SNI extension will be sent, and the X.509 \"minimal\""]
    #[doc = " engine (if used for server certificate validation) will not check"]
    #[doc = " presence of any specific name in the received certificate."]
    #[doc = ""]
    #[doc = " Therefore, setting the `server_name` to `NULL` shall be reserved"]
    #[doc = " to cases where alternate or additional methods are used to ascertain"]
    #[doc = " that the right server public key is used (e.g. a \"known key\" model)."]
    #[doc = ""]
    #[doc = " If `resume_session` is non-zero and the context was previously used"]
    #[doc = " then the session parameters may be reused (depending on whether the"]
    #[doc = " server previously sent a non-empty session ID, and accepts the session"]
    #[doc = " resumption). The session parameters for session resumption can also"]
    #[doc = " be set explicitly with `br_ssl_engine_set_session_parameters()`."]
    #[doc = ""]
    #[doc = " On failure, the context is marked as failed, and this function"]
    #[doc = " returns 0. A possible failure condition is when no initial entropy"]
    #[doc = " was injected, and none could be obtained from the OS (either OS"]
    #[doc = " randomness gathering is not supported, or it failed)."]
    #[doc = ""]
    #[doc = " \\param cc               client context."]
    #[doc = " \\param server_name      target server name, or `NULL`."]
    #[doc = " \\param resume_session   non-zero to try session resumption."]
    #[doc = " \\return  0 on failure, 1 on success."]
    pub fn br_ssl_client_reset(
        cc: *mut br_ssl_client_context,
        server_name: *const cty::c_char,
        resume_session: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Set client certificate chain and key (single RSA case)."]
    #[doc = ""]
    #[doc = " This function sets a client certificate chain, that the client will"]
    #[doc = " send to the server whenever a client certificate is requested. This"]
    #[doc = " certificate uses an RSA public key; the corresponding private key is"]
    #[doc = " invoked for authentication. Trust anchor names sent by the server are"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " The provided chain and private key are linked in the client context;"]
    #[doc = " they must remain valid as long as they may be used, i.e. normally"]
    #[doc = " for the duration of the connection, since they might be invoked"]
    #[doc = " again upon renegotiations."]
    #[doc = ""]
    #[doc = " \\param cc          SSL client context."]
    #[doc = " \\param chain       client certificate chain (SSL order: EE comes first)."]
    #[doc = " \\param chain_len   client chain length (number of certificates)."]
    #[doc = " \\param sk          client private key."]
    #[doc = " \\param irsasign    RSA signature implementation (PKCS#1 v1.5)."]
    pub fn br_ssl_client_set_single_rsa(
        cc: *mut br_ssl_client_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_rsa_private_key,
        irsasign: br_rsa_pkcs1_sign,
    );
}
extern "C" {
    pub fn br_ssl_client_set_single_ec(
        cc: *mut br_ssl_client_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_ec_private_key,
        allowed_usages: cty::c_uint,
        cert_issuer_key_type: cty::c_uint,
        iec: *const br_ec_impl,
        iecdsa: br_ecdsa_sign,
    );
}
#[doc = " \\brief Type for a \"translated cipher suite\", as an array of two"]
#[doc = " 16-bit integers."]
#[doc = ""]
#[doc = " The first element is the cipher suite identifier (as used on the wire)."]
#[doc = " The second element is the concatenation of four 4-bit elements which"]
#[doc = " characterise the cipher suite contents. In most to least significant"]
#[doc = " order, these 4-bit elements are:"]
#[doc = ""]
#[doc = "   - Bits 12 to 15: key exchange + server key type"]
#[doc = ""]
#[doc = "     | val | symbolic constant        | suite type  | details                                          |"]
#[doc = "     | :-- | :----------------------- | :---------- | :----------------------------------------------- |"]
#[doc = "     |  0  | `BR_SSLKEYX_RSA`         | RSA         | RSA key exchange, key is RSA (encryption)        |"]
#[doc = "     |  1  | `BR_SSLKEYX_ECDHE_RSA`   | ECDHE_RSA   | ECDHE key exchange, key is RSA (signature)       |"]
#[doc = "     |  2  | `BR_SSLKEYX_ECDHE_ECDSA` | ECDHE_ECDSA | ECDHE key exchange, key is EC (signature)        |"]
#[doc = "     |  3  | `BR_SSLKEYX_ECDH_RSA`    | ECDH_RSA    | Key is EC (key exchange), cert signed with RSA   |"]
#[doc = "     |  4  | `BR_SSLKEYX_ECDH_ECDSA`  | ECDH_ECDSA  | Key is EC (key exchange), cert signed with ECDSA |"]
#[doc = ""]
#[doc = "   - Bits 8 to 11: symmetric encryption algorithm"]
#[doc = ""]
#[doc = "     | val | symbolic constant      | symmetric encryption | key strength (bits) |"]
#[doc = "     | :-- | :--------------------- | :------------------- | :------------------ |"]
#[doc = "     |  0  | `BR_SSLENC_3DES_CBC`   | 3DES/CBC             | 168                 |"]
#[doc = "     |  1  | `BR_SSLENC_AES128_CBC` | AES-128/CBC          | 128                 |"]
#[doc = "     |  2  | `BR_SSLENC_AES256_CBC` | AES-256/CBC          | 256                 |"]
#[doc = "     |  3  | `BR_SSLENC_AES128_GCM` | AES-128/GCM          | 128                 |"]
#[doc = "     |  4  | `BR_SSLENC_AES256_GCM` | AES-256/GCM          | 256                 |"]
#[doc = "     |  5  | `BR_SSLENC_CHACHA20`   | ChaCha20/Poly1305    | 256                 |"]
#[doc = ""]
#[doc = "   - Bits 4 to 7: MAC algorithm"]
#[doc = ""]
#[doc = "     | val | symbolic constant  | MAC type     | details                               |"]
#[doc = "     | :-- | :----------------- | :----------- | :------------------------------------ |"]
#[doc = "     |  0  | `BR_SSLMAC_AEAD`   | AEAD         | No dedicated MAC (encryption is AEAD) |"]
#[doc = "     |  2  | `BR_SSLMAC_SHA1`   | HMAC/SHA-1   | Value matches `br_sha1_ID`            |"]
#[doc = "     |  4  | `BR_SSLMAC_SHA256` | HMAC/SHA-256 | Value matches `br_sha256_ID`          |"]
#[doc = "     |  5  | `BR_SSLMAC_SHA384` | HMAC/SHA-384 | Value matches `br_sha384_ID`          |"]
#[doc = ""]
#[doc = "   - Bits 0 to 3: hash function for PRF when used with TLS-1.2"]
#[doc = ""]
#[doc = "     | val | symbolic constant  | hash function | details                              |"]
#[doc = "     | :-- | :----------------- | :------------ | :----------------------------------- |"]
#[doc = "     |  4  | `BR_SSLPRF_SHA256` | SHA-256       | Value matches `br_sha256_ID`         |"]
#[doc = "     |  5  | `BR_SSLPRF_SHA384` | SHA-384       | Value matches `br_sha384_ID`         |"]
#[doc = ""]
#[doc = " For instance, cipher suite `TLS_RSA_WITH_AES_128_GCM_SHA256` has"]
#[doc = " standard identifier 0x009C, and is translated to 0x0304, for, in"]
#[doc = " that order: RSA key exchange (0), AES-128/GCM (3), AEAD integrity (0),"]
#[doc = " SHA-256 in the TLS PRF (4)."]
pub type br_suite_translated = [u16; 2usize];
pub type br_ssl_server_context = br_ssl_server_context_;
#[doc = " \\brief Type for the server policy choices, taken after analysis of"]
#[doc = " the client message (ClientHello)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_server_choices {
    #[doc = " \\brief Cipher suite to use with that client."]
    pub cipher_suite: u16,
    #[doc = " \\brief Hash function or algorithm for signing the ServerKeyExchange."]
    #[doc = ""]
    #[doc = " This parameter is ignored for `TLS_RSA_*` and `TLS_ECDH_*`"]
    #[doc = " cipher suites; it is used only for `TLS_ECDHE_*` suites, in"]
    #[doc = " which the server _signs_ the ephemeral EC Diffie-Hellman"]
    #[doc = " parameters sent to the client."]
    #[doc = ""]
    #[doc = " This identifier must be one of the following values:"]
    #[doc = ""]
    #[doc = "   - `0xFF00 + id`, where `id` is a hash function identifier"]
    #[doc = "     (0 for MD5+SHA-1, or 2 to 6 for one of the SHA functions);"]
    #[doc = ""]
    #[doc = "   - a full 16-bit identifier, lower than `0xFF00`."]
    #[doc = ""]
    #[doc = " If the first option is used, then the SSL engine will"]
    #[doc = " compute the hash of the data that is to be signed, with the"]
    #[doc = " designated hash function. The `do_sign()` method will be"]
    #[doc = " invoked with that hash value provided in the the `data`"]
    #[doc = " buffer."]
    #[doc = ""]
    #[doc = " If the second option is used, then the SSL engine will NOT"]
    #[doc = " compute a hash on the data; instead, it will provide the"]
    #[doc = " to-be-signed data itself in `data`, i.e. the concatenation of"]
    #[doc = " the client random, server random, and encoded ECDH"]
    #[doc = " parameters. Furthermore, with TLS-1.2 and later, the 16-bit"]
    #[doc = " identifier will be used \"as is\" in the protocol, in the"]
    #[doc = " SignatureAndHashAlgorithm; for instance, `0x0401` stands for"]
    #[doc = " RSA PKCS#1 v1.5 signature (the `01`) with SHA-256 as hash"]
    #[doc = " function (the `04`)."]
    #[doc = ""]
    #[doc = " Take care that with TLS 1.0 and 1.1, the hash function is"]
    #[doc = " constrainted by the protocol: RSA signature must use"]
    #[doc = " MD5+SHA-1 (so use `0xFF00`), while ECDSA must use SHA-1"]
    #[doc = " (`0xFF02`). Since TLS 1.0 and 1.1 don't include a"]
    #[doc = " SignatureAndHashAlgorithm field in their ServerKeyExchange"]
    #[doc = " messages, any value below `0xFF00` will be usable to send the"]
    #[doc = " raw ServerKeyExchange data to the `do_sign()` callback, but"]
    #[doc = " that callback must still follow the protocol requirements"]
    #[doc = " when generating the signature."]
    pub algo_id: cty::c_uint,
    #[doc = " \\brief Certificate chain to send to the client."]
    #[doc = ""]
    #[doc = " This is an array of `br_x509_certificate` objects, each"]
    #[doc = " normally containing a DER-encoded certificate. The server"]
    #[doc = " code does not try to decode these elements."]
    pub chain: *const br_x509_certificate,
    #[doc = " \\brief Certificate chain length (number of certificates)."]
    pub chain_len: usize,
}
#[doc = " \\brief Class type for a policy handler (server side)."]
#[doc = ""]
#[doc = " A policy handler selects the policy parameters for a connection"]
#[doc = " (cipher suite and other algorithms, and certificate chain to send to"]
#[doc = " the client); it also performs the server-side computations involving"]
#[doc = " its permanent private key."]
#[doc = ""]
#[doc = " The SSL server engine will invoke first `choose()`, once the"]
#[doc = " ClientHello message has been received, then either `do_keyx()`"]
#[doc = " `do_sign()`, depending on the cipher suite."]
pub type br_ssl_server_policy_class = br_ssl_server_policy_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_server_policy_class_ {
    #[doc = " \\brief Context size (in bytes)."]
    pub context_size: usize,
    #[doc = " \\brief Select algorithms and certificates for this connection."]
    #[doc = ""]
    #[doc = " This callback function shall fill the provided `choices`"]
    #[doc = " structure with the policy choices for this connection. This"]
    #[doc = " entails selecting the cipher suite, hash function for signing"]
    #[doc = " the ServerKeyExchange (applicable only to ECDHE cipher suites),"]
    #[doc = " and certificate chain to send."]
    #[doc = ""]
    #[doc = " The callback receives a pointer to the server context that"]
    #[doc = " contains the relevant data. In particular, the functions"]
    #[doc = " `br_ssl_server_get_client_suites()`,"]
    #[doc = " `br_ssl_server_get_client_hashes()` and"]
    #[doc = " `br_ssl_server_get_client_curves()` can be used to obtain"]
    #[doc = " the cipher suites, hash functions and elliptic curves"]
    #[doc = " supported by both the client and server, respectively. The"]
    #[doc = " `br_ssl_engine_get_version()` and `br_ssl_engine_get_server_name()`"]
    #[doc = " functions yield the protocol version and requested server name"]
    #[doc = " (SNI), respectively."]
    #[doc = ""]
    #[doc = " This function may modify its context structure (`pctx`) in"]
    #[doc = " arbitrary ways to keep track of its own choices."]
    #[doc = ""]
    #[doc = " This function shall return 1 if appropriate policy choices"]
    #[doc = " could be made, or 0 if this connection cannot be pursued."]
    #[doc = ""]
    #[doc = " \\param pctx      policy context."]
    #[doc = " \\param cc        SSL server context."]
    #[doc = " \\param choices   destination structure for the policy choices."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub choose: ::core::option::Option<
        unsafe extern "C" fn(
            pctx: *mut *const br_ssl_server_policy_class,
            cc: *const br_ssl_server_context,
            choices: *mut br_ssl_server_choices,
        ) -> cty::c_int,
    >,
    #[doc = " \\brief Perform key exchange (server part)."]
    #[doc = ""]
    #[doc = " This callback is invoked to perform the server-side cryptographic"]
    #[doc = " operation for a key exchange that is not ECDHE. This callback"]
    #[doc = " uses the private key."]
    #[doc = ""]
    #[doc = " **For RSA key exchange**, the provided `data` (of length `*len`"]
    #[doc = " bytes) shall be decrypted with the server's private key, and"]
    #[doc = " the 48-byte premaster secret copied back to the first 48 bytes"]
    #[doc = " of `data`."]
    #[doc = ""]
    #[doc = "   - The caller makes sure that `*len` is at least 59 bytes."]
    #[doc = ""]
    #[doc = "   - This callback MUST check that the provided length matches"]
    #[doc = "     that of the key modulus; it shall report an error otherwise."]
    #[doc = ""]
    #[doc = "   - If the length matches that of the RSA key modulus, then"]
    #[doc = "     processing MUST be constant-time, even if decryption fails,"]
    #[doc = "     or the padding is incorrect, or the plaintext message length"]
    #[doc = "     is not exactly 48 bytes."]
    #[doc = ""]
    #[doc = "   - This callback needs not check the two first bytes of the"]
    #[doc = "     obtained pre-master secret (the caller will do that)."]
    #[doc = ""]
    #[doc = "   - If an error is reported (0), then what the callback put"]
    #[doc = "     in the first 48 bytes of `data` is unimportant (the caller"]
    #[doc = "     will use random bytes instead)."]
    #[doc = ""]
    #[doc = " **For ECDH key exchange**, the provided `data` (of length `*len`"]
    #[doc = " bytes) is the elliptic curve point from the client. The"]
    #[doc = " callback shall multiply it with its private key, and store"]
    #[doc = " the resulting X coordinate in `data`, starting at offset 0,"]
    #[doc = " and set `*len` to the length of the X coordinate."]
    #[doc = ""]
    #[doc = "   - If the input array does not have the proper length for"]
    #[doc = "     an encoded curve point, then an error (0) shall be reported."]
    #[doc = ""]
    #[doc = "   - If the input array has the proper length, then processing"]
    #[doc = "     MUST be constant-time, even if the data is not a valid"]
    #[doc = "     encoded point."]
    #[doc = ""]
    #[doc = "   - This callback MUST check that the input point is valid."]
    #[doc = ""]
    #[doc = " Returned value is 1 on success, 0 on error."]
    #[doc = ""]
    #[doc = " \\param pctx   policy context."]
    #[doc = " \\param data   key exchange data from the client."]
    #[doc = " \\param len    key exchange data length (in bytes)."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub do_keyx: ::core::option::Option<
        unsafe extern "C" fn(
            pctx: *mut *const br_ssl_server_policy_class,
            data: *mut cty::c_uchar,
            len: *mut usize,
        ) -> u32,
    >,
    #[doc = " \\brief Perform a signature (for a ServerKeyExchange message)."]
    #[doc = ""]
    #[doc = " This callback function is invoked for ECDHE cipher suites. On"]
    #[doc = " input, the hash value or message to sign is in `data`, of"]
    #[doc = " size `hv_len`; the involved hash function or algorithm is"]
    #[doc = " identified by `algo_id`. The signature shall be computed and"]
    #[doc = " written back into `data`; the total size of that buffer is"]
    #[doc = " `len` bytes."]
    #[doc = ""]
    #[doc = " This callback shall verify that the signature length does not"]
    #[doc = " exceed `len` bytes, and abstain from writing the signature if"]
    #[doc = " it does not fit."]
    #[doc = ""]
    #[doc = " The `algo_id` value matches that which was written in the"]
    #[doc = " `choices` structures by the `choose()` callback. This will be"]
    #[doc = " one of the following:"]
    #[doc = ""]
    #[doc = "   - `0xFF00 + id` for a hash function identifier `id`. In"]
    #[doc = "     that case, the `data` buffer contains a hash value"]
    #[doc = "     already computed over the data that is to be signed,"]
    #[doc = "     of length `hv_len`. The `id` may be 0 to designate the"]
    #[doc = "     special MD5+SHA-1 concatenation (old-style RSA signing)."]
    #[doc = ""]
    #[doc = "   - Another value, lower than `0xFF00`. The `data` buffer"]
    #[doc = "     then contains the raw, non-hashed data to be signed"]
    #[doc = "     (concatenation of the client and server randoms and"]
    #[doc = "     ECDH parameters). The callback is responsible to apply"]
    #[doc = "     any relevant hashing as part of the signing process."]
    #[doc = ""]
    #[doc = " Returned value is the signature length (in bytes), or 0 on error."]
    #[doc = ""]
    #[doc = " \\param pctx      policy context."]
    #[doc = " \\param algo_id   hash function / algorithm identifier."]
    #[doc = " \\param data      input/output buffer (message/hash, then signature)."]
    #[doc = " \\param hv_len    hash value or message length (in bytes)."]
    #[doc = " \\param len       total buffer length (in bytes)."]
    #[doc = " \\return  signature length (in bytes) on success, or 0 on error."]
    pub do_sign: ::core::option::Option<
        unsafe extern "C" fn(
            pctx: *mut *const br_ssl_server_policy_class,
            algo_id: cty::c_uint,
            data: *mut cty::c_uchar,
            hv_len: usize,
            len: usize,
        ) -> usize,
    >,
}
#[doc = " \\brief A single-chain RSA policy handler."]
#[doc = ""]
#[doc = " This policy context uses a single certificate chain, and a RSA"]
#[doc = " private key. The context can be restricted to only signatures or"]
#[doc = " only key exchange."]
#[doc = ""]
#[doc = " Apart from the first field (vtable pointer), its contents are"]
#[doc = " opaque and shall not be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_server_policy_rsa_context {
    #[doc = " \\brief Pointer to vtable."]
    pub vtable: *const br_ssl_server_policy_class,
    pub chain: *const br_x509_certificate,
    pub chain_len: usize,
    pub sk: *const br_rsa_private_key,
    pub allowed_usages: cty::c_uint,
    pub irsacore: br_rsa_private,
    pub irsasign: br_rsa_pkcs1_sign,
}
#[doc = " \\brief A single-chain EC policy handler."]
#[doc = ""]
#[doc = " This policy context uses a single certificate chain, and an EC"]
#[doc = " private key. The context can be restricted to only signatures or"]
#[doc = " only key exchange."]
#[doc = ""]
#[doc = " Due to how TLS is defined, this context must be made aware whether"]
#[doc = " the server certificate was itself signed with RSA or ECDSA. The code"]
#[doc = " does not try to decode the certificate to obtain that information."]
#[doc = ""]
#[doc = " Apart from the first field (vtable pointer), its contents are"]
#[doc = " opaque and shall not be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_server_policy_ec_context {
    #[doc = " \\brief Pointer to vtable."]
    pub vtable: *const br_ssl_server_policy_class,
    pub chain: *const br_x509_certificate,
    pub chain_len: usize,
    pub sk: *const br_ec_private_key,
    pub allowed_usages: cty::c_uint,
    pub cert_issuer_key_type: cty::c_uint,
    pub mhash: *const br_multihash_context,
    pub iec: *const br_ec_impl,
    pub iecdsa: br_ecdsa_sign,
}
#[doc = " \\brief Class type for a session parameter cache."]
#[doc = ""]
#[doc = " Session parameters are saved in the cache with `save()`, and"]
#[doc = " retrieved with `load()`. The cache implementation can apply any"]
#[doc = " storage and eviction strategy that it sees fit. The SSL server"]
#[doc = " context that performs the request is provided, so that its"]
#[doc = " functionalities may be used by the implementation (e.g. hash"]
#[doc = " functions or random number generation)."]
pub type br_ssl_session_cache_class = br_ssl_session_cache_class_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_session_cache_class_ {
    #[doc = " \\brief Context size (in bytes)."]
    pub context_size: usize,
    #[doc = " \\brief Record a session."]
    #[doc = ""]
    #[doc = " This callback should record the provided session parameters."]
    #[doc = " The `params` structure is transient, so its contents shall"]
    #[doc = " be copied into the cache. The session ID has been randomly"]
    #[doc = " generated and always has length exactly 32 bytes."]
    #[doc = ""]
    #[doc = " \\param ctx          session cache context."]
    #[doc = " \\param server_ctx   SSL server context."]
    #[doc = " \\param params       session parameters to save."]
    pub save: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_ssl_session_cache_class,
            server_ctx: *mut br_ssl_server_context,
            params: *const br_ssl_session_parameters,
        ),
    >,
    #[doc = " \\brief Lookup a session in the cache."]
    #[doc = ""]
    #[doc = " The session ID to lookup is in `params` and always has length"]
    #[doc = " exactly 32 bytes. If the session parameters are found in the"]
    #[doc = " cache, then the parameters shall be copied into the `params`"]
    #[doc = " structure. Returned value is 1 on successful lookup, 0"]
    #[doc = " otherwise."]
    #[doc = ""]
    #[doc = " \\param ctx          session cache context."]
    #[doc = " \\param server_ctx   SSL server context."]
    #[doc = " \\param params       destination for session parameters."]
    #[doc = " \\return  1 if found, 0 otherwise."]
    pub load: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut *const br_ssl_session_cache_class,
            server_ctx: *mut br_ssl_server_context,
            params: *mut br_ssl_session_parameters,
        ) -> cty::c_int,
    >,
}
#[doc = " \\brief Context for a basic cache system."]
#[doc = ""]
#[doc = " The system stores session parameters in a buffer provided at"]
#[doc = " initialisation time. Each entry uses exactly 100 bytes, and"]
#[doc = " buffer sizes up to 4294967295 bytes are supported."]
#[doc = ""]
#[doc = " Entries are evicted with a LRU (Least Recently Used) policy. A"]
#[doc = " search tree is maintained to keep lookups fast even with large"]
#[doc = " caches."]
#[doc = ""]
#[doc = " Apart from the first field (vtable pointer), the structure"]
#[doc = " contents are opaque and shall not be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_ssl_session_cache_lru {
    #[doc = " \\brief Pointer to vtable."]
    pub vtable: *const br_ssl_session_cache_class,
    pub store: *mut cty::c_uchar,
    pub store_len: usize,
    pub store_ptr: usize,
    pub index_key: [cty::c_uchar; 32usize],
    pub hash: *const br_hash_class,
    pub init_done: cty::c_int,
    pub head: u32,
    pub tail: u32,
    pub root: u32,
}
extern "C" {
    #[doc = " \\brief Initialise a LRU session cache with the provided storage space."]
    #[doc = ""]
    #[doc = " The provided storage space must remain valid as long as the cache"]
    #[doc = " is used. Arbitrary lengths are supported, up to 4294967295 bytes;"]
    #[doc = " each entry uses up exactly 100 bytes."]
    #[doc = ""]
    #[doc = " \\param cc          session cache context."]
    #[doc = " \\param store       storage space for cached entries."]
    #[doc = " \\param store_len   storage space length (in bytes)."]
    pub fn br_ssl_session_cache_lru_init(
        cc: *mut br_ssl_session_cache_lru,
        store: *mut cty::c_uchar,
        store_len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Forget an entry in an LRU session cache."]
    #[doc = ""]
    #[doc = " The session cache context must have been initialised. The entry"]
    #[doc = " with the provided session ID (of exactly 32 bytes) is looked for"]
    #[doc = " in the cache; if located, it is disabled."]
    #[doc = ""]
    #[doc = " \\param cc   session cache context."]
    #[doc = " \\param id   session ID to forget."]
    pub fn br_ssl_session_cache_lru_forget(
        cc: *mut br_ssl_session_cache_lru,
        id: *const cty::c_uchar,
    );
}
#[doc = " \\brief Context structure for a SSL server."]
#[doc = ""]
#[doc = " The first field (called `eng`) is the SSL engine; all functions that"]
#[doc = " work on a `br_ssl_engine_context` structure shall take as parameter"]
#[doc = " a pointer to that field. The other structure fields are opaque and"]
#[doc = " must not be accessed directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_ssl_server_context_ {
    #[doc = " \\brief The encapsulated engine context."]
    pub eng: br_ssl_engine_context,
    pub client_max_version: u16,
    pub cache_vtable: *mut *const br_ssl_session_cache_class,
    pub client_suites: [br_suite_translated; 48usize],
    pub client_suites_num: cty::c_uchar,
    pub hashes: u32,
    pub curves: u32,
    pub policy_vtable: *mut *const br_ssl_server_policy_class,
    pub sign_hash_id: u16,
    pub chain_handler: br_ssl_server_context___bindgen_ty_1,
    pub ecdhe_key: [cty::c_uchar; 70usize],
    pub ecdhe_key_len: usize,
    pub ta_names: *const br_x500_name,
    pub tas: *const br_x509_trust_anchor,
    pub num_tas: usize,
    pub cur_dn_index: usize,
    pub cur_dn: *const cty::c_uchar,
    pub cur_dn_len: usize,
    pub hash_CV: [cty::c_uchar; 64usize],
    pub hash_CV_len: usize,
    pub hash_CV_id: cty::c_int,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union br_ssl_server_context___bindgen_ty_1 {
    pub vtable: *const br_ssl_server_policy_class,
    pub single_rsa: br_ssl_server_policy_rsa_context,
    pub single_ec: br_ssl_server_policy_ec_context,
    _bindgen_union_align: [u32; 9usize],
}
extern "C" {
    #[doc = " \\brief SSL server profile: full_rsa."]
    #[doc = ""]
    #[doc = " This function initialises the provided SSL server context with"]
    #[doc = " all supported algorithms and cipher suites that rely on a RSA"]
    #[doc = " key pair."]
    #[doc = ""]
    #[doc = " \\param cc          server context to initialise."]
    #[doc = " \\param chain       server certificate chain."]
    #[doc = " \\param chain_len   certificate chain length (number of certificate)."]
    #[doc = " \\param sk          RSA private key."]
    pub fn br_ssl_server_init_full_rsa(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_rsa_private_key,
    );
}
extern "C" {
    #[doc = " \\brief SSL server profile: full_ec."]
    #[doc = ""]
    #[doc = " This function initialises the provided SSL server context with"]
    #[doc = " all supported algorithms and cipher suites that rely on an EC"]
    #[doc = " key pair."]
    #[doc = ""]
    #[doc = " The key type of the CA that issued the server's certificate must"]
    #[doc = " be provided, since it matters for ECDH cipher suites (ECDH_RSA"]
    #[doc = " suites require a RSA-powered CA). The key type is either"]
    #[doc = " `BR_KEYTYPE_RSA` or `BR_KEYTYPE_EC`."]
    #[doc = ""]
    #[doc = " \\param cc                     server context to initialise."]
    #[doc = " \\param chain                  server certificate chain."]
    #[doc = " \\param chain_len              chain length (number of certificates)."]
    #[doc = " \\param cert_issuer_key_type   certificate issuer's key type."]
    #[doc = " \\param sk                     EC private key."]
    pub fn br_ssl_server_init_full_ec(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        cert_issuer_key_type: cty::c_uint,
        sk: *const br_ec_private_key,
    );
}
extern "C" {
    #[doc = " \\brief SSL server profile: minr2g."]
    #[doc = ""]
    #[doc = " This profile uses only TLS_RSA_WITH_AES_128_GCM_SHA256. Server key is"]
    #[doc = " RSA, and RSA key exchange is used (not forward secure, but uses little"]
    #[doc = " CPU in the client)."]
    #[doc = ""]
    #[doc = " \\param cc          server context to initialise."]
    #[doc = " \\param chain       server certificate chain."]
    #[doc = " \\param chain_len   certificate chain length (number of certificate)."]
    #[doc = " \\param sk          RSA private key."]
    pub fn br_ssl_server_init_minr2g(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_rsa_private_key,
    );
}
extern "C" {
    #[doc = " \\brief SSL server profile: mine2g."]
    #[doc = ""]
    #[doc = " This profile uses only TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256. Server key"]
    #[doc = " is RSA, and ECDHE key exchange is used. This suite provides forward"]
    #[doc = " security, with a higher CPU expense on the client, and a somewhat"]
    #[doc = " larger code footprint (compared to \"minr2g\")."]
    #[doc = ""]
    #[doc = " \\param cc          server context to initialise."]
    #[doc = " \\param chain       server certificate chain."]
    #[doc = " \\param chain_len   certificate chain length (number of certificate)."]
    #[doc = " \\param sk          RSA private key."]
    pub fn br_ssl_server_init_mine2g(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_rsa_private_key,
    );
}
extern "C" {
    #[doc = " \\brief SSL server profile: minf2g."]
    #[doc = ""]
    #[doc = " This profile uses only TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256."]
    #[doc = " Server key is EC, and ECDHE key exchange is used. This suite provides"]
    #[doc = " forward security, with a higher CPU expense on the client and server"]
    #[doc = " (by a factor of about 3 to 4), and a somewhat larger code footprint"]
    #[doc = " (compared to \"minu2g\" and \"minv2g\")."]
    #[doc = ""]
    #[doc = " \\param cc          server context to initialise."]
    #[doc = " \\param chain       server certificate chain."]
    #[doc = " \\param chain_len   certificate chain length (number of certificate)."]
    #[doc = " \\param sk          EC private key."]
    pub fn br_ssl_server_init_minf2g(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_ec_private_key,
    );
}
extern "C" {
    #[doc = " \\brief SSL server profile: minu2g."]
    #[doc = ""]
    #[doc = " This profile uses only TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256."]
    #[doc = " Server key is EC, and ECDH key exchange is used; the issuing CA used"]
    #[doc = " a RSA key."]
    #[doc = ""]
    #[doc = " The \"minu2g\" and \"minv2g\" profiles do not provide forward secrecy,"]
    #[doc = " but are the lightest on the server (for CPU usage), and are rather"]
    #[doc = " inexpensive on the client as well."]
    #[doc = ""]
    #[doc = " \\param cc          server context to initialise."]
    #[doc = " \\param chain       server certificate chain."]
    #[doc = " \\param chain_len   certificate chain length (number of certificate)."]
    #[doc = " \\param sk          EC private key."]
    pub fn br_ssl_server_init_minu2g(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_ec_private_key,
    );
}
extern "C" {
    #[doc = " \\brief SSL server profile: minv2g."]
    #[doc = ""]
    #[doc = " This profile uses only TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256."]
    #[doc = " Server key is EC, and ECDH key exchange is used; the issuing CA used"]
    #[doc = " an EC key."]
    #[doc = ""]
    #[doc = " The \"minu2g\" and \"minv2g\" profiles do not provide forward secrecy,"]
    #[doc = " but are the lightest on the server (for CPU usage), and are rather"]
    #[doc = " inexpensive on the client as well."]
    #[doc = ""]
    #[doc = " \\param cc          server context to initialise."]
    #[doc = " \\param chain       server certificate chain."]
    #[doc = " \\param chain_len   certificate chain length (number of certificate)."]
    #[doc = " \\param sk          EC private key."]
    pub fn br_ssl_server_init_minv2g(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_ec_private_key,
    );
}
extern "C" {
    #[doc = " \\brief SSL server profile: mine2c."]
    #[doc = ""]
    #[doc = " This profile uses only TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256."]
    #[doc = " Server key is RSA, and ECDHE key exchange is used. This suite"]
    #[doc = " provides forward security."]
    #[doc = ""]
    #[doc = " \\param cc          server context to initialise."]
    #[doc = " \\param chain       server certificate chain."]
    #[doc = " \\param chain_len   certificate chain length (number of certificate)."]
    #[doc = " \\param sk          RSA private key."]
    pub fn br_ssl_server_init_mine2c(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_rsa_private_key,
    );
}
extern "C" {
    #[doc = " \\brief SSL server profile: minf2c."]
    #[doc = ""]
    #[doc = " This profile uses only TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256."]
    #[doc = " Server key is EC, and ECDHE key exchange is used. This suite provides"]
    #[doc = " forward security."]
    #[doc = ""]
    #[doc = " \\param cc          server context to initialise."]
    #[doc = " \\param chain       server certificate chain."]
    #[doc = " \\param chain_len   certificate chain length (number of certificate)."]
    #[doc = " \\param sk          EC private key."]
    pub fn br_ssl_server_init_minf2c(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_ec_private_key,
    );
}
extern "C" {
    #[doc = " \\brief Clear the complete contents of a SSL server context."]
    #[doc = ""]
    #[doc = " Everything is cleared, including the reference to the configured buffer,"]
    #[doc = " implementations, cipher suites and state. This is a preparatory step"]
    #[doc = " to assembling a custom profile."]
    #[doc = ""]
    #[doc = " \\param cc   server context to clear."]
    pub fn br_ssl_server_zero(cc: *mut br_ssl_server_context);
}
extern "C" {
    #[doc = " \\brief Set the server certificate chain and key (single RSA case)."]
    #[doc = ""]
    #[doc = " This function uses a policy context included in the server context."]
    #[doc = " It configures use of a single server certificate chain with a RSA"]
    #[doc = " private key. The `allowed_usages` is a combination of usages, namely"]
    #[doc = " `BR_KEYTYPE_KEYX` and/or `BR_KEYTYPE_SIGN`; this enables or disables"]
    #[doc = " the corresponding cipher suites (i.e. `TLS_RSA_*` use the RSA key for"]
    #[doc = " key exchange, while `TLS_ECDHE_RSA_*` use the RSA key for signatures)."]
    #[doc = ""]
    #[doc = " \\param cc               server context."]
    #[doc = " \\param chain            server certificate chain to send to the client."]
    #[doc = " \\param chain_len        chain length (number of certificates)."]
    #[doc = " \\param sk               server private key (RSA)."]
    #[doc = " \\param allowed_usages   allowed private key usages."]
    #[doc = " \\param irsacore         RSA core implementation."]
    #[doc = " \\param irsasign         RSA signature implementation (PKCS#1 v1.5)."]
    pub fn br_ssl_server_set_single_rsa(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_rsa_private_key,
        allowed_usages: cty::c_uint,
        irsacore: br_rsa_private,
        irsasign: br_rsa_pkcs1_sign,
    );
}
extern "C" {
    #[doc = " \\brief Set the server certificate chain and key (single EC case)."]
    #[doc = ""]
    #[doc = " This function uses a policy context included in the server context."]
    #[doc = " It configures use of a single server certificate chain with an EC"]
    #[doc = " private key. The `allowed_usages` is a combination of usages, namely"]
    #[doc = " `BR_KEYTYPE_KEYX` and/or `BR_KEYTYPE_SIGN`; this enables or disables"]
    #[doc = " the corresponding cipher suites (i.e. `TLS_ECDH_*` use the EC key for"]
    #[doc = " key exchange, while `TLS_ECDHE_ECDSA_*` use the EC key for signatures)."]
    #[doc = ""]
    #[doc = " In order to support `TLS_ECDH_*` cipher suites (non-ephemeral ECDH),"]
    #[doc = " the algorithm type of the key used by the issuing CA to sign the"]
    #[doc = " server's certificate must be provided, as `cert_issuer_key_type`"]
    #[doc = " parameter (this value is either `BR_KEYTYPE_RSA` or `BR_KEYTYPE_EC`)."]
    #[doc = ""]
    #[doc = " \\param cc                     server context."]
    #[doc = " \\param chain                  server certificate chain to send."]
    #[doc = " \\param chain_len              chain length (number of certificates)."]
    #[doc = " \\param sk                     server private key (EC)."]
    #[doc = " \\param allowed_usages         allowed private key usages."]
    #[doc = " \\param cert_issuer_key_type   issuing CA's key type."]
    #[doc = " \\param iec                    EC core implementation."]
    #[doc = " \\param iecdsa                 ECDSA signature implementation (\"asn1\" format)."]
    pub fn br_ssl_server_set_single_ec(
        cc: *mut br_ssl_server_context,
        chain: *const br_x509_certificate,
        chain_len: usize,
        sk: *const br_ec_private_key,
        allowed_usages: cty::c_uint,
        cert_issuer_key_type: cty::c_uint,
        iec: *const br_ec_impl,
        iecdsa: br_ecdsa_sign,
    );
}
extern "C" {
    #[doc = " \\brief Prepare or reset a server context for handling an incoming client."]
    #[doc = ""]
    #[doc = " \\param cc   server context."]
    #[doc = " \\return  1 on success, 0 on error."]
    pub fn br_ssl_server_reset(cc: *mut br_ssl_server_context) -> cty::c_int;
}
#[doc = " \\brief Context structure for the simplified SSL I/O wrapper."]
#[doc = ""]
#[doc = " This structure is initialised with `br_sslio_init()`. Its contents"]
#[doc = " are opaque and shall not be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_sslio_context {
    pub engine: *mut br_ssl_engine_context,
    pub low_read: ::core::option::Option<
        unsafe extern "C" fn(
            read_context: *mut cty::c_void,
            data: *mut cty::c_uchar,
            len: usize,
        ) -> cty::c_int,
    >,
    pub read_context: *mut cty::c_void,
    pub low_write: ::core::option::Option<
        unsafe extern "C" fn(
            write_context: *mut cty::c_void,
            data: *const cty::c_uchar,
            len: usize,
        ) -> cty::c_int,
    >,
    pub write_context: *mut cty::c_void,
}
extern "C" {
    #[doc = " \\brief Initialise a simplified I/O wrapper context."]
    #[doc = ""]
    #[doc = " The simplified I/O wrapper offers a simpler read/write API for a SSL"]
    #[doc = " engine (client or server), using the provided callback functions for"]
    #[doc = " reading data from, or writing data to, the transport medium."]
    #[doc = ""]
    #[doc = " The callback functions have the following semantics:"]
    #[doc = ""]
    #[doc = "   - Each callback receives an opaque context value (of type `void *`)"]
    #[doc = "     that the callback may use arbitrarily (or possibly ignore)."]
    #[doc = ""]
    #[doc = "   - `low_read()` reads at least one byte, at most `len` bytes, from"]
    #[doc = "     the transport medium. Read bytes shall be written in `data`."]
    #[doc = ""]
    #[doc = "   - `low_write()` writes at least one byte, at most `len` bytes, unto"]
    #[doc = "     the transport medium. The bytes to write are read from `data`."]
    #[doc = ""]
    #[doc = "   - The `len` parameter is never zero, and is always lower than 20000."]
    #[doc = ""]
    #[doc = "   - The number of processed bytes (read or written) is returned. Since"]
    #[doc = "     that number is less than 20000, it always fits on an `int`."]
    #[doc = ""]
    #[doc = "   - On error, the callbacks return -1. Reaching end-of-stream is an"]
    #[doc = "     error. Errors are permanent: the SSL connection is terminated."]
    #[doc = ""]
    #[doc = "   - Callbacks SHOULD NOT return 0. This is tolerated, as long as"]
    #[doc = "     callbacks endeavour to block for some non-negligible amount of"]
    #[doc = "     time until at least one byte can be sent or received (if a"]
    #[doc = "     callback returns 0, then the wrapper invokes it again"]
    #[doc = "     immediately)."]
    #[doc = ""]
    #[doc = "   - Callbacks MAY return as soon as at least one byte is processed;"]
    #[doc = "     they MAY also insist on reading or writing _all_ requested bytes."]
    #[doc = "     Since SSL is a self-terminated protocol (each record has a length"]
    #[doc = "     header), this does not change semantics."]
    #[doc = ""]
    #[doc = "   - Callbacks need not apply any buffering (for performance) since SSL"]
    #[doc = "     itself uses buffers."]
    #[doc = ""]
    #[doc = " \\param ctx             wrapper context to initialise."]
    #[doc = " \\param engine          SSL engine to wrap."]
    #[doc = " \\param low_read        callback for reading data from the transport."]
    #[doc = " \\param read_context    context pointer for `low_read()`."]
    #[doc = " \\param low_write       callback for writing data on the transport."]
    #[doc = " \\param write_context   context pointer for `low_write()`."]
    pub fn br_sslio_init(
        ctx: *mut br_sslio_context,
        engine: *mut br_ssl_engine_context,
        low_read: ::core::option::Option<
            unsafe extern "C" fn(
                read_context: *mut cty::c_void,
                data: *mut cty::c_uchar,
                len: usize,
            ) -> cty::c_int,
        >,
        read_context: *mut cty::c_void,
        low_write: ::core::option::Option<
            unsafe extern "C" fn(
                write_context: *mut cty::c_void,
                data: *const cty::c_uchar,
                len: usize,
            ) -> cty::c_int,
        >,
        write_context: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Read some application data from a SSL connection."]
    #[doc = ""]
    #[doc = " If `len` is zero, then this function returns 0 immediately. In"]
    #[doc = " all other cases, it never returns 0."]
    #[doc = ""]
    #[doc = " This call returns only when at least one byte has been obtained."]
    #[doc = " Returned value is the number of bytes read, or -1 on error. The"]
    #[doc = " number of bytes always fits on an 'int' (data from a single SSL/TLS"]
    #[doc = " record is returned)."]
    #[doc = ""]
    #[doc = " On error or SSL closure, this function returns -1. The caller should"]
    #[doc = " inspect the error status on the SSL engine to distinguish between"]
    #[doc = " normal closure and error."]
    #[doc = ""]
    #[doc = " \\param cc    SSL wrapper context."]
    #[doc = " \\param dst   destination buffer for application data."]
    #[doc = " \\param len   maximum number of bytes to obtain."]
    #[doc = " \\return  number of bytes obtained, or -1 on error."]
    pub fn br_sslio_read(
        cc: *mut br_sslio_context,
        dst: *mut cty::c_void,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Read application data from a SSL connection."]
    #[doc = ""]
    #[doc = " This calls returns only when _all_ requested `len` bytes are read,"]
    #[doc = " or an error is reached. Returned value is 0 on success, -1 on error."]
    #[doc = " A normal (verified) SSL closure before that many bytes are obtained"]
    #[doc = " is reported as an error by this function."]
    #[doc = ""]
    #[doc = " \\param cc    SSL wrapper context."]
    #[doc = " \\param dst   destination buffer for application data."]
    #[doc = " \\param len   number of bytes to obtain."]
    #[doc = " \\return  0 on success, or -1 on error."]
    pub fn br_sslio_read_all(
        cc: *mut br_sslio_context,
        dst: *mut cty::c_void,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Write some application data unto a SSL connection."]
    #[doc = ""]
    #[doc = " If `len` is zero, then this function returns 0 immediately. In"]
    #[doc = " all other cases, it never returns 0."]
    #[doc = ""]
    #[doc = " This call returns only when at least one byte has been written."]
    #[doc = " Returned value is the number of bytes written, or -1 on error. The"]
    #[doc = " number of bytes always fits on an 'int' (less than 20000)."]
    #[doc = ""]
    #[doc = " On error or SSL closure, this function returns -1. The caller should"]
    #[doc = " inspect the error status on the SSL engine to distinguish between"]
    #[doc = " normal closure and error."]
    #[doc = ""]
    #[doc = " **Important:** SSL is buffered; a \"written\" byte is a byte that was"]
    #[doc = " injected into the wrapped SSL engine, but this does not necessarily mean"]
    #[doc = " that it has been scheduled for sending. Use `br_sslio_flush()` to"]
    #[doc = " ensure that all pending data has been sent to the transport medium."]
    #[doc = ""]
    #[doc = " \\param cc    SSL wrapper context."]
    #[doc = " \\param src   source buffer for application data."]
    #[doc = " \\param len   maximum number of bytes to write."]
    #[doc = " \\return  number of bytes written, or -1 on error."]
    pub fn br_sslio_write(
        cc: *mut br_sslio_context,
        src: *const cty::c_void,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Write application data unto a SSL connection."]
    #[doc = ""]
    #[doc = " This calls returns only when _all_ requested `len` bytes have been"]
    #[doc = " written, or an error is reached. Returned value is 0 on success, -1"]
    #[doc = " on error. A normal (verified) SSL closure before that many bytes are"]
    #[doc = " written is reported as an error by this function."]
    #[doc = ""]
    #[doc = " **Important:** SSL is buffered; a \"written\" byte is a byte that was"]
    #[doc = " injected into the wrapped SSL engine, but this does not necessarily mean"]
    #[doc = " that it has been scheduled for sending. Use `br_sslio_flush()` to"]
    #[doc = " ensure that all pending data has been sent to the transport medium."]
    #[doc = ""]
    #[doc = " \\param cc    SSL wrapper context."]
    #[doc = " \\param src   source buffer for application data."]
    #[doc = " \\param len   number of bytes to write."]
    #[doc = " \\return  0 on success, or -1 on error."]
    pub fn br_sslio_write_all(
        cc: *mut br_sslio_context,
        src: *const cty::c_void,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Flush pending data."]
    #[doc = ""]
    #[doc = " This call makes sure that any buffered application data in the"]
    #[doc = " provided context (including the wrapped SSL engine) has been sent"]
    #[doc = " to the transport medium (i.e. accepted by the `low_write()` callback"]
    #[doc = " method). If there is no such pending data, then this function does"]
    #[doc = " nothing (and returns a success, i.e. 0)."]
    #[doc = ""]
    #[doc = " If the underlying transport medium has its own buffers, then it is"]
    #[doc = " up to the caller to ensure the corresponding flushing."]
    #[doc = ""]
    #[doc = " Returned value is 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\param cc    SSL wrapper context."]
    #[doc = " \\return  0 on success, or -1 on error."]
    pub fn br_sslio_flush(cc: *mut br_sslio_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Close the SSL connection."]
    #[doc = ""]
    #[doc = " This call runs the SSL closure protocol (sending a `close_notify`,"]
    #[doc = " receiving the response `close_notify`). When it returns, the SSL"]
    #[doc = " connection is finished. It is still up to the caller to manage the"]
    #[doc = " possible transport-level termination, if applicable (alternatively,"]
    #[doc = " the underlying transport stream may be reused for non-SSL messages)."]
    #[doc = ""]
    #[doc = " Returned value is 0 on success, -1 on error. A failure by the peer"]
    #[doc = " to process the complete closure protocol (i.e. sending back the"]
    #[doc = " `close_notify`) is an error."]
    #[doc = ""]
    #[doc = " \\param cc    SSL wrapper context."]
    #[doc = " \\return  0 on success, or -1 on error."]
    pub fn br_sslio_close(cc: *mut br_sslio_context) -> cty::c_int;
}
#[doc = " \\brief PEM decoder context."]
#[doc = ""]
#[doc = " Contents are opaque (they should not be accessed directly)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct br_pem_decoder_context {
    pub cpu: br_pem_decoder_context__bindgen_ty_1,
    pub dp_stack: [u32; 32usize],
    pub rp_stack: [u32; 32usize],
    pub err: cty::c_int,
    pub hbuf: *const cty::c_uchar,
    pub hlen: usize,
    pub dest: ::core::option::Option<
        unsafe extern "C" fn(dest_ctx: *mut cty::c_void, src: *const cty::c_void, len: usize),
    >,
    pub dest_ctx: *mut cty::c_void,
    pub event: cty::c_uchar,
    pub name: [cty::c_char; 128usize],
    pub buf: [cty::c_uchar; 255usize],
    pub ptr: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_pem_decoder_context__bindgen_ty_1 {
    pub dp: *mut u32,
    pub rp: *mut u32,
    pub ip: *const cty::c_uchar,
}
extern "C" {
    #[doc = " \\brief Initialise a PEM decoder structure."]
    #[doc = ""]
    #[doc = " \\param ctx   decoder context to initialise."]
    pub fn br_pem_decoder_init(ctx: *mut br_pem_decoder_context);
}
extern "C" {
    #[doc = " \\brief Push some bytes into the decoder."]
    #[doc = ""]
    #[doc = " Returned value is the number of bytes actually consumed; this may be"]
    #[doc = " less than the number of provided bytes if an event is raised. When an"]
    #[doc = " event is raised, it must be read (with `br_pem_decoder_event()`);"]
    #[doc = " until the event is read, this function will return 0."]
    #[doc = ""]
    #[doc = " \\param ctx    decoder context."]
    #[doc = " \\param data   new data bytes."]
    #[doc = " \\param len    number of new data bytes."]
    #[doc = " \\return  the number of bytes actually received (may be less than `len`)."]
    pub fn br_pem_decoder_push(
        ctx: *mut br_pem_decoder_context,
        data: *const cty::c_void,
        len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Get the last event."]
    #[doc = ""]
    #[doc = " If an event was raised, then this function returns the event value, and"]
    #[doc = " also clears it, thereby allowing the decoder to proceed. If no event"]
    #[doc = " was raised since the last call to `br_pem_decoder_event()`, then this"]
    #[doc = " function returns 0."]
    #[doc = ""]
    #[doc = " \\param ctx   decoder context."]
    #[doc = " \\return  the raised event, or 0."]
    pub fn br_pem_decoder_event(ctx: *mut br_pem_decoder_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Encode an object in PEM."]
    #[doc = ""]
    #[doc = " This function encodes the provided binary object (`data`, of length `len`"]
    #[doc = " bytes) into PEM. The `banner` text will be included in the header and"]
    #[doc = " footer (e.g. use `\"CERTIFICATE\"` to get a `\"BEGIN CERTIFICATE\"` header)."]
    #[doc = ""]
    #[doc = " The length (in characters) of the PEM output is returned; that length"]
    #[doc = " does NOT include the terminating zero, that this function nevertheless"]
    #[doc = " adds. If using the returned value for allocation purposes, the allocated"]
    #[doc = " buffer size MUST be at least one byte larger than the returned size."]
    #[doc = ""]
    #[doc = " If `dest` is `NULL`, then the encoding does not happen; however, the"]
    #[doc = " length of the encoded object is still computed and returned."]
    #[doc = ""]
    #[doc = " The `data` pointer may be `NULL` only if `len` is zero (when encoding"]
    #[doc = " an object of length zero, which is not very useful), or when `dest`"]
    #[doc = " is `NULL` (in that case, source data bytes are ignored)."]
    #[doc = ""]
    #[doc = " Some `flags` can be specified to alter the encoding behaviour:"]
    #[doc = ""]
    #[doc = "   - If `BR_PEM_LINE64` is set, then line-breaking will occur after"]
    #[doc = "     every 64 characters of output, instead of the default of 76."]
    #[doc = ""]
    #[doc = "   - If `BR_PEM_CRLF` is set, then end-of-line sequence will use"]
    #[doc = "     CR+LF instead of a single LF."]
    #[doc = ""]
    #[doc = " The `data` and `dest` buffers may overlap, in which case the source"]
    #[doc = " binary data is destroyed in the process. Note that the PEM-encoded output"]
    #[doc = " is always larger than the source binary."]
    #[doc = ""]
    #[doc = " \\param dest     the destination buffer (or `NULL`)."]
    #[doc = " \\param data     the source buffer (can be `NULL` in some cases)."]
    #[doc = " \\param len      the source length (in bytes)."]
    #[doc = " \\param banner   the PEM banner expression."]
    #[doc = " \\param flags    the behavioural flags."]
    #[doc = " \\return  the PEM object length (in characters), EXCLUDING the final zero."]
    pub fn br_pem_encode(
        dest: *mut cty::c_void,
        data: *const cty::c_void,
        len: usize,
        banner: *const cty::c_char,
        flags: cty::c_uint,
    ) -> usize;
}
#[doc = " \\brief Type for a configuration option."]
#[doc = ""]
#[doc = " A \"configuration option\" is a value that is selected when the BearSSL"]
#[doc = " library itself is compiled. Most options are boolean; their value is"]
#[doc = " then either 1 (option is enabled) or 0 (option is disabled). Some"]
#[doc = " values have other integer values. Option names correspond to macro"]
#[doc = " names. Some of the options can be explicitly set in the internal"]
#[doc = " `\"config.h\"` file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct br_config_option {
    #[doc = " \\brief Configurable option name."]
    pub name: *const cty::c_char,
    #[doc = " \\brief Configurable option value."]
    pub value: cty::c_long,
}
extern "C" {
    #[doc = " \\brief Get configuration report."]
    #[doc = ""]
    #[doc = " This function returns compiled configuration options, each as a"]
    #[doc = " 'long' value. Names match internal macro names, in particular those"]
    #[doc = " that can be set in the `\"config.h\"` inner file. For boolean options,"]
    #[doc = " the numerical value is 1 if enabled, 0 if disabled. For maximum"]
    #[doc = " key sizes, values are expressed in bits."]
    #[doc = ""]
    #[doc = " The returned array is terminated by an entry whose `name` is `NULL`."]
    #[doc = ""]
    #[doc = " \\return  the configuration report."]
    pub fn br_get_config() -> *const br_config_option;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
